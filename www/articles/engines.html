<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Estimation Engines • bamlss</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Estimation Engines">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">bamlss</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0.3</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/bamlss.html">Get started</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Vignettes
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/terms.html">Available Model Terms</a>
    </li>
    <li>
      <a href="../articles/glm.html">Generalized Linear Models (+)</a>
    </li>
    <li>
      <a href="../articles/families.html">Families</a>
    </li>
    <li>
      <a href="../articles/distregvis.html">Visualization with distreg.vis</a>
    </li>
    <li>
      <a href="../articles/rent.html">Munich Rent Example</a>
    </li>
    <li>
      <a href="../articles/zn.html">Spatial Location-Scale Model</a>
    </li>
    <li>
      <a href="../articles/engines.html">Estimation Engines</a>
    </li>
    <li>
      <a href="../articles/bf.html">BAMLSS Model Frame</a>
    </li>
    <li>
      <a href="../articles/misc.html">Miscellaneous Topics</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Publications
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/bivnorm.html">Bivariate Gaussian Models for Wind Vectors</a>
    </li>
    <li>
      <a href="../articles/lasso.html">LASSO-Type Penalization in the Framework of GAMLSS</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Estimation Engines</h1>
            
      
      
      <div class="hidden name"><code>engines.Rmd</code></div>

    </div>

    
    
<div id="intro" class="section level2">
<h2 class="hasAnchor">
<a href="#intro" class="anchor"></a>Intro</h2>
<p>For the estimation of model parameters the <em>bamlss</em> package provides a flexible infrastructure that allows the user to exchange both, optimization functions for posterior mode estimation (penalized likelihood) and sampling functions for full Bayesian Inference. This goes beyond the common modeling infrastructures that usually allow to create new family objects, only, and can be too restrictive for a couple of applications. Within the unified modeling approach in <em>bamlss</em> it is relatively straightforward to develop new estimation functions (algorithms), e.g., for implementing new models or for efficiency reasons. Such estimation functions could also interface to other software (see, e.g., the <code><a href="../reference/JAGS.html">JAGS()</a></code> sampling function). In the following, the basic requirements for optimizer and sampling functions are described in detail.</p>
</div>
<div id="the-basic-setup" class="section level2">
<h2 class="hasAnchor">
<a href="#the-basic-setup" class="anchor"></a>The basic setup</h2>
<p>Estimation engines in <em>bamlss</em> are usually based on the model frame setup function <code><a href="../reference/bamlss.frame.html">bamlss.frame()</a></code>, i.e., the functions all have a <code>x</code> argument, which contains all the necessary model and penalty matrices, and a <code>y</code> argument, which is the response (univariate or multivariate). In addition, an estimation engine usually has a <code>family</code> argument, which specifies the model to be estimated. However, this is not a mandatory argument, i.e., one could write an estimation function that is designed for one specific problem, only.</p>
<p>The modeling setup is best explained by looking at the main estimation engines provided by <em>bamlss</em>. The default optimizer using the <code><a href="../reference/bamlss.html">bamlss()</a></code> wrapper function is <code><a href="../reference/bfit.html">bfit()</a></code>, which is a backfitting routine. The most important arguments are</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/bfit.html">bfit</a></span>(x, y, family, <span class="dt">start =</span> <span class="ot">NULL</span>, <span class="dt">weights =</span> <span class="ot">NULL</span>, <span class="dt">offset =</span> <span class="ot">NULL</span>, ...)</code></pre></div>
<p>The default sampling engine in <em>bamlss</em> is <code><a href="../reference/GMCMC.html">GMCMC()</a></code>, again the most important arguments are</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/GMCMC.html">GMCMC</a></span>(x, y, family, <span class="dt">start =</span> <span class="ot">NULL</span>, <span class="dt">weights =</span> <span class="ot">NULL</span>, <span class="dt">offset =</span> <span class="ot">NULL</span>, ...)</code></pre></div>
<p>So basically, the arguments of the optimizer and the sampling function are the same, the main difference is the return value. In <em>bamlss</em> optimizer functions usually return a vector of estimated regression coefficients (parameters), while sampling functions return a matrix of parameter samples of class <code>"mcmc"</code> or <code>"mcmc.list"</code> (for details see the documentation of the <em>coda</em> package).</p>
<p>Internally, what the optimizer or sampling function is actually processing is not important for the <code><a href="../reference/bamlss.html">bamlss()</a></code> wrapper function as long as a vector or matrix of parameters is returned. For optimizer functions the return value needs to be named list with an element <code>"parameters"</code>, the vector (also a matrix, e.g., for <code><a href="../reference/lasso.html">lasso()</a></code> and <code><a href="../reference/boost.html">boost()</a></code> optimizers) of estimated parameters. The most important requirement to make use of all extractor functions like <code><a href="../reference/summary.bamlss.html">summary.bamlss()</a></code>, <code><a href="../reference/predict.bamlss.html">predict.bamlss()</a></code>, <code><a href="../reference/plot.bamlss.html">plot.bamlss()</a></code>, <code><a href="../reference/residuals.bamlss.html">residuals.bamlss()</a></code>, etc., is to follow the naming convention of the returned estimates. The parameter names are based on the names of the distribution parameters as specified in the family object. For example, the family object <code><a href="../reference/family.bamlss.html">gaussian_bamlss()</a></code> has parameter names <code>"mu"</code> and <code>"sigma"</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/family.bamlss.html">gaussian_bamlss</a></span>()$names</code></pre></div>
<pre><code>## [1] "mu"    "sigma"</code></pre>
<p>Then, each distributional parameter can be modeled by parametric (linear) and nonlinear smooth effect terms. The parametric part is indicated with <code>"p"</code> and the smooth part with <code>"s"</code>. The names of the parametric coefficients are the names of the corresponding model matrices as returned from <code><a href="../reference/bamlss.frame.html">bamlss.frame()</a></code>. E.g., if two linear effects, “<code>x1</code>” and <code>"x2"</code>, enter the model for distributional parameter <code>"mu"</code>, then the final names are <code>"mu.p.x1"</code> and <code>"mu.p.x2"</code>. Similarly for the smooth parts, if we model a variable <code>"x3"</code> using a regression spline as provided by the <code>s()</code> function of the <em>mgcv</em> package, the name is based on the names that are used by <code><a href="../reference/bamlss.frame.html">bamlss.frame()</a></code> for the <code><a href="../reference/smooth.construct.html">smooth.construct()</a></code> object. In this case the parameter names start with <code>"mu.s.s(x3)"</code>. If this smooth term has 10 regression coefficients, then the final name must be</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste0</a></span>(<span class="st">"mu.s.s(x3)"</span>, <span class="st">".b"</span>, <span class="dv">1</span>:<span class="dv">10</span>)</code></pre></div>
<pre><code>##  [1] "mu.s.s(x3).b1"  "mu.s.s(x3).b2"  "mu.s.s(x3).b3"  "mu.s.s(x3).b4" 
##  [5] "mu.s.s(x3).b5"  "mu.s.s(x3).b6"  "mu.s.s(x3).b7"  "mu.s.s(x3).b8" 
##  [9] "mu.s.s(x3).b9"  "mu.s.s(x3).b10"</code></pre>
<p>i.e., all smooth term parameters are named with “b” and a numerated.</p>
</div>
<div id="model-fitting-engines-for-linear-regression" class="section level2">
<h2 class="hasAnchor">
<a href="#model-fitting-engines-for-linear-regression" class="anchor"></a>Model fitting engines for linear regression</h2>
<p>In the following, to explain the setup and the naming convention of estimation engines in more detail, we implement</p>
<ul>
<li>a new family object for simple linear models <span class="math inline">\(y = x^{\top}\boldsymbol{\beta} + \varepsilon\)</span> with <span class="math inline">\(\varepsilon \sim N(0, \sigma^2)\)</span>,</li>
<li>and set up an optimizer function based on the <code><a href="https://www.rdocumentation.org/packages/stats/topics/lm">lm()</a></code> function,</li>
<li>and additionally a MCMC sampling function.</li>
</ul>
<p>For illustration, the family object is kept very simple, we only model the mean function in terms of covariates.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lm_bamlss &lt;-<span class="st"> </span>function(...) {
  f &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>(
    <span class="st">"family"</span> =<span class="st"> "LM"</span>,
    <span class="st">"names"</span> =<span class="st"> "mu"</span>,
    <span class="st">"links"</span> =<span class="st"> "identity"</span>,
    <span class="st">"d"</span> =<span class="st"> </span>function(y, par, <span class="dt">log =</span> <span class="ot">FALSE</span>) {
      sigma &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/MathFun">sqrt</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/sum">sum</a></span>((y -<span class="st"> </span>par$mu)^<span class="dv">2</span>) /<span class="st"> </span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(y) -<span class="st"> </span>.lm_bamlss.p))
      <span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Normal">dnorm</a></span>(y, <span class="dt">mean =</span> par$mu, <span class="dt">sd =</span> sigma, <span class="dt">log =</span> log)
    },
    <span class="st">"p"</span> =<span class="st"> </span>function(y, par, ...) {
      sigma &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/MathFun">sqrt</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/sum">sum</a></span>((y -<span class="st"> </span>par$mu)^<span class="dv">2</span>) /<span class="st"> </span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(y) -<span class="st"> </span>.lm_bamlss.p))
      <span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/Normal">pnorm</a></span>(y, <span class="dt">mean =</span> par$mu, <span class="dt">sd =</span> sigma, ...)
    }
  )
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span>(f) &lt;-<span class="st"> "family.bamlss"</span>
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(f)
}</code></pre></div>
<p>Now, for setting up the estimation functions we first simulate some data using the <code><a href="../reference/GAMart.html">GAMart()</a></code> function, afterwards the necessary <code>"bamlss.frame"</code> can be created with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Simulate some data.
d &lt;-<span class="st"> </span><span class="kw"><a href="../reference/GAMart.html">GAMart</a></span>()

## Setup a "bamlss.frame" object, that is used for
## developing the estimation functions for the linear model.
bf &lt;-<span class="st"> </span><span class="kw"><a href="../reference/bamlss.frame.html">bamlss.frame</a></span>(num ~<span class="st"> </span>x1 +<span class="st"> </span>x2, <span class="dt">data =</span> d, <span class="dt">family =</span> <span class="st">"lm"</span>)

## Print the structure of the "bamlss.frame".
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(bf)</code></pre></div>
<pre><code>## 'bamlss.frame' structure: 
##   ..$ call 
##   ..$ model.frame 
##   ..$ formula 
##   ..$ family 
##   ..$ terms 
##   ..$ x 
##   .. ..$ mu 
##   .. .. ..$ formula 
##   .. .. ..$ fake.formula 
##   .. .. ..$ terms 
##   .. .. ..$ model.matrix 
##   ..$ y 
##   .. ..$ num</code></pre>
<p>As noted above, the object is a named list with elements <code>"x"</code> and <code>"y"</code>, which will be passed to the estimation functions. For the moment, since we only implement a linear model, we need to work with the linear model matrix that is part of the <code>bf</code> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/utils/topics/head">head</a></span>(bf$x$mu$model.matrix))</code></pre></div>
<pre><code>##   (Intercept)        x1         x2
## 1           1 0.2875775 0.35360608
## 2           1 0.7883051 0.36644144
## 3           1 0.4089769 0.28710013
## 4           1 0.8830174 0.07997291
## 5           1 0.9404673 0.36545427
## 6           1 0.0455565 0.17801381</code></pre>
<p>and the response <code>"y"</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/utils/topics/head">head</a></span>(bf$y))</code></pre></div>
<pre><code>##            num
## 1  0.341704542
## 2 -0.373302161
## 3  0.007432787
## 4  0.163871126
## 5 -0.096522673
## 6  0.505487688</code></pre>
<p>to setup the optimizer function with:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Linear model optimizer function.
lm.opt &lt;-<span class="st"> </span>function(x, y, ...)
{
  ## Only univariate response.
  y &lt;-<span class="st"> </span>y[[1L]]

  ## For illustration this is easier to read.
  X &lt;-<span class="st"> </span>x$mu$model.matrix

  ## Estimate model parameters.
  par &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/drop">drop</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/chol2inv">chol2inv</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/chol">chol</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/crossprod">crossprod</a></span>(X))) %*%<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/crossprod">crossprod</a></span>(X, y))

  ## Set parameter names.
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/names">names</a></span>(par) &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste0</a></span>(<span class="st">"mu.p."</span>, <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/colnames">colnames</a></span>(X))

  ## Return estimated parameters and fitted values.
  rval &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>(
    <span class="st">"parameters"</span> =<span class="st"> </span>par,
    <span class="st">"fitted.values"</span> =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/drop">drop</a></span>(X %*%<span class="st"> </span>par),
    <span class="st">"edf"</span> =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(par),
    <span class="st">"sigma"</span> =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/drop">drop</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/MathFun">sqrt</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/crossprod">crossprod</a></span>(y -<span class="st"> </span>X %*%<span class="st"> </span>par) /<span class="st"> </span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(y) -<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/nrow">ncol</a></span>(X))))
  )

  ## Set edf within .GlobalEnv for the
  ## loglik() function in the lm_bamlss() family.
  .lm_bamlss.p &lt;&lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(par)

  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(rval)
}</code></pre></div>
<p>This optimizer function can already be used with the <code><a href="../reference/bamlss.html">bamlss()</a></code> wrapper function and all extractor functions are readily available.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Model formula with polynomial model terms.
f &lt;-<span class="st"> </span>num ~<span class="st"> </span>x1 +<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/poly">poly</a></span>(x2, <span class="dv">5</span>) +<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/poly">poly</a></span>(x3, <span class="dv">5</span>)

## Estimate model with new optimizer function.
b &lt;-<span class="st"> </span><span class="kw"><a href="../reference/bamlss.html">bamlss</a></span>(f, <span class="dt">data =</span> d, <span class="dt">family =</span> <span class="st">"lm"</span>, <span class="dt">optimizer =</span> lm.opt, <span class="dt">sampler =</span> <span class="ot">FALSE</span>)

## Summary output.
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/summary">summary</a></span>(b)</code></pre></div>
<pre><code>## 
## Call:
## bamlss(formula = f, family = "lm", data = d, optimizer = lm.opt, 
##     sampler = FALSE)
## ---
## Family: LM 
## Link function: mu = identity
## *---
## Formula mu:
## ---
## num ~ x1 + poly(x2, 5) + poly(x3, 5)
## -
## Parametric coefficients:
##              parameters
## (Intercept)       0.344
## x1               -0.677
## poly(x2, 5)1     -1.138
## poly(x2, 5)2      2.575
## poly(x2, 5)3      0.966
## poly(x2, 5)4     -1.504
## poly(x2, 5)5      1.201
## poly(x3, 5)1     -0.214
## poly(x3, 5)2      4.446
## poly(x3, 5)3      0.200
## poly(x3, 5)4     -0.052
## poly(x3, 5)5     -0.627
## ---
## Optimizer summary:
## -
## edf = 12 sigma = 0.2469
## ---</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Predict for term x2.
nd &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/data.frame">data.frame</a></span>(<span class="st">"x2"</span> =<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/seq">seq</a></span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">length =</span> <span class="dv">100</span>))
nd$p &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/predict">predict</a></span>(b, <span class="dt">newdata =</span> nd, <span class="dt">term =</span> <span class="st">"x2"</span>)</code></pre></div>
<p>Plot the estimated effect of <code>x2</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot2d.html">plot2d</a></span>(p ~<span class="st"> </span>x2, <span class="dt">data =</span> nd)</code></pre></div>
<p><img src="engines_files/figure-html/unnamed-chunk-12-1.png" width="480" style="display: block; margin: auto;"></p>
<p>The next step is to setup a full Bayesian MCMC sampling function. Fortunately, if we assume multivariate normal priors for the regression coefficients and an inverse Gamma prior for the variance, a Gibbs sampler with multivariate normal and inverse Gamma full conditionals can be created. The MCMC algorithm consecutively samples for <span class="math inline">\(t = 1, \ldots, T\)</span> from the full conditionals <span class="math display">\[
\boldsymbol{\beta}^{(t)} | \cdot \sim N\left(\boldsymbol{\mu}_{\boldsymbol{\beta}}^{(t - 1)}, 
  \boldsymbol{\Sigma}_{\boldsymbol{\beta}}^{(t - 1)}\right)
\]</span> and <span class="math display">\[ 
{\sigma^2}^{(t)} | \cdot \sim IG\left({a^{\prime}}^{(t - 1)}, {b^{\prime}}^{(t - 1)}\right),
\]</span> where <span class="math inline">\(IG( \cdot )\)</span> is the inverse Gamma distribution for sampling the variance parameter. The covariance matrix for <span class="math inline">\(\boldsymbol{\beta}\)</span> is given by <span class="math display">\[
\boldsymbol{\Sigma}_{\boldsymbol{\beta}} = \left(\frac{1}{\sigma^2}\mathbf{X}^\top\mathbf{X} +
  \frac{1}{\sigma^2}\mathbf{M}^{-1}\right)^{-1}
\]</span> and the mean <span class="math display">\[
\boldsymbol{\mu}_{\boldsymbol{\beta}} = \boldsymbol{\Sigma}_{\boldsymbol{\beta}}
  \left(\frac{1}{\sigma^2}\mathbf{X}^\top\mathbf{y} +
  \frac{1}{\sigma^2}\mathbf{M}^{-1}\mathbf{m}\right),
\]</span> where <span class="math inline">\(\mathbf{m}\)</span> is the prior mean and <span class="math inline">\(\mathbf{M}\)</span> the prior covariance matrix. Similarly, for <span class="math inline">\(\sigma^2\)</span> paramaters <span class="math inline">\(a^{\prime}\)</span> and <span class="math inline">\(b^{\prime}\)</span> are computed by <span class="math display">\[
a^{\prime} = a + \frac{n}{2} + \frac{p}{2}
\]</span> and <span class="math display">\[
b^{\prime} = b + \frac{1}{2}(\mathbf{y} -
  \mathbf{X}\boldsymbol{\beta})^\top(\mathbf{y} - \mathbf{X}\boldsymbol{\beta}) +
  \frac{1}{2} (\boldsymbol{\beta} - \mathbf{m})^\top \mathbf{M}^{-1}(\boldsymbol{\beta}
  - \mathbf{m}),
\]</span> where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are usually set small, e.g., with <span class="math inline">\(a = 1\)</span> and <span class="math inline">\(b = 0.0001\)</span>, such that the prior is flat and uninformative.</p>
<p>We can implement the MCMC algorithm in the following sampling function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lm.mcmc &lt;-<span class="st"> </span>function(x, y, <span class="dt">start =</span> <span class="ot">NULL</span>,
  <span class="dt">n.iter =</span> <span class="dv">12000</span>, <span class="dt">burnin =</span> <span class="dv">2000</span>, <span class="dt">thin =</span> <span class="dv">10</span>,
  <span class="dt">m =</span> <span class="dv">0</span>, <span class="dt">M =</span> <span class="fl">1e+05</span>,
  <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="fl">1e-05</span>,
  <span class="dt">verbose =</span> <span class="ot">TRUE</span>, ...)
{
  ## How many samples are saved?
  itrthin &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/seq">seq.int</a></span>(burnin, n.iter, <span class="dt">by =</span> thin)
  nsaves &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(itrthin)

  ## Only univariate response.
  y &lt;-<span class="st"> </span>y[[1L]]

  ## For illustration this is easier to read.
  X &lt;-<span class="st"> </span>x$mu$model.matrix

  ## Again, set edf within .GlobalEnv for the
  ## loglik() function in the lm_bamlss() family.
  .lm_bamlss.p &lt;&lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/nrow">ncol</a></span>(X)

  ## Number of observations and parameters.
  n &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(y)
  p &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/nrow">ncol</a></span>(X)

  ## Matrix saving the samples.
  samples &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/matrix">matrix</a></span>(<span class="dv">0</span>, nsaves, p +<span class="st"> </span>1L)

  ## Stick to the naming convention.
  pn &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste0</a></span>(<span class="st">"mu.p."</span>, <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/colnames">colnames</a></span>(X))
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/colnames">colnames</a></span>(samples) &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(
    pn,      ## Regression coefficients and
    <span class="st">"sigma"</span>  ## variance samples.
  )

  ## Setup coefficient vector,
  ## again, use correct names.
  beta &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/rep">rep</a></span>(<span class="dv">0</span>, p)
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/names">names</a></span>(beta) &lt;-<span class="st"> </span>pn
  sigma &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/sd">sd</a></span>(y)

  ## Check for starting values obtained,
  ## e.g., from lm.opt() from above.
  if(!<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/NULL">is.null</a></span>(start)) {
    sn &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/names">names</a></span>(start)
    for(j in <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/names">names</a></span>(beta)) {
      if(j %in%<span class="st"> </span>sn)
        beta[j] &lt;-<span class="st"> </span>start[j]
    }
  }

  ## Process prior information.
  m &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/rep">rep</a></span>(m, <span class="dt">length.out =</span> p)
  if(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(M) &lt;<span class="st"> </span><span class="dv">2</span>)
    M &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/rep">rep</a></span>(M, <span class="dt">length.out =</span> p)
  if(!<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/matrix">is.matrix</a></span>(M))
    M &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/diag">diag</a></span>(M)
  Mi &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/solve">solve</a></span>(M)

  ## Precompute cross products.
  XX &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/crossprod">crossprod</a></span>(X)
  Xy &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/crossprod">crossprod</a></span>(X, y)

  ## Inverse gamma parameter.
  a &lt;-<span class="st"> </span>a +<span class="st"> </span>n /<span class="st"> </span><span class="dv">2</span> +<span class="st"> </span>p /<span class="st"> </span><span class="dv">2</span>

  ## Start sampling.
  ii &lt;-<span class="st"> </span><span class="dv">1</span>
  for(i in <span class="dv">1</span>:n.iter) {
    ## Sampling sigma
    b2 &lt;-<span class="st"> </span>b +<span class="st"> </span><span class="dv">1</span> /<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/t">t</a></span>(y -<span class="st"> </span>X %*%<span class="st"> </span>beta) %*%<span class="st"> </span>(y -<span class="st"> </span>X %*%<span class="st"> </span>beta) +
<span class="st">      </span><span class="dv">1</span> /<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/t">t</a></span>(beta -<span class="st"> </span>m) %*%<span class="st"> </span>Mi %*%<span class="st"> </span>(beta -<span class="st"> </span>m)
    sigma2 &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/MathFun">sqrt</a></span>(<span class="dv">1</span> /<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/GammaDist">rgamma</a></span>(<span class="dv">1</span>, a, b2))

    ## Sampling beta.
    sigma2i &lt;-<span class="st"> </span><span class="dv">1</span> /<span class="st"> </span>sigma2
    Sigma &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/chol2inv">chol2inv</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/chol">chol</a></span>(sigma2i *<span class="st"> </span>XX +<span class="st"> </span>sigma2i *<span class="st"> </span>Mi))
    mu &lt;-<span class="st"> </span>Sigma %*%<span class="st"> </span>(sigma2i *<span class="st"> </span>Xy +<span class="st"> </span>sigma2i *<span class="st"> </span>Mi %*%<span class="st"> </span>m)
    beta &lt;-<span class="st"> </span>MASS::<span class="kw">mvrnorm</span>(<span class="dv">1</span>, mu, Sigma)
      
    if(i %in%<span class="st"> </span>itrthin) {
      samples[ii, pn] &lt;-<span class="st"> </span>beta
      samples[ii, <span class="st">"sigma"</span>] &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/MathFun">sqrt</a></span>(sigma2)
      ii &lt;-<span class="st"> </span>ii +<span class="st"> </span><span class="dv">1</span>
    }
    if(verbose) {
      if(i %%<span class="st"> </span><span class="dv">1000</span> ==<span class="st"> </span><span class="dv">0</span>)
        <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/cat">cat</a></span>(<span class="st">"iteration:"</span>, i, <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)
    }
  }

  ## Convert to "mcmc" object.
  samples &lt;-<span class="st"> </span><span class="kw">as.mcmc</span>(samples)

  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(samples)
}</code></pre></div>
<p>The new estimation function can be directly used with the <code><a href="../reference/bamlss.html">bamlss()</a></code> wrapper.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b &lt;-<span class="st"> </span><span class="kw"><a href="../reference/bamlss.html">bamlss</a></span>(f, <span class="dt">data =</span> d, <span class="dt">family =</span> <span class="st">"lm"</span>, <span class="dt">optimizer =</span> lm.opt, <span class="dt">sampler =</span> lm.mcmc)</code></pre></div>
<pre><code>## iteration: 1000 
## iteration: 2000 
## iteration: 3000 
## iteration: 4000 
## iteration: 5000 
## iteration: 6000 
## iteration: 7000 
## iteration: 8000 
## iteration: 9000 
## iteration: 10000 
## iteration: 11000 
## iteration: 12000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/summary">summary</a></span>(b)</code></pre></div>
<pre><code>## 
## Call:
## bamlss(formula = f, family = "lm", data = d, optimizer = lm.opt, 
##     sampler = lm.mcmc)
## ---
## Family: LM 
## Link function: mu = identity
## *---
## Formula mu:
## ---
## num ~ x1 + poly(x2, 5) + poly(x3, 5)
## -
## Parametric coefficients:
##                  Mean     2.5%      50%    97.5% parameters
## (Intercept)   0.34335  0.25194  0.34301  0.43597      0.344
## x1           -0.67776 -0.83802 -0.67661 -0.51787     -0.677
## poly(x2, 5)1 -1.13619 -2.10501 -1.14094 -0.14911     -1.138
## poly(x2, 5)2  2.57776  1.61974  2.55178  3.59514      2.575
## poly(x2, 5)3  0.95242  0.02486  0.94042  1.94693      0.966
## poly(x2, 5)4 -1.51261 -2.47971 -1.50229 -0.51755     -1.504
## poly(x2, 5)5  1.22412  0.25245  1.21497  2.20126      1.201
## poly(x3, 5)1 -0.23215 -1.27160 -0.22737  0.77661     -0.214
## poly(x3, 5)2  4.44849  3.48017  4.43948  5.46043      4.446
## poly(x3, 5)3  0.17578 -0.86734  0.17204  1.20828      0.200
## poly(x3, 5)4 -0.03387 -1.03739 -0.05553  0.96289     -0.052
## poly(x3, 5)5 -0.64516 -1.59706 -0.63726  0.38114     -0.627
## ---
## Sampler summary:
## -
## DIC = 105.551 pd = 48.6437 runtime = 2.006
## ---
## Optimizer summary:
## -
## edf = 12 sigma = 0.2469
## ---</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Predict for all terms including 95% credible intervals
nd$x1 &lt;-<span class="st"> </span>nd$x3 &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/seq">seq</a></span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dt">length =</span> <span class="dv">100</span>)
for(j in <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="st">"x1"</span>, <span class="st">"x2"</span>, <span class="st">"x3"</span>))
  nd[[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste0</a></span>(<span class="st">"p"</span>, j)]] &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/predict">predict</a></span>(b, <span class="dt">newdata =</span> nd, <span class="dt">term =</span> j, <span class="dt">FUN =</span> c95, <span class="dt">intercept =</span> <span class="ot">FALSE</span>)</code></pre></div>
<p>The estimated effects can be plotted with.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/par">par</a></span>(<span class="dt">mfrow =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw"><a href="../reference/plot2d.html">plot2d</a></span>(px1 ~<span class="st"> </span>x1, <span class="dt">data =</span> nd)
<span class="kw"><a href="../reference/plot2d.html">plot2d</a></span>(px2 ~<span class="st"> </span>x2, <span class="dt">data =</span> nd)
<span class="kw"><a href="../reference/plot2d.html">plot2d</a></span>(px3 ~<span class="st"> </span>x3, <span class="dt">data =</span> nd)</code></pre></div>
<p><img src="engines_files/figure-html/unnamed-chunk-16-1.png" width="960" style="display: block; margin: auto;"></p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<div id="refs" class="references">
<div id="ref-bamlss:Umlauf+bamlss:2018">
<p>Umlauf, Nikolaus, Nadja Klein, Achim Zeileis, and Thorsten Simon. 2019. <em>Bamlss: Bayesian Additive Models for Location Scale and Shape (and Beyond)</em>. <a href="https://CRAN.R-project.org/package=bamlss" class="uri">https://CRAN.R-project.org/package=bamlss</a>.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#intro">Intro</a></li>
      <li><a href="#the-basic-setup">The basic setup</a></li>
      <li><a href="#model-fitting-engines-for-linear-regression">Model fitting engines for linear regression</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Nikolaus Umlauf, Nadja Klein, Achim Zeileis, Thorsten Simon.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
