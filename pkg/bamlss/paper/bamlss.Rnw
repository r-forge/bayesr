\documentclass[nojss]{jss}
% \documentclass[article]{jss}
\usepackage{amsmath,amssymb,amsfonts,thumbpdf}
\usepackage{multirow,longtable}

\definecolor{darkgray}{rgb}{0.1,0.1,0.1}
\definecolor{heat1}{rgb}{0.8274510, 0.2470588, 0.4156863}
\definecolor{heat2}{rgb}{0.8823529, 0.4392157, 0.2980392}
\definecolor{heat3}{rgb}{0.9137255, 0.6039216, 0.1725490}
\definecolor{heat4}{rgb}{0.9098039, 0.7647059, 0.2352941}
\definecolor{heat5}{rgb}{0.8862745, 0.9019608, 0.7411765}
\definecolor{blue1}{RGB}{0, 126, 255}


%% additional commands
\newcommand{\squote}[1]{`{#1}'}
\newcommand{\dquote}[1]{``{#1}''}
\newcommand{\fct}[1]{{\texttt{#1()}\index{#1@\texttt{#1()}}}}
\newcommand{\class}[1]{\dquote{\texttt{#1}}}
%% for internal use
\newcommand{\fixme}[1]{\emph{\marginpar{FIXME} (#1)}}
\newcommand{\readme}[1]{\emph{\marginpar{README} (#1)}}

%% Authors: NU + rest in alphabetical order
\author{Nikolaus Umlauf\\Universit\"at Innsbruck \And
        Achim Zeileis\\Universit\"at Innsbruck}
\Plainauthor{Nikolaus Umlauf, Achim Zeileis}

\title{BAMLSS: Bayesian additive models for location, scale and shape (and beyond)}
\Plaintitle{BAMLSS: Bayesian additive models for location, scale and shape (and beyond)}

\Keywords{GAMLSS, distributional regression, MCMC, \proglang{BUGS}, \proglang{R}, software}
\Plainkeywords{GAMLSS, distributional regression, MCMC, BUGS, R, software}

\Abstract{
  Bayesian analysis provides a convenient setting for the estimation of complex generalized
  additive regression models (GAM). Since computational power has tremendously increased in the past
  decade it is now possible to tackle complicated inferential problems, e.g., with Markov chain
  Monte Carlo simulation, on virtually any modern computer. This is one of the reasons why
  Bayesian methods have become quite popular and it has lead to a number of highly specialized and
  optimized estimation engines. Because of the very general structure of the additive predictor in
  GAMs, we propose an unified modeling architecture that can deal with a wide range of types of
  model terms and can benefit from different algorithms in order to estimate Bayesian additive
  models for location, scale and shape (and beyond).
}

\Address{
  Nikolaus Umlauf, Achim Zeileis\\
  Department of Statistics\\
  Faculty of Economics and Statistics\\
  Universit\"at Innsbruck\\
  Universit\"atsstr.~15\\
  6020 Innsbruck, Austria\\
  E-mail: \email{Nikolaus.Umlauf@uibk.ac.at}, \email{Achim.Zeileis@R-project.org}\\
  URL: \url{http://eeecon.uibk.ac.at/~umlauf/},\\
  \phantom{URL: }\url{http://eeecon.uibk.ac.at/~zeileis/}
}

%% Sweave/vignette information and metadata
%% need no \usepackage{Sweave}
\SweaveOpts{engine = R, eps = FALSE, keep.source = TRUE}

<<preliminaries, echo=FALSE, results=hide>>=
options(width = 70, prompt = "R> ", continue = "+  ")
set.seed(1090)

library("bamlss")
library("maptools")

data("LondonFire")
data("Austria")

if(!file.exists("figures"))
  dir.create("figures")

epng <- function(file, height = 4, width = 5, res = 200, bg = "white") {
  png(file, height = height, width = width,
    units = "in", res = res, bg = bg)
}

main <- function(text, side = 3, line = 0.5, cex = 1.2, ...) {
  mtext(text, side = side, line = line, cex = cex, ...)
}
@


\begin{document}


\section{Introduction} \label{sec:intro}

The generalized additive model for location, scale and shape
(GAMLSS,~\citealp{bamlss:Rigby+Stasinopoulos:2005}) relaxes the distributional assumptions of
an response variable in a way that allows for modeling the mean (location) as well
as higher moments (scale and shape) in terms of covariates. This is
especially useful in cases where, e.g., the response does not follow the exponential family or
particular interest lies on scale and shape parameters. Moreover, covariate effects can have
arbitrary forms such as, e.g., linear, nonlinear, spatial or random effects. Hence, each parameter
of the distribution is linked to an additive predictor in similar fashion as for the well
established generalized additive model (GAM,~\citealp{bamlss:Hastie+Tibshirani:1990}).

The terms of an additive predictor are most commonly represented by a basis function approach. This
leads to a very generic model structure and can be further exploited because each term
can be transformed into a mixed model representation
\citep{bamlss:Ruppert+Wand+Carrol:2003, bamlss:Wand:2003}. In a full Bayesian setting, this
generality remains because priors on parameters can also be formalized in general way, e.g.,
by assigning normal priors on the regression coefficients of smooth terms
\citep{bamlss:Fahrmeir+Kneib+Lang+Marx:2013, bamlss:Brezger+Lang:2006}.

The full Bayesian approach using Marcov Chain Monte Carlo (MCMC) simulation is particularly
attractive since it provides inference that does not rely on asymptotic properties and allows
extensions such as variable selection or multilevel models.
Probably for this reason, and because computational power has tremendously increased in the past
decade, the number of Bayesian estimation engines that can tackle complicated inferential problems
has seen a constant rise. As a whole, existing estimation engines already provide infrastructures
for a number of regression problems exceeding univariate responses, e.g., for multinomial,
multivariate normal or mixed discrete-continuous distributed variables, and so forth. In addition,
most of the engines support random effect estimation which in the end can in principle be utilized
for setting up complex models with additive predictors (see, e.g., \citealp{bamlss:Wood:2006}).

However, the majority of engines (Bayesian and frequentist) use different model setups and output 
formats, which makes it difficult for practitioners, e.g., to compare properties of
different algorithms or to select the appropriate distribution and variables, etc. The reasons are
manifold: the use of different model specification languages like
\proglang{BUGS}~\citep{bamlss:BUGS:2009} or \proglang{R}~\citep{bamlss:R}; different standalone
statistical software packages like \pkg{BayesX}~\citep{bamlss:Umlauf+Adler+Kneib+Lang+Zeileis:2014,
bamlss:Belitz+Brezger+Kneib+Lang:2011}, \pkg{JAGS}~\citep{bamlss:Plummer:2013},
\pkg{Stan}~\citep{bamlss:stan-software:2013} or
\pkg{WinBUGS}~\citep{bamlss:Lunn+Thomas+Best+Spiegelhalter:2000}; or even differences within the
same environment.

In order to ease the usage of already existing implementations and code, as well as to facilitate
the development of new algorithms and extensions, we present an unified and entirely modular
architecture for models with additive predictors that does not restrict to any type of regression
problem. Hence, the approach supports more than the GAMLSS statistical model class and is sometimes
referred to as distributional regression. However, because of the great similarities with GAMLSS we
call the conceptional framework Bayesian additive models for location, scale and shape (BAMLSS).

The remainder of the paper is as follows. In Section~\ref{sec:models} the models supported by this
framework are briefly introduced. Section~\ref{sec:legobox} presents the lego bricks that can be
utilized for model building and estimation. In Section~\ref{sec:comptools} computational strategies
for the implemenation are presented. Section \ref{sec:softex} briefly introduces the \proglang{R}
implementation using two examples.


\section{Model structure and overview} \label{sec:models}

Supposing data of $i = 1, \ldots, n$ observations is available, the models discussed in this paper
assume conditional independence of individual response observations given covariates.
Within the GAMLSS model class all parameters of the response distribution can be modeled by
explanatory variables such that
\begin{equation} \label{eqn:dreg}
y \sim \mathbf{\mathcal{D}}\left(h_{1}(\theta_{1}) = \eta_{1}, \,\,
  h_{2}(\theta_{2}) = \eta_{2}, \dots, \,\, h_{K}(\theta_{K}) =
  \eta_{K}\right),
\end{equation}
where $\mathbf{\mathcal{D}}$ denotes any distribution available for the response
variable $y$ and $\theta_k$, $k = 1, \ldots, K$, are parameters that are linked to additive predictors
using known monotonic and twice differentiable functions
$h_{k}(\cdot)$ \citep{bamlss:Rigby+Stasinopoulos:2005}. Note that the response may also be a
q-dimensional vector $\mathbf{y} = (y_{1}, \ldots, y_{q})^\top$, e.g., when
$\mathbf{\mathcal{D}}$ is a multivariate normal density
(see, e.g., \citealp{bamlss:Klein+Kneib+Klasen+Lang:2014}).
The $k$-th additive predictor is given by
\begin{equation} \label{eqn:structadd}
\eta_k = \eta_k(\mathbf{x}; \boldsymbol{\beta}_k) =
  f_{1k}(\mathbf{x}; \boldsymbol{\beta}_{1k}) + \ldots + f_{J_kk}(\mathbf{x}; \boldsymbol{\beta}_{J_kk}),
\end{equation}
with unspecified (possibly nonlinear) functions $f_{jk}(\cdot)$ of a generic covariate vector
$\mathbf{x}$, $j = 1, \ldots, J_k$ and $k = 1, \ldots, K$. In the following, we only assume that
each function $f_{jk}(\cdot)$ is a composition of covariate data $\mathbf{x}$ and regression
coefficients $\boldsymbol{\beta}_{jk}$, hence, $f_{jk}(\cdot)$ are not necessarily linear
functions or functions that have a linear representation, only. More specifically, a simple linear
effect of one continuous covariate could be given by
$f_{jk}(\mathbf{x}, \boldsymbol{\beta}_{jk}) = x_{1}\beta$, whereas a nonlinear effect
$f_{jk}(\mathbf{x}, \boldsymbol{\beta}_{jk}) = f(x_{1})$
could, e.g., be modeled by regression splines or a technique that is nonlinear in the
parameters like growth curves, amongst others. More examples that are covered by this framework are:
Spatially correlated effects of some discrete location index, varying coefficients, spatially
varying effects, random intercepts and slopes, etc. Also note that each predictor in
(\ref{eqn:dreg}) may contain a different set of covariate effects 
supporting very complex structures with arbitrary combinations. This general framework is also
known as structured additive regression
(STAR,~\citealp{bamlss:Fahrmeir+Kneib+Lang:2004, bamlss:Brezger+Lang:2006}) and covers a number of
well known model classes that have been developed for the exponential family of distributions as
special cases, e.g., generalized additive models (GAM, \citealp{bamlss:Hastie+Tibshirani:1990}),
generalized additive mixed models (GAMM, \citealp{bamlss:Lin+Zhang:1999}), geoadditive models
\citep{bamlss:Kamman+Wand:2003}, varying coefficient models \citep{bamlss:Hastie+Tibshirani:1993},
and geographically weighted regression \citep{bamlss:Fotheringham+Brunsdon+Charlton:2002}.


\section{A conceptional Lego toolbox} \label{sec:legobox}

\subsection{Terms and priors} \label{sec:termprior}

In the following, we assume that for each function $f_{jk}(\cdot)$ the vector of function evaluations
$\mathbf{f}_{jk} = (f_{jk}(\mathbf{x}_{1}),\ldots,f_{jk}(\mathbf{x}_{n}))^{\top}$ of the
$i = 1, \ldots, n$ observations is a composition of
\begin{equation} \label{eqn:functions}
\mathbf{f}_{jk} = f_{jk}(\mathbf{X}_{jk}, \boldsymbol{\beta}_{jk}),
\end{equation}
where $\mathbf{X}_{jk}$ ($n \times m_{jk}$) is a design matrix and the structure of $\mathbf{X}_{jk}$
only depends on the type of covariate(s) and prior assumptions. The vector $\boldsymbol{\beta}_{jk}$
($q_{jk} \times 1$) are regression coefficients that need to be estimated. Hence, the predictor
(\ref{eqn:structadd}) may be written as $\boldsymbol{\eta}_k = \mathbf{f}_{1k} + \ldots + \mathbf{f}_{J_kk}$.
The computation of the vector $\mathbf{f}_{jk}$ is in most cases a matrix product of the design matrix
and the coefficients, however as already noted, the framework presented here allows for arbitrary
functional types that may not have this structure, e.g., nonlinear growth curve estimation of covariates.
In the frequentist setting, to ensure regularization, e.g., for penalizing too abrupt jumps using a
P(enalised)-spline representation of $f_{jk}(\cdot)$ \citep{bamlss:Eilers+Marx:1996}, it is common to add a
penalty $\text{pen}(\mathbf{f}_{jk}) = \text{pen}(\boldsymbol{\beta}_{jk})$ to the regression problem.
Within the Bayesian formulation, the equivalent is to put prior distributions $p(\cdot)$ on
the regression coefficients $\boldsymbol{\beta}_{jk}$. The following outlines frequently used terms
and corresponding priors for parameters within STAR predictors (\ref{eqn:structadd}).

\subsubsection{Linear effects}

Linear or parametric effects can be written as a simple matrix product
$\mathbf{f}_{jk} = \mathbf{X}_{jk}\boldsymbol{\beta}_{jk}$. A common choice of $p(\boldsymbol{\beta}_{jk})$
is to use a non-informative uniform prior
\begin{equation} \label{eqn:uniprior}
p(\boldsymbol{\beta}_{jk}) \propto 1.
\end{equation}
One of the simplest
informative priors is a normal prior given by
\begin{equation} \label{eqn:linprior}
p(\boldsymbol{\beta}_{jk}) \propto \exp \left(- \frac{1}{2}
  (\boldsymbol{\beta}_{jk} - \mathbf{m}_{jk})^{\top}\mathbf{M}_{jk}^{-1}(\boldsymbol{\beta}_{jk} -
  \mathbf{m}_{jk})\right),
\end{equation}
with prior mean $\mathbf{m}_{jk}$ and prior covariance matrix $\mathbf{M}_{jk}$. In a lot of applications
a vague prior specification is used with $\mathbf{m}_{jk} = \mathbf{0}$ and a large variance.

\subsubsection{Nonlinear effects} \label{sec:smootheffects}

Although the functional forms may be rather complex within predictor (\ref{eqn:structadd}),
sometimes including more than one covariate, it is again possible to obtain a linear representation
$\mathbf{f}_{jk} = \mathbf{X}_{jk}\boldsymbol{\beta}_{jk}$ using a basis function approach. Here, the columns
of the design matrix $\mathbf{X}_{jk}$ hold the so called basis functions which are predetermined by
the type of the function chosen. More specifically, for functions of a single covariate commonly
used basis functions are B-splines or thin plate splines, which are also capable to estimate higher
dimensional functions. Moreover, higher dimensional functions can always be obtained by tensor
product basis construction of marginal basis of an arbitrary number of covariates. A detailed
overview of smooth functions constructed from various basis functions is provided in
\citet{bamlss:Fahrmeir+Kneib+Lang+Marx:2013} and \citet{bamlss:Wood:2006}.

The elegance of the approach is that regularization of the possibly very complex functions is
accomplished by placing a generic multivariate normal prior
\begin{equation} \label{eqn:shrinkprior}
p(\boldsymbol{\beta}_{jk}) \propto \left( \frac{1}{\tau_{jk}^2} \right)^{rk(\mathbf{K}_{jk}) / 2} \exp \left(- \frac{1}{2\tau_{jk}^2}
\boldsymbol{\beta}_{jk}^{\top}\mathbf{K}_{jk}\boldsymbol{\beta}_{jk}\right)
\end{equation}
on the regression coefficients $\boldsymbol{\beta}_{jk}$, where the precision matrix $\mathbf{K}_{jk}$
corresponds to the frequentist's penalty matrix and depends on the type of function
associated with the term. The variance parameter $\tau_{jk}^2$ is equivalent to the inverse smoothing
parameter in a frequentist approach and controls the trade off between flexibility and smoothness.
Note that within this notion a ridge penalty on linear effects can be obtained by
$\mathbf{K}_{jk} = \mathbf{I}$, similarly independent and identically distributed (i.i.d.) random
effects can be incorporated using prior (\ref{eqn:shrinkprior}).
A common choice of prior for the variance parameter is a weakly informative inverse Gamma hyperprior
\begin{equation} \label{eqn:ig}
p(\tau_{jk}^2) = \frac{b_{jk}^{a_{jk}}}{\Gamma(a_{jk})} (\tau_{jk}^2)^{-(a_{jk} + 1)} \exp(-b_{jk} / \tau_{jk}^2).
\end{equation}
with $a_{jk} = b_{jk} = 0.001$ as a standard option. Small values for $a_{jk}$ and $b_{jk}$ correspond to an 
approximate uniform distribution for $\log(\tau_{jk}^2)$. However, the default option of the inverse
Gamma prior for variance parameters needs to be reconsidered in some cases, e.g., it might be
problematic if $\tau_{jk}$ is close to zero, since the results a very sensitive on the choice of
$a_{jk}$ and $b_{jk}$. Therefore, \citet{bamlss:Gelman:2006} proposes to use the half-Cauchy prior
\begin{equation} \label{eqn:hcauchy}
p(\tau_{jk}) = \frac{2A_{jk}}{\pi (\tau_{jk}^2 + A_{jk}^2)}, \quad A_{jk} > 0.
\end{equation}
For $A_{jk} \rightarrow \infty$ the prior is uniform, hence large values (e.g., $A_{jk} = 25$) result in
weakly informative priors. A desirable property of the half-Cauchy is that for $\tau_{jk} = 0$ the
density is a nonzero constant, whereas the density of the inverse Gamma for $\tau_{jk} \rightarrow 0$
vanishes (see also \citealp{bamlss:Polson+Scott:2012}).

In addition, the individual model components $\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}$ for any basis
function specification can be further decomposed into a mixed model representation given by
\begin{equation*} \label{eqn:mixed}
\mathbf{f}_{jk} = \tilde{\mathbf{X}}_{jk}\tilde{\boldsymbol{\gamma}}_{jk} +
  \mathbf{U}_{jk}\tilde{\boldsymbol{\beta}}_{jk},
\end{equation*}
where $\tilde{\boldsymbol{\gamma}}_{jk}$ represents the fixed effects parameters and 
$\tilde{\boldsymbol{\beta}}_{jk} \sim N(\mathbf{0}, \tau^2_{jk}\mathbf{I})$ i.i.d.\ random effects.
The design matrix $\mathbf{U}_{jk}$ is derived from a spectral decomposition of the penalty matrix
$\mathbf{K}_{jk}$ and $\tilde{\mathbf{X}}_{jk}$ by finding a basis of the null space of $\mathbf{K}_{jk}$
such that $\tilde{\mathbf{X}}_{jk}^{\top}\mathbf{K}_{jk} = \mathbf{0}$, i.e., parameters
$\tilde{\boldsymbol{\gamma}}_{jk}$ are not penalized (see, e.g.,
\citealp{bamlss:Fahrmeir+Kneib+Lang+Marx:2013, bamlss:Ruppert+Wand+Carrol:2003, bamlss:Wand:2003}).

\subsubsection{Further effects}

Within the scope of the presented framework we allow for functions of covariates that cannot
necessarily be written by a matrix product $\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}$. As an
example, nonlinear growth curve estimation with the Gompertz function requires the evaluation of
$$
\mathbf{f}_{jk} = \beta_{1} \cdot \exp \left( -\exp\left( \beta_{2} +
  \mathbf{X}_{jk}\beta_{3} \right) \right)
$$
and particular interest may lie on the parameters describing the growth rate, lag phase, etc.
As a standard option one can put non-informative uniform priors (\ref{eqn:uniprior}) or normal
priors (\ref{eqn:linprior}) on $\boldsymbol{\beta}$. To generalize this, the framework allows for
any functions $f_{jk}(\mathbf{X}_{jk}, \boldsymbol{\beta}_{jk})$ and prior(s) $p(\boldsymbol{\beta}_{jk})$
that are available for the covariate(s).

%The representation of the terms in the structured additive predictor (\ref{eqn:structadd})
%already suggests a general and modular architecture. However, to keep the focus on maximum
%flexibility of the conceptional framework it is useful to list the typical steps needed to estimate
%the models presented in Section~\ref{sec:models}:
%\begin{enumerate}
%\item Choosing an appropriate distribution for the response.
%\item Specification of the model terms the parameters are modeled by.
%\item Setting up the corresponding design and penalty matrices.
%\item Starting the estimation engine.
%\item Processing the results for printing summaries, plotting, etc. 
%\end{enumerate}
%Step 2 thereby requires some type of generic model formula syntax to actually specify the
%dependencies of the parameters on covariates. Choosing an appropriate distribution in step 1 implies
%that the estimation engine used in step 4 includes the corresponding implementation. In addition,
%to compute, e.g., goodness of fit plots using quantile residuals \citep{bamlss:Dunn+Gordon:1996},
%the distribution specification oftentimes needs information beyond the log-likelihood function.
%Moreover, the individual steps should be modular, e.g., changing the estimation engine does not
%require additional adjustments on subsequent infrastructures. The following describes the
%conceptional building blocks in more detail.

\subsection{Response distribution} \label{sec:density}

%Any statistical software for regression models needs some description system for the supported
%distributions. Since most estimation algorithms have at least one common part, a modular system
%with reusable elements arises naturally from the following characterizations.

The main building block of regression model algorithms is the probability density function
$f(\mathbf{y} | \boldsymbol{\theta}_1, \ldots, \boldsymbol{\theta}_K)$, or for
computational reasons its logarithm.
Note that $f$ is considered to be a general density and $\boldsymbol{\theta}_k$, $k = 1, \ldots, K$,
are parameters that are linked to STAR predictors given in equation (\ref{eqn:structadd}).
Estimation typically requires to evaluate the log-likelihood function
\begin{equation} \label{eqn:density}
\ell(\boldsymbol{\beta} ; \mathbf{y}, \mathbf{X}) =
  \sum_{i = 1}^n \log \, f(y_i ; \theta_{i1} = h_1^{-1}(\eta_{i1}(\mathbf{x}_i, \boldsymbol{\beta}_1)), \ldots,
  \theta_{iK} = h_K^{-1}(\eta_{iK}(\mathbf{x}_i, \boldsymbol{\beta}_K)))
\end{equation}
a number of times, where the vector
$\boldsymbol{\beta} = (\boldsymbol{\beta}_1^\top, \ldots, \boldsymbol{\beta}_K^\top)^\top$ 
comprises all model coefficients that should be estimated, $\mathbf{X} = (\mathbf{X}_1, \ldots, \mathbf{X}_K)$
are the respective covariate matrices with $\mathbf{x}_i$ as the $i$-th row of $\mathbf{X}$ and
$\boldsymbol{\theta}_k$ are vectors of length $n$.
Assigning prior distributions to the individual model components, e.g., given by the normal
prior (\ref{eqn:shrinkprior}) and the inverse gamma prior (\ref{eqn:ig}), results in the log-posterior
\begin{equation} \label{eqn:logpost}
\log \, p(\boldsymbol{\vartheta} ; \mathbf{y}, \mathbf{X}) \propto
  \ell(\boldsymbol{\beta} ; \mathbf{y}, \mathbf{X}) +
  \sum_{k = 1}^K\sum_{j = 1}^{J_k} \left\{ \log \, p_{jk}(\boldsymbol{\vartheta}_{jk}) \right\},
\end{equation}
where, e.g., $\boldsymbol{\vartheta}_{jk} = (\boldsymbol{\beta}_{jk}^\top, (\boldsymbol{\tau}^2_{jk})^\top)^\top$
is a vector of all parameters associated to the $jk$-th term and includes all variances, too, and
prior $p_{jk}(\cdot)$ denotes the combination of all assigned priors on parameters
$\boldsymbol{\vartheta}_{jk}$. Also note that from a frequentist perspective (\ref{eqn:logpost}) can
be viewed as a penalized log-likelihood using prior (\ref{eqn:shrinkprior}) for fixed variance
parameters $\boldsymbol{\tau}_{jk}^2$.


\subsection{Model fitters} \label{sec:modelfit}

Bayesian point estimates of $\boldsymbol{\vartheta}$ are obtained by posterior mode, mean or median
estimation. While posterior mode estimation requires maximization of the log-posterior
(\ref{eqn:logpost}), which has an unique (sometimes analytical) solution in a number of cases,
posterior mean and median estimation involves solving (possibly) high-dimensional integrals, usually
requiring computer intensive techniques such as Markov chain Monte Carlo simulation. The
following describes the quantities needed for generic iterative algorithms for estimating Bayesian
distributional regression models.

\subsubsection{Posterior mode} \label{sec:postmode}

The mode of the posterior distribution is the mode of the log-posterior (\ref{eqn:logpost}) given by
\begin{equation}
\text{Mod}(\boldsymbol{\vartheta} ; \mathbf{y}, \mathbf{X}) =
  \underset{\boldsymbol{\vartheta}}{\text{arg max }} \log \, p(\boldsymbol{\vartheta} ; \mathbf{y}. \mathbf{X})
\end{equation}
and equals the maximum likelihood estimator
\begin{equation}
\text{ML}(\boldsymbol{\vartheta} ; \mathbf{y}, \mathbf{X}) =
  \underset{\boldsymbol{\vartheta}}{\text{arg max }} \ell(\boldsymbol{\beta} ; \mathbf{y}, \mathbf{X})
\end{equation}
assigning uniform priors (\ref{eqn:uniprior})
for $j = 1, \ldots, J_k$, $k = 1, \ldots, K$.
For models involving shrinkage priors, e.g., given by (\ref{eqn:shrinkprior}), the posterior mode is
equivalent to a penalized maximum likelihood estimator for fixed variance parameters
$\boldsymbol{\tau}_{jk}^2$ and $p(\boldsymbol{\tau}_{jk}^2) \propto 1$. Moreover, the structure of
(\ref{eqn:logpost}) prohibits simultaneous estimation of
$\boldsymbol{\vartheta}_{jk} = (\boldsymbol{\beta}_{jk}^\top, (\boldsymbol{\tau}^2_{jk})^\top)^\top$ and the
estimator $\hat{\boldsymbol{\tau}}^2_{jk}$ is usually derived by additionally
minimizing an information criterion such as the Akaike information criterion (AIC) or the Bayesian
information criterion (BIC) (see also \citealp{bamlss:Rigby+Stasinopoulos:2005} Appendix~A.2. for
a more detailed discussion on variance/hyperparameter estimation). In the following we describe
posterior mode estimation for the case of fixed and known parameters $\boldsymbol{\tau}_{jk}^2$,
i.e., $\boldsymbol{\vartheta}_{jk} = \boldsymbol{\beta}_{jk}$ for
$j = 1, \ldots, J_k$ and $k = 1, \ldots, K$.
Estimation of $\boldsymbol{\beta} = (\boldsymbol{\beta}_1^\top, \ldots, \boldsymbol{\beta}_K^\top)^\top$
requires solving equations
$\partial (\log \, p(\boldsymbol{\vartheta} | \mathbf{y})) / \partial \boldsymbol{\beta} = \mathbf{0}$
and usually the problem is solved with an iterative updating scheme of the form
\begin{equation} \label{eqn:updating}
\boldsymbol{\beta}^{(t + 1)} = U(\boldsymbol{\beta}^{(t)}),
\end{equation}
with updating function $U(\cdot)$ and $\hat{\boldsymbol{\beta}}$ as a fixed point of the iteration.
A particularly convenient way to maximize (\ref{eqn:logpost}) is a Newton-Raphson type updating
\begin{equation} \label{eqn:newton}
\boldsymbol{\beta}^{(t + 1)} = U(\boldsymbol{\beta}^{(t)}) = \boldsymbol{\beta}^{(t)} -
  \mathbf{H}\left( \boldsymbol{\beta}^{(t)} \right)^{-1}\mathbf{s}\left( \boldsymbol{\beta}^{(t)} \right)
\end{equation}
with score vector
\begin{equation} \label{eqn:score}
\mathbf{s}(\boldsymbol{\beta}) = 
  \frac{\partial \log \, p(\boldsymbol{\vartheta} ; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\beta}}
= \frac{\partial \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\beta}} +
    \sum_{k = 1}^K\sum_{j = 1}^{J_k} \left\{ \frac{\partial \log \, p_{jk}(\boldsymbol{\beta}_{jk})}{\partial \boldsymbol{\beta}} \right\}.
\end{equation}
and hessian matrix $\mathbf{H}(\boldsymbol{\beta})$ with components
\begin{equation} \label{eqn:hessian}
\mathbf{H}_{ks}(\boldsymbol{\beta}) =
\frac{\partial \mathbf{s}(\boldsymbol{\beta}_k)}{\partial \boldsymbol{\beta}_s^\top} =
\frac{\partial^2 \log \, p(\boldsymbol{\vartheta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\beta}_k \partial \boldsymbol{\beta}_s^\top},
\end{equation}
for $k = 1, \dots, K$ and $s = 1, \dots, K$. By chain rule, the part of the score vector involving
the derivatives of the log-likelihood for the $k$th parameter can be further decomposed to
\begin{equation} \label{eqn:score2}
\frac{\partial \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\beta}_k} =
  \frac{\partial \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\eta}_k}
  \frac{\partial \boldsymbol{\eta}_k}{\partial \boldsymbol{\beta}_k} = 
  \frac{\partial \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\theta}_k}
  \frac{\partial \boldsymbol{\theta}_k}{\partial \boldsymbol{\eta}_k}
  \frac{\partial \boldsymbol{\eta}_k}{\partial \boldsymbol{\beta}_k},
\end{equation}
including the derivatives of the log-likelihood with respect to parameters $\boldsymbol{\theta}_k$,
the derivative of the link functions and the derivative of the STAR predictor
$\boldsymbol{\eta}_k$ with respect to coefficients $\boldsymbol{\beta}_k$. Again by chain rule,
the components of $\mathbf{H}_{ks}$ including $\ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})$ can be
written as
\begin{equation} \label{hessian2}
\frac{\partial^2 \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\beta}_k \partial \boldsymbol{\beta}_s^\top} =
\left( \frac{\partial \boldsymbol{\eta}_s}{\partial \boldsymbol{\beta}_s} \right)^\top
\frac{\partial^2 \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\eta}_k\partial \boldsymbol{\eta}_s^\top}
\frac{\partial \boldsymbol{\eta}_k}{\partial \boldsymbol{\beta}_k}
\,\, \underbrace{
  \, + \, \frac{\partial \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\eta}_k}
    \frac{\partial^2 \boldsymbol{\eta}_k}{\partial^2 \boldsymbol{\beta}_k}}_{\text{if } k = s},
\end{equation}
where the second term drops if all functions (\ref{eqn:functions}) can be written as a linear
combination of a design matrix and coefficients, e.g., when using a basis function approach. Within
the first term, the second derivatives of the log-likelihood involving the predictors can be written
as
\begin{equation} \label{hessian3}
\frac{\partial^2 \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\eta}_k\partial \boldsymbol{\eta}_s^\top} =
  \frac{\partial \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\theta}_k}
  \frac{\partial^2 \boldsymbol{\theta}_k}{\partial \boldsymbol{\eta}_k \partial \boldsymbol{\eta}_s^\top} + 
  \frac{\partial^2 \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X})}{\partial \boldsymbol{\theta}_k \partial \boldsymbol{\theta}_s^\top}
  \frac{\partial \boldsymbol{\theta}_k}{\partial \boldsymbol{\eta}_k}
  \frac{\partial \boldsymbol{\theta}_s}{\partial \boldsymbol{\eta}_s}
\end{equation}
involving the second derivatives of the link functions.

Although solving the updating scheme (\ref{eqn:newton}) is feasible, from the computational
perspective of the model class it is still a bit unhandy. Fortunately, the problem of iteratively
finding the roots for $\boldsymbol{\beta}$ can be partitioned into separate updating equations
using leapfrog or zigzag iteration \citep{bamlss:Smyth:1996}. Now let
\begin{eqnarray} \label{eqn:pupdate}
\boldsymbol{\beta}_1^{(t + 1)} &=& U_1(\boldsymbol{\beta}_1^{(t)}, \boldsymbol{\beta}_2^{(t)},
  \ldots, \boldsymbol{\beta}_K^{(t)}) \nonumber \\
\boldsymbol{\beta}_2^{(t + 1)} &=& U_2(\boldsymbol{\beta}_1^{(t+1)}, \boldsymbol{\beta}_2^{(t)},
  \ldots, \boldsymbol{\beta}_K^{(t)}) \nonumber \\
  &\vdots& \nonumber \\
\boldsymbol{\beta}_K^{(t + 1)} &=& U_K(\boldsymbol{\beta}_1^{(t+1)}, \boldsymbol{\beta}_2^{(t+1)},
  \ldots, \boldsymbol{\beta}_K^{(t)})
\end{eqnarray}
be a partitioned updating scheme with updating functions $U_k(\cdot)$, i.e., in each iteration
one parameter is maximized holding the other parameters fixed. Note that this updating scheme can be
further partitioned for each function within parameter block $k$, leading to a highly modular
system.

For parameters $\boldsymbol{\beta}_k$, the updating scheme can be written as a $k$-partitioned
Newton-Raphson iteration
\begin{equation} \label{eqn:blocknewton}
\boldsymbol{\beta}_k^{(t + 1)} = U_k(\boldsymbol{\beta}_k^{(t)} | \cdot) = \boldsymbol{\beta}_k^{(t)} -
  \mathbf{H}_{kk}\left( \boldsymbol{\beta}_k^{(t)} \right)^{-1}\mathbf{s}_k\left( \boldsymbol{\beta}_k^{(t)} \right).
\end{equation}
Assuming a basis function approach for functions (\ref{eqn:functions}) with multivariate normal
priors (\ref{eqn:shrinkprior}), the hessian matrix in (\ref{eqn:blocknewton}) is given by
$$
\mathbf{H}_{kk}\left( \boldsymbol{\beta}_k^{(t)} \right) =
\begin{pmatrix}
\mathbf{X}_{1k}^\top\mathbf{W}_{kk}\mathbf{X}_{1k} + \mathbf{G}_{1k} &
  \cdots & \mathbf{X}_{1k}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk} \\
\vdots & \ddots & \vdots \\
\mathbf{X}_{J_kk}^\top\mathbf{W}_{kk}\mathbf{X}_{1k} & \cdots & \mathbf{X}_{J_kk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk} + \mathbf{G}_{J_kk}
\end{pmatrix}^{(t)},
$$
with diagonal weight matrix $\mathbf{W}_{kk} = -\mathrm{diag}(\partial^2 \ell(\boldsymbol{\beta} | \mathbf{y}) /
\partial \boldsymbol{\eta}_k \partial \boldsymbol{\eta}_k^\top)$ and penalty matrix
$\mathbf{G}_{jk} = \tau_{jk}^{-2}\mathbf{K}_{jk}$. Similarly, the score vector is
$$
\mathbf{s}_k\left( \boldsymbol{\beta}_k^{(t)} \right) =
\begin{pmatrix}
\mathbf{X}_{1k}^\top \mathbf{u}_k^{(t)} - \mathbf{G}_{1k}\boldsymbol{\beta}_{1k}^{(t)} \\
\vdots \\
\mathbf{X}_{J_kk}^\top \mathbf{u}_k^{(t)} - \mathbf{G}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t)} \\
\end{pmatrix}
$$
and derivatives $\mathbf{u}_k = \partial \ell(\boldsymbol{\beta} | \mathbf{y}) /
\partial \boldsymbol{\eta}_k$. Focusing on the $j$th row of (\ref{eqn:blocknewton}) gives
\begin{eqnarray*}
(\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})\boldsymbol{\beta}_{jk}^{(t+1)} +
\ldots + \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t + 1)} - \\
(\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})\boldsymbol{\beta}_{jk}^{(t)} -
\ldots - \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t)}
  &=& \mathbf{X}_{jk}^\top \mathbf{u}_k^{(t)} - \mathbf{G}_{jk}\boldsymbol{\beta}_{jk}^{(t)}
\end{eqnarray*}
\begin{eqnarray*}
\mathbf{G}_{jk}(\boldsymbol{\beta}_{jk}^{(t+1)} - \boldsymbol{\beta}_{jk}^{(t)}) +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t+1)} + \ldots +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t+1)} - \\
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t)} - \ldots -
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t)}
  &=& \mathbf{X}_{jk}^\top \mathbf{u}_k^{(t)} - \mathbf{G}_{jk}\boldsymbol{\beta}_{jk}^{(t)}
\end{eqnarray*}
\begin{eqnarray*}
\mathbf{G}_{jk}\boldsymbol{\beta}_{jk}^{(t)} +
  \mathbf{G}_{jk}(\boldsymbol{\beta}_{jk}^{(t+1)} - \boldsymbol{\beta}_{jk}^{(t)}) +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t+1)} + \ldots +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t+1)} - \\
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t)} - \ldots -
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t)}
  &=& \mathbf{X}_{jk}^\top \mathbf{u}_k^{(t)}
\end{eqnarray*}
\begin{eqnarray*}
\mathbf{G}_{jk}\boldsymbol{\beta}_{jk}^{(t+1)} +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t+1)} + \ldots +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t+1)} - \\
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t)} - \ldots -
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{J_kk}\boldsymbol{\beta}_{J_kk}^{(t)}
  &=& \mathbf{X}_{jk}^\top \mathbf{u}_k^{(t)}
\end{eqnarray*}
\begin{eqnarray*}
\mathbf{G}_{jk}\boldsymbol{\beta}_{jk}^{(t+1)} +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t+1)} + 
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\boldsymbol{\eta}_{k, -j}^{(t+1)} -
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\boldsymbol{\eta}_{k}^{(t)}
  &=& \mathbf{X}_{jk}^\top \mathbf{u}_k^{(t)}
\end{eqnarray*}
\begin{eqnarray*}
(\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})\boldsymbol{\beta}_{jk}^{(t+1)}
  &=& \mathbf{X}_{jk}^\top \mathbf{u}_k^{(t)} + \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\boldsymbol{\eta}_{k}^{(t)} -
    \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\boldsymbol{\eta}_{k, -j}^{(t+1)}
\end{eqnarray*}
\begin{eqnarray*}
  \boldsymbol{\beta}_{jk}^{(t+1)}
  &=& (\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})^{-1}(\mathbf{X}_{jk}^\top \mathbf{u}_k^{(t)} +
    \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\boldsymbol{\eta}_{k}^{(t)} -
    \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\boldsymbol{\eta}_{k, -j}^{(t+1)})
\end{eqnarray*}
\begin{eqnarray*}
  \boldsymbol{\beta}_{jk}^{(t+1)}
  &=& (\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})^{-1}\mathbf{X}_{jk}^\top(\mathbf{u}_k^{(t)} +
    \mathbf{W}_{kk}\boldsymbol{\eta}_{k}^{(t)} -
    \mathbf{W}_{kk}\boldsymbol{\eta}_{k, -j}^{(t+1)})
\end{eqnarray*}
\begin{eqnarray*}
  \boldsymbol{\beta}_{jk}^{(t+1)}
  &=& (\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})^{-1}\mathbf{X}_{jk}^\top(
    \mathbf{W}_{kk}\mathbf{W}_{kk}^{-1}\mathbf{u}_k^{(t)} +
    \mathbf{W}_{kk}\boldsymbol{\eta}_{k}^{(t)} -
    \mathbf{W}_{kk}\boldsymbol{\eta}_{k, -j}^{(t+1)})
\end{eqnarray*}
\begin{eqnarray*}
  \boldsymbol{\beta}_{jk}^{(t+1)}
  &=& (\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})^{-1}\mathbf{X}_{jk}^\top\mathbf{W}_{kk}(
    \mathbf{W}_{kk}^{-1}\mathbf{u}_k^{(t)} +
    \boldsymbol{\eta}_{k}^{(t)} -
    \boldsymbol{\eta}_{k, -j}^{(t+1)})
\end{eqnarray*}
\begin{eqnarray} \label{eqn:blockbackfit}
  \boldsymbol{\beta}_{jk}^{(t+1)}
  &=& (\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})^{-1}\mathbf{X}_{jk}^\top\mathbf{W}_{kk}(
    \mathbf{z}_k - \boldsymbol{\eta}_{k, -j}^{(t+1)})
\end{eqnarray}
with working observations
$\mathbf{z}_k = \boldsymbol{\eta}_{k}^{(t)} + \mathbf{W}_{kk}^{-1}\mathbf{u}_k^{(t)}$.
Hence, this leads to a backfitting algorithm and cycling through (\ref{eqn:blockbackfit}) for
terms $j = 1, \ldots, J_k$ and parameters $k = 1, \ldots, K$ is approximate to a single
Newton-Raphson step in (\ref{eqn:newton}), because cross derivatives are not incorporated and
therefore overall convergence will be slower.
Note that this yields the ingredients of the \emph{RS}-algorithm developed in
\citet{bamlss:Rigby+Stasinopoulos:2005} Appendix~B.2. The updating scheme (\ref{eqn:blockbackfit})
can be further generalized to
$$
\mathbf{f}_{jk}^{(t)} = \mathbf{S}_{jk}\left(\mathbf{z}_k - \boldsymbol{\eta}_{k, -j}^{(t+1)}\right)
$$
i.e., theoretically any smoother function $\mathbf{S}_{jk}( \cdot )$ applied on the
``partial residuals'' can be used. For optimization, different strategies of the backfitting
algorithm (\ref{eqn:blockbackfit}) can be applied. One alternative is an inner backfitting algorithm
for each parameter $k$, i.e., the backfitting procedure updates
$\boldsymbol{\beta}_{jk}$, for $j = 1, \ldots, J_k$ until convergence, afterwards updates for
parameters for the next $k$ are calculated again by an inner backfitting algorithm, and so forth
(see also \citealp{bamlss:Rigby+Stasinopoulos:2005}).

Note that for numerical reasons it is oftentimes better to replace the hessian by the expected
Fisher information with weights $\mathbf{W}_{kk} = -\mathrm{diag}(E(\partial^2 \ell(\boldsymbol{\beta} | \mathbf{y}) /
\partial \boldsymbol{\eta}_k \partial \boldsymbol{\eta}_k^\top))$.

\newpage

\subsubsection{Posterior mean} \label{sec:postmean}

The mean of the posterior distribution is
\begin{equation} \label{eqn:postmean}
E(\boldsymbol{\vartheta}; \mathbf{y}, \mathbf{X}) =
  \int \boldsymbol{\vartheta} p(\boldsymbol{\vartheta}; \mathbf{y}, \mathbf{X})d\boldsymbol{\vartheta}.
\end{equation}
Clearly, the problem in deriving the expectation, and other quantities like the posterior median,
relies on the computation of the usually high-dimensional integral, which can be rarely solved
analytically and needs to be approximated by numerical techniques.  

MCMC simulation is commonly used in such situations as it provides an extendable framework that can 
adapt to almost any type of problem. Moreover, computational power has increases tremendously in the
past decade and even computer intensive algorithms are feasible on simple desktop computers today.
In the following we summarize three sampling techniques that are especially suited for this
modeling framework, i.e., techniques that can be used for a highly modular and extendable system.
Similarly to updating scheme (\ref{eqn:pupdate}) we consider samples that are drawn for blocks of
parameters, more specifically, the sampling schemes successively update the parameters of a single
function (\ref{eqn:functions}). Note that for some models there exist full conditionals that can
be derived in closed form from the log-posterior (\ref{eqn:logpost}), however, we especially focus
on situations were this is not generally the case.
MCMC samples for the regression coefficients $\boldsymbol{\beta}_{jk}$ can be derived by each of the
following methods:
\begin{itemize}
\item \emph{Random-walk Metropolis}: \label{sec:rwm} \\
  Probably the most important algorithm, because of its generality and easy implementation, is
  random-walk Metropolis. The sampler
  proceeds by drawing a candidate $\boldsymbol{\beta}_{jk}^{\star}$ from a symmetric jumping
  distribution $q(\boldsymbol{\beta}_{jk}^{\star}| \boldsymbol{\beta}_{jk}^{(t)})$, the
  candidate is then accepted as the new state of the Markov chain with probability
  $$
  \alpha\left( \boldsymbol{\beta}_{jk}^{\star} | \boldsymbol{\beta}_{jk}^{(t)}\right) =
  \text{min} \left\{ \frac{p(\boldsymbol{\beta}_{jk}^{\star} | \cdot)}{
    p(\boldsymbol{\beta}_{jk}^{(t)} | \cdot)}, 1 \right\}
  $$
  with the log-posterior $p(\boldsymbol{\beta}_{jk} | \cdot)$ evaluated at the proposed and
  current value.
  Commonly, the jumping distribution is a normal distribution $N(\boldsymbol{\beta}_{jk}^{(t)}, \boldsymbol{\Sigma}_{jk})$ centered at the current iterate and fixed covariance matrix. Although this algorithm
  is theoretically working for any distribution, the actual sampling performance depends heavily on
  starting values and the scaling of $\boldsymbol{\Sigma}_{jk}$. Therefore, numerous methods that
  try to optimize the behavior of the Markov chain in an adaptive phase (burnin phase) have been
  developed. In the seminal paper of \citet{bamlss:Gelman+Roberts+Gilks:1996}, strategies that
  optimize the acceptance rate to roughly $1/4$ are suggested to obtain a good mixing (see also
  \citealp{bamlss:Gareth+Roberts+Jeffrey+Rosenthal:2009}). Similarly,
  within the presented modeling framework and a basis function approach with multivariate normal
  prior (\ref{eqn:shrinkprior}), a convenient way is to set
  $\boldsymbol{\Sigma}_{jk} = \sigma_{jk}\mathbf{K}_{jk}^{-1}$ and optimize $\sigma_{jk}$ to the
  desired properties in the adaptive phase.

\item \emph{Derivative based Metropolis-Hastings}: \label{sec:dmh} \\
  A commonly used alternative for the covariance matrix of the jumping distribution
  $N(\boldsymbol{\beta}_{jk}^{(t)}, \boldsymbol{\Sigma}_{jk})$ is to use the local curvature
  information
  $$
  \boldsymbol{\Sigma}_{jk} = -\left( \frac{\partial^2 p(\boldsymbol{\vartheta}; \mathbf{y}, \mathbf{X})}{
    \partial \boldsymbol{\beta}_{jk}\boldsymbol{\beta}_{jk}^\top} \right)^{-1}
  $$
  computed at the posterior mode estimate $\hat{\boldsymbol{\beta}}_{jk}$. However, fixing
  $\boldsymbol{\Sigma}_{jk}$ during MCMC simulation might still lead to undesired behavior of the
  Markov chain especially when iterates move into regions with low probability mass of the
  posterior distribution. A solution is to construct full conditionals
  $p(\boldsymbol{\beta}_{jk} | \cdot)$
  which approximate the posterior at the current iterate and minimize the risk of slow traversing.
  The construction of the full conditional is based on a second order Taylor series expansion
  of the log-posterior centered at the last state
  \begin{eqnarray*}
  p(\boldsymbol{\beta}_{jk}^\star | \cdot) &\propto& \exp\left\{
    ln\,p\left(\boldsymbol{\beta}_{jk}^{(t)} | \cdot\right) +
    \left(\boldsymbol{\beta}_{jk}^\star - \boldsymbol{\beta}_{jk}^{(t)}\right)^\top s\left(\boldsymbol{\beta}_{jk}^{(t)}\right) + \right.\\
  && \left. \frac{1}{2}\left(\boldsymbol{\beta}_{jk}^\star - \boldsymbol{\beta}_{jk}^{(t)}\right)^\top
    \mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)
    \left(\boldsymbol{\beta}_{jk}^\star - \boldsymbol{\beta}_{jk}^{(t)}\right)\right\} \\
  &\propto& \exp\left\{(\boldsymbol{\beta}_{jk}^\star)^\top s\left(\boldsymbol{\beta}_{jk}^{(t)}\right) +
    \left(\frac{1}{2}(\boldsymbol{\beta}_{jk}^\star)^\top\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right) - \right.\right. \\
  && \qquad\qquad\left.\left. \frac{1}{2}(\boldsymbol{\beta}_{jk}^{(t)})^\top\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right) \right)\left(\boldsymbol{\beta}_{jk}^\star - \boldsymbol{\beta}_{jk}^{(t)}\right)\right\} \\
  &\propto& \exp\left\{(\boldsymbol{\beta}_{jk}^\star)^\top s\left(\boldsymbol{\beta}_{jk}^{(t)}\right) +
    \frac{1}{2}(\boldsymbol{\beta}_{jk}^\star)^\top\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^\star - \right. \\
  && \left. \qquad\qquad \frac{1}{2}(\boldsymbol{\beta}_{jk}^\star)^\top\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^{(t)} -
    \frac{1}{2}(\boldsymbol{\beta}_{jk}^{(t)})^\top\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^\star \right\} \\
  &=& \exp\left\{
    \frac{1}{2}(\boldsymbol{\beta}_{jk}^\star)^\top\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^\star +
    (\boldsymbol{\beta}_{jk}^\star)^\top s\left(\boldsymbol{\beta}_{jk}^{(t)}\right) -
    (\boldsymbol{\beta}_{jk}^\star)^\top\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^{(t)} \right\} \\
  &=& \exp\left\{
    -\frac{1}{2}(\boldsymbol{\beta}_{jk}^\star)^\top-\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^\star +
    (\boldsymbol{\beta}_{jk}^\star)^\top \left(s\left(\boldsymbol{\beta}_{jk}^{(t)}\right) - \mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^{(t)}\right) \right\}
  \end{eqnarray*}
  which is proportional to a multivariate normal distribution with precision matrix
  $$
  \left(\boldsymbol{\Sigma}_{jk}^{(t)}\right)^{-1} = -\mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)
  $$
  and mean
  \begin{eqnarray*}
  \boldsymbol{\mu}_{jk}^{(t)} &=& \boldsymbol{\Sigma}_{jk}^{(t)}\left\{
    s\left(\boldsymbol{\beta}_{jk}^{(t)}\right) -
    \mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)\boldsymbol{\beta}_{jk}^{(t)} \right\} \\
  &=& \boldsymbol{\beta}_{jk}^{(t)} -
    \mathbf{H}_{kk}\left(\boldsymbol{\beta}_{jk}^{(t)}\right)^{-1}
    s\left(\boldsymbol{\beta}_{jk}^{(t)}\right).
  \end{eqnarray*}
  Note that the mean is simply one Newton or Fisher scoring iteration towards the posterior mode.
  Hence, the proposal density for $\boldsymbol{\beta}_{jk}$ is
  $q(\boldsymbol{\beta}_{jk}^\star | \boldsymbol{\beta}_{jk}^{(t)}) =
    N(\boldsymbol{\mu}_{jk}^{(t)}, \boldsymbol{\Sigma}_{jk}^{(t)})$ and the acceptance probability
  of the candidate is then computed by
  $$
  \alpha\left( \boldsymbol{\beta}_{jk}^{\star} | \boldsymbol{\beta}_{jk}^{(t)}\right) =
  \text{min} \left\{ \frac{p(\boldsymbol{\beta}_{jk}^{\star} | \cdot)q(\boldsymbol{\beta}_{jk}^{(t)} | \boldsymbol{\beta}_{jk}^\star)}{
    p(\boldsymbol{\beta}_{jk}^{(t)} | \cdot)q(\boldsymbol{\beta}_{jk}^\star | \boldsymbol{\beta}_{jk}^{(t)})  }, 1 \right\}.
  $$
  Again, assuming a basis
  function approach with multivariate normal priors (\ref{eqn:shrinkprior}) the precision matrix is
  $$
  \left(\boldsymbol{\Sigma}_{jk}^{(t)}\right)^{-1} = \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk},
  $$
  with weights $\mathbf{W}_{kk} = -\mathrm{diag}(\partial^2 \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X}) /
\partial \boldsymbol{\eta}_k \partial \boldsymbol{\eta}_k^\top)$ and the mean can be written as
  \begin{eqnarray*}
  \boldsymbol{\mu}_{jk}^{(t)} &=& \boldsymbol{\Sigma}_{jk}^{(t)}\left\{
  \mathbf{X}_{jk}^\top\mathbf{u}_k^{(t)} - \mathbf{G}_{jk}\boldsymbol{\beta}_{jk}^{(t)} +
  (\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk} + \mathbf{G}_{jk})\boldsymbol{\beta}_{jk}^{(t)}\right\} \\
  &=& \boldsymbol{\Sigma}_{jk}^{(t)}\left\{
  \mathbf{X}_{jk}^\top\mathbf{u}_k^{(t)} +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\mathbf{X}_{jk}\boldsymbol{\beta}_{jk}^{(t)}\right\} \\
  &=& \boldsymbol{\Sigma}_{jk}^{(t)}\left\{
  \mathbf{X}_{jk}^\top\mathbf{u}_k^{(t)} +
  \mathbf{X}_{jk}^\top\mathbf{W}_{kk}\left(\boldsymbol{\eta}_k^{(t)} - \boldsymbol{\eta}^{(t)}_{k,-j}\right)\right\} \\
  &=& \boldsymbol{\Sigma}_{jk}^{(t)}\mathbf{X}_{jk}^\top\left\{
  \mathbf{u}_k^{(t)} + \mathbf{W}_{kk}\left(\boldsymbol{\eta}_k^{(t)} - \boldsymbol{\eta}^{(t)}_{k,-j}\right)\right\} \\
  &=& \boldsymbol{\Sigma}_{jk}^{(t)}\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\left\{
  \boldsymbol{\eta}_k^{(t)} + \mathbf{W}_{kk}^{-1}\mathbf{u}_k^{(t)}  - \boldsymbol{\eta}^{(t)}_{k,-j}\right\} \\
  &=& \boldsymbol{\Sigma}_{jk}^{(t)}\mathbf{X}_{jk}^\top\mathbf{W}_{kk}\left\{\mathbf{z}_k  - \boldsymbol{\eta}^{(t)}_{k,-j}\right\}
  \end{eqnarray*}
  with working observations
  $\mathbf{z}_k = \boldsymbol{\eta}_k^{(t)} + \mathbf{W}_{kk}^{-1}\mathbf{u}_k^{(t)}$. Therefore,
  the computation of the mean is equivalent to a full Newton step, or Fisher scoring when using
  $-E(\partial^2 \ell(\boldsymbol{\beta}; \mathbf{y}, \mathbf{X}) /
    \partial \boldsymbol{\eta}_k \partial \boldsymbol{\eta}_k^\top)$,
  in each iteration of the MCMC sampler using iteratively reweighted least squares (IWLS)
  \citep{bamlss:Gamerman:1997, bamlss:Brezger+Lang:2006, bamlss:Klein+Kneib+Klasen+Lang:2014}. If
  the computation of the weights $\mathbf{W}_{kk}$ is expensive, one simple strategy is to update
  $\mathbf{W}_{kk}$ only after samples all parameters of $\boldsymbol{\theta}_k$ are drawn.

\item \emph{Slice sampling}: \label{sec:smcmc} \\
  Slice sampling \citep{bamlss:Neal:2003} is a gradient free MCMC sampling scheme that produces
  samples with $100\%$ acceptance rate. Therefore, and because of the simplicity of the algorithm,
  slice sampling is especially useful for automated general purpose MCMC implementations that allow
  for sampling from many distributions. The basic slice
  sampling algorithm samples univariate directly under the plot of the log-posterior
  (\ref{eqn:logpost}). Updates for the $i$-th parameter with $\boldsymbol{\vartheta}_{jk}$ are
  generated by:
  \begin{enumerate}
  \item Sample $h \sim U(0, p(\vartheta_{ijk}^{(t)} | \cdot))$.
  \item Sample $\vartheta_{ijk}^{(t+1)} \sim U(S)$ from the horizontal slice
    $S = \{\vartheta_{ijk}: h < p(\vartheta_{ijk} | \cdot)\}$.
  \end{enumerate}
\end{itemize}

The full conditional $p(\tau_{jk} | \cdot)$ for smoothing variances is commonly constructed using
priors for $\tau_{jk}$ that lead to known distributions, i.e., simple Gibbs sampling is possible.
E.g., this is the case when using an inverse Gamma prior (\ref{eqn:ig}) in combination with
the normal prior (\ref{eqn:shrinkprior}), then $p(\tau_{jk} | \cdot)$ is again an inverse Gamma
distribution with
$$
\tilde{a}_{jk} = \frac{1}{2}rk(\mathbf{K}_{jk}) + a_{jk}, \qquad
  \tilde{b}_{jk} = \frac{1}{2}(\boldsymbol{\beta}_{jk}^\star)^\top\mathbf{K}_{jk}
  \boldsymbol{\beta}_{jk}^\star + b_{jk}.
$$
As mentioned in Section \ref{sec:smootheffects}, other priors than the inverse Gamma might be
desirable. However, in most applications estimating the smooth effects using the inverse Gamma works
particulary well. If a simple Gibbs sampling step cannot be derived, another easy to implement
strategy is to use slice sampling, since the number of smoothing variances is usually not very large
the computational burden does most of the times not exceed possible benefits.


\subsection{Inference and prediction} \label{sec:infpred}

Inference for parameters $\boldsymbol{\beta}_{jk}$ can be based on the asymptotic normality of the
posterior distribution, which is valid for any posterior distribution under suitable regularity
conditions.


\subsection{Lego bricks} \label{sec:leobricks}

From the above, it can be recognized that the following quantities are repeatedly used within
BAMLSS candidate algorithms:
\begin{itemize}
\item The density function $f(\mathbf{y} | \boldsymbol{\theta}_1, \ldots, \boldsymbol{\theta}_K)$.
\item The first order derivatives
  $\partial \ell(\boldsymbol{\vartheta} | \mathbf{y}) / \partial \boldsymbol{\theta}_k$,
  $\partial \boldsymbol{\theta}_k / \partial \boldsymbol{\eta}_k$ and
  $\partial \boldsymbol{\eta}_k / \partial \boldsymbol{\vartheta}_k$.
\item Second order derivatives
  $\partial^2 \ell(\boldsymbol{\vartheta} | \mathbf{y}) / \partial \boldsymbol{\eta}_k \partial \boldsymbol{\eta}_k^\top$.
\item Derivatives for priors, e.g., $\log \, p(\boldsymbol{\beta}_{jk} | \tau_{jk}^2)$ and $\log \, p(\tau_{jk}^2)$.
\end{itemize}
Hence, a modular family specification system can in principle be used to implement various
estimation algorithms. A simple generic algorithm for BAMLSS models is outlined by the 
following pseudo code:
\begin{center}
\begin{minipage}[c]{13cm}
\code{while(eps >} $\varepsilon\,$ \code{\& i < maxit) \{ } \\
\hspace*{0.5cm} \code{for(k in 1:K) \{} \\
\hspace*{1cm} \code{for(j in 1:p) \{} \\
\hspace*{1.5cm} Compute $\boldsymbol{\eta}^{\texttt{[k]}}_{\texttt{-j}} = \boldsymbol{\eta}^{\texttt{[k]}} - \mathbf{f}_{\texttt{j}}^{\texttt{[k]}}$. \\
\hspace*{1.5cm} Obtain new $(\boldsymbol{\beta}^{\texttt{[k]}}_{\texttt{j}}, {\tau^2}^{\texttt{[k]}}_{\texttt{j}})^\top = \texttt{u}_{\texttt{j}}^{\texttt{[k]}}(\mathbf{y}, \boldsymbol{\eta}^{\texttt{[k]}}_{\texttt{-j}},
  \mathbf{x}^{\texttt{[k]}}_{\texttt{j}}, \boldsymbol{\beta}^{\texttt{[k]}}_{\texttt{j}}, {\tau^2}^{\texttt{[k]}}_{\texttt{j}}, \texttt{family}, \texttt{k})$. \\
\hspace*{1.5cm} Update $\boldsymbol{\eta}^{\texttt{[k]}}$. \\
\hspace*{1cm} \code{\}} \\
\hspace*{0.5cm} \code{\}} \\
\hspace*{0.5cm} Compute new \code{eps} \\
\code{\}}
\end{minipage}
\end{center}
The algorithm does not distinguish between the frequentist or Bayesian approach, because the 
functions $\texttt{u}_{\texttt{j}}^{\texttt{[k]}}( \cdot )$ could either return proposals from
a MCMC sampler or updates from an optimizing algorithm like the IWLS. Therefore, $\varepsilon$ 
(e.g., $0.0001$) and \code{eps} represent the stopping mechanism in an optimizer while
\code{maxit} controls the maximum iterations of a MCMC sampler, too. To achieve this flexibility a
\code{family} object that contains all distribution specific information to compute the new
parameters
$(\boldsymbol{\beta}^{\texttt{[k]}}_{\texttt{j}}, {\tau^2}^{\texttt{[k]}}_{\texttt{j}})^\top$ is
required, e.g., containing the log-likelihood function, the first and second order derivatives,
etc., as described in the above.

%In practice, only few implementations support an entirely modular setup that can be
%extended by the user. Examples that do support some flexibility are the \proglang{R}
%model fitting functions \fct{glm}, \fct{gam} as well as function \fct{gamlss} of package \pkg{gamlss}
%\citep{bamlss:Stasinopoulos+Rigby:2014}.


\section{Computational tools and strategies for implementation} \label{sec:comptools}

\subsection{Symbolic descriptions} \label{sec:symdesc}

Based on \citet{bamlss:Wilkinson+Rogers:1973} symbolic descriptions for specifying models have been
implemented for various computer programs. The statistical environment \proglang{R} provides such
a syntax (see also \citealp{bamlss:Chambers+Hastie:1992}), which is familiar to almost any common
\proglang{R} user today. Without such specifications, that in the end translate model formulae into
model frames, the estimation of regression models is very circumstantial, especially in the case of
structured additive predictors (\ref{eqn:structadd}). Therefore, the \proglang{R} model formula
language is also extensible. The recommended package \pkg{mgcv}~\citep{bamlss:Wood:2014} for
estimating GAMs additionally provides the generic descriptor \code{s()} for smooth terms. However,
to conveniently specify the models presented in Section~\ref{sec:models}, a slightly enhanced syntax
is required.

Hereinafter, we follow the notation of the \proglang{R} formula language and denote
smooth and random effect terms with the \code{s()} descriptor. A typical linear regression model 
with a response variable \code{y} and covariates \code{x1} and \code{x2} is then represented by
\begin{center}
\code{y} $\sim$ \code{x1 + x2}
\end{center}
A model with two additional nonlinear modeled terms of covariates \code{z1}, \code{z2} and \code{z3}
is set up with
\begin{center}
\begin{tabular}{l}
\code{y} $\sim$ \code{x1 + x2 + s(z1) + s(z2, z3)}
\end{tabular}
\end{center}
However, in the context of distributional regression we need formula extensions for multiple
parameters. A convenient way to specify, e.g., the parameters of a normal model with
$y~\sim~N(\mu = \eta_{\mu}, log(\sigma) = \eta_{\sigma})$ is given by
\begin{center}
{ \renewcommand{\arraystretch}{1}
\begin{tabular}{l}
\code{list(} \\
$\quad$ \code{y} $\sim$ \code{x1 + x2 + s(z1) + s(z2),} \\
$\quad$ \code{sigma} $\sim$ \code{x1 + x2 + s(z1)} \\
\code{)}
\end{tabular}
}
\end{center}
i.e., two formulas are provided where the first represents the description of the mean $\mu$
and the second of the scale parameter $\sigma$. Furthermore, the two formulas
are symbolically connected by a list of formulas that is send to the subsequent processor. This way
any number of parameters can be easily specified, e.g., a four parameter example is
\begin{center}
{ \renewcommand{\arraystretch}{1}
\begin{tabular}{l}
\code{list(} \\
$\quad$ \code{y} $\sim$ \code{x1 + x2 + s(z1) + s(z2),} \\
$\quad$ \code{sigma2} $\sim$ \code{x1 + x2 + s(z1),} \\
$\quad$ \code{nu} $\sim$ \code{s(z1),} \\
$\quad$ \code{tau} $\sim$ \code{s(z2)} \\
\code{)}
\end{tabular}
}
\end{center}
A convention we make at this point is that
the mean formula is always the one including the response variable and all other formulas
have the corresponding parameter name on the left hand side. Hence, a mapping of terms with 
parameters is provided.

Within this syntax it is also possible to incorporate multilevel models with STAR predictor
\citep{bamlss:Lang+Umlauf+Wechselberger+Harttgen+Kneib:2014}, where a hierarchy of
units or clusters grouped at different levels is given. Suppose there is data on three levels
available, where variable \code{id1} denotes the indicator from the individual observations to the
second level with lower resolution and \code{id2} is another indicator mapping from the second to
third level. A four parameter model with 3 levels can be specified with
\begin{center}
{ \renewcommand{\arraystretch}{1}
\begin{tabular}{l}
\code{list(} \\
$\quad$ \code{y} $\sim$ \code{x1 + x2 + s(z1) + s({\color{heat1}{id1}}),} \\
$\quad$ {\color{heat1}{\code{id1} $\sim$ \code{x3 + s(z3) + s(}}}\code{\color{blue1}{id2}}\code{\color{heat1})}\code{,} \\
$\quad$ {\color{blue1}{\code{id2} $\sim$ \code{s(z4)}}}\code{,} \\
$\quad$ \code{sigma2} $\sim$ \code{x1 + x2 + s(z1),} \\
$\quad$ \code{nu} $\sim$ \code{s(z1) + s({\color{heat1}{id1}}),} \\
$\quad$ \code{tau} $\sim$ \code{s(z2)} \\
\code{)}
\end{tabular}
}
\end{center}
Note that the mean and \code{nu} parameter include the indicator variable \code{id1}, therefore,
the level two and three formulas are incorporated in both specifications.

In addition, models with categorical responses can be formulated in a similar fashion. A model
with three categories within the \code{y} variable, e.g., a multinomial model with some
reference category can be defined by
\begin{center}
{ \renewcommand{\arraystretch}{1}
\begin{tabular}{l}
\code{list(} \\
$\quad$ \code{y} $\sim$ \code{x1 + s(z1) + s(z2),} \\
$\quad$ $\sim$ \code{x1 + x2 + s(z1) + s(z3)} \\
\code{)}
\end{tabular}
}
\end{center}
where all subsequent formulas do not need a left hand side. The only additional assumption here is
that the order of the formulas represents the order of the categories. Another option is to specify
the formulas of each category explicitly by
\begin{center}
{ \renewcommand{\arraystretch}{1}
\begin{tabular}{l}
\code{list(} \\
$\quad$ \code{response1} $\sim$ \code{x1 + s(z1) + s(z2),} \\
$\quad$ \code{response2} $\sim$ \code{x1 + x2 + s(z1) + s(z3)} \\
\code{)}
\end{tabular}
}
\end{center}
i.e., variable \code{response1} is a dummy variable indicating whether the $i$th observation is in
category 1 and \code{response2} in category 2, respectively.

In summary, the described model definition syntax does not restrict to any type of regression
model, number of parameters and hierarchies.

\subsection{Building blocks} \label{sec:blocks}

The architecture of the conceptional framework is illustrated in Figure~\ref{fig:blocks}.
\begin{figure}[ht!]
\centering
\setlength{\unitlength}{1cm}
\setlength{\fboxsep}{0pt}
\begin{picture}(10.53, 5.7)(0, 0)
\put(0, 5){\fcolorbox{black}{heat5}{\framebox(2, 0.7)[c]{\footnotesize \texttt{formula}}}}
\put(2.5, 5){\fcolorbox{black}{heat5}{\framebox(2, 0.7)[c]{\footnotesize \texttt{family}}}}
\put(5, 5){\fcolorbox{black}{heat5}{\framebox(2, 0.7)[c]{\footnotesize \texttt{data}}}}
\put(2.5, 3.5){\fcolorbox{black}{heat4}{\framebox(2, 0.7)[c]{\footnotesize \texttt{model.frame}}}}
\put(2.5, 2.5){\fcolorbox{black}{heat3}{\framebox(2, 0.7)[c]{\footnotesize \texttt{transformer}}}}
\put(6, 3.5){\fcolorbox{black}{heat2}{\framebox(2, 0.7)[c]{\footnotesize \texttt{optimizer}}}}
\put(6, 2.5){\fcolorbox{black}{heat1}{\framebox(2, 0.7)[c]{\footnotesize \texttt{sampler}}}}
\put(6, 1.5){\fcolorbox{black}{heat2}{\framebox(2, 0.7)[c]{\footnotesize \texttt{results}}}}
\put(1, 0){\fcolorbox{black}{heat5}{\framebox(2, 0.7)[c]{\footnotesize \texttt{summary}}}}
\put(3.5, 0){\fcolorbox{black}{heat5}{\framebox(2, 0.7)[c]{\footnotesize \texttt{plot}}}}
\put(6, 0){\fcolorbox{black}{heat5}{\framebox(2, 0.7)[c]{\footnotesize \texttt{select}}}}
\put(8.5, 0){\fcolorbox{black}{heat5}{\framebox(2, 0.7)[c]{\footnotesize \texttt{predict}}}}
\put(3.5, 4.2){\line(0, 1){0.8}}
\put(1, 5){\line(0, -1){0.4}}
\put(6, 5){\line(0, -1){0.4}}
\put(1, 4.605){\line(1, 0){5}}
\put(3.5, 3.2){\line(0, 1){0.3}}
\put(4.51, 2.85){\line(1, 0){0.8}}
\put(5.3, 2.85){\line(0, 1){1}}
\put(5.3, 3.85){\line(1, 0){0.72}}
\put(2, 0.7){\line(0, 1){0.4}}
\put(4.5, 0.7){\line(0, 1){0.4}}
\put(7, 0.7){\line(0, 1){0.8}}
\put(9.5, 0.7){\line(0, 1){0.4}}
\put(2, 1.098){\line(1, 0){7.5}}
\put(7, 2.2){\line(0, 1){0.3}}
\put(7, 3.2){\line(0, 1){0.3}}
\end{picture}
\caption{\label{fig:blocks} Conceptional overview.}
\end{figure}
The framework can be divided in three parts: First, functions that describe distribution families,
formulas, together with the data that is used for modeling. Secondly, functions that actually
compute estimates of parameters, and thirdly, functions for visualization and output statistics.

To set up the necessary model frame, the parser function translates the model formula
(see Section~\ref{sec:symdesc}) and the data. For some algorithms a modified version of the
model frame is needed, e.g., using the mixed model representation (\ref{eqn:mixed}) for smooth
terms. Hence, a transformer function might be required. For using standalone estimation engines
additional specifications could be required, e.g., the model code when using \proglang{BUGS} 
implementations. This task is handled by the setup function. The actual estimation function then
calls the engine, either an external device or code within the same environment. The data obtained
from the engine is then uniformly processed in a results function to be able to plot estimates, 
create summary statistics, and so forth.

The main advantage of the architecture is that the blocks parser, transformer, setup, engine and 
results are entirely exchangeable and reusable, i.e., it is relatively easy to incorporate new
algorithms or engines. The other blocks are assumed to be more or less stable such that no extra
coding is required. An implementation of this concept together with examples is illustrated in the
next section.


\section{Software implementation and examples} \label{sec:softex}


\subsection{Precepitation climatolgy from daily observations} \label{sec:censreg}

<<echo=FALSE, results=hide>>=
if(!file.exists("rainmodel.rda") & FALSE) {
  ## Austria: http://www.statistik.at/web_de/klassifikationen/regionale_gliederungen/nuts_einheiten/index.html
  ## AustriaTopo: https://www.ngdc.noaa.gov/mgg/global/global.html
  if(file.exists("homstart.rda")) {
    load("homstart.rda")
  } else {
    dpath <- system.file(package = "bamlss", "data")
    if(!file.exists(file <- file.path(dpath, "homstart.rda"))) {
      homstart_data(dir = dirname(file), load = TRUE)
    } else load(file)
    file.copy(file, file.path(getwd(), "homstart.rda"))
  }

  homstart$raw[homstart$raw < 0] <- 0
  homstart2 <- subset(homstart, year >= 1979)

  f <- list(
    "mu" = sqrt(raw) ~ elevation + ti(day,bs="cc") + ti(long,lat,bs="tp",d=2,k=50) +
      ti(day,long,lat,bs=c("cc","tp"),d=c(1,2),mp=FALSE,k=c(8,30)),
    "sigma" = ~ elevation + ti(day,bs="cc") + ti(long,lat,bs="tp",d=2,k=50) +
      ti(day,long,lat,bs=c("cc","tp"),d=c(1,2),mp=FALSE,k=c(8,30))
  )

  rainmodel <- bamlss(f, data = homstart2, family = "cnorm",
    binning = TRUE, before = TRUE, gam.side = FALSE,
    samplestats = FALSE, results = FALSE,
    eps = 0.001, n.iter = 1200, burnin = 200, thin = 2, cores = 2)

  save(rainmodel, file = "rainmodel.rda")
}

if(!file.exists("figures/rainmodel-effects.png") & FALSE) {
  library("spatstat")
  library("sp")
  library("maptools")
  library("raster")
  library("rgeos")

  if(file.exists("homstart.rda")) {
    load("homstart.rda")
  } else {
    dpath <- system.file(package = "bamlss", "data")
    if(!file.exists(file <- file.path(dpath, "homstart.rda"))) {
      homstart_data(dir = dirname(file), load = TRUE)
    } else load(file)
    file.copy(file, file.path(getwd(), "homstart.rda"))
  }

  homstart$raw[homstart$raw < 0] <- 0
  homstart <- subset(homstart, year >= 1979)

  data("Austria")
  load("rainmodel-final.rda")

  nd <- as.data.frame(coordinates(AustriaTopo))
  names(nd) <- c("long", "lat")
  nd$elevation <- extract(AustriaTopo, cbind(nd$long, nd$lat))
  nd <- na.omit(nd)

  nd$fmu <- predict(rainmodel, newdata = nd, model = "mu", term = "(long,lat)", intercept = FALSE)
  nd$fsigma <- predict(rainmodel, newdata = nd, model = "sigma", term = "(long,lat)", intercept = FALSE)

  expCens <- function(mu, sigma) {
    pnorm(mu / sigma) * (mu + sigma * dnorm(mu / sigma) / pnorm(mu / sigma))
  }

  expSample <- function(mu, sigma, n = 1000) {
    N <- length(mu)
    rval <- sapply(1:N, function(i) {
      rs <- rnorm(n, mean = mu[i], sd = sigma[i])
      rs[rs < 0] <- 0
      rs <- mean(rs^2)
      rs
    })
    unlist(rval)
  }

  nd$day <- 10
  nd$fmu2 <- predict(rainmodel, newdata = nd, model = "mu", intercept = TRUE)
  nd$fsigma2 <- predict(rainmodel, newdata = nd, model = "sigma", intercept = TRUE)
  nd$rain10 <- expSample(nd$fmu2, nd$fsigma2)

  nd$day <- 192
  nd$fmu2 <- predict(rainmodel, newdata = nd, model = "mu", intercept = TRUE)
  nd$fsigma2 <- predict(rainmodel, newdata = nd, model = "sigma", intercept = TRUE)
  nd$rain192 <- expSample(nd$fmu, nd$fsigma2)

  nd2 <- data.frame("day" = 1:365)
  co <- unique(homstart[, c("long", "lat", "elevation", "id")])
  nd3 <- list()
  for(i in 1:nrow(co)) {
    cat("Station", i, "\n")
    nd2$long <- co[i, "long"]
    nd2$lat <- co[i, "lat"]
    nd2$elevation <- mean(co$elevation)
    nd2[[paste("fmu", i, sep = "")]] <- predict(rainmodel, model = "mu", term = "day",
      newdata = nd2, intercept = FALSE)
    nd2[[paste("fsigma", i, sep = "")]] <- predict(rainmodel, model = "sigma", term = "day",
      newdata = nd2, intercept = FALSE)
  
    ttime <- subset(homstart, id == co$id[i])
    ttime$day2 <- as.factor(ttime$day)
    fday <- aggregate(sqrt(ttime$raw), by = list(ttime$day2), FUN = function(x) { mean(x, na.rm = TRUE ) })
    names(fday) <- c("day", "mean")
    fday$day <- as.integer(fday$day)
    fday <- fday[order(fday$day), ]
    nd2$day <- fday$day
    foo <- function(x) { x }
    pmu <- predict(rainmodel, model = "mu", newdata = nd2, intercept = TRUE, FUN = foo)
    psigma <- predict(rainmodel, model = "sigma", newdata = nd2, intercept = TRUE, FUN = foo)
    pred <- NULL
    for(j in 1:ncol(pmu))
      pred <- cbind(pred, expCens(pmu[, j], exp(psigma[, j])))
    pred <- apply(pred, 1, mean, na.rm = TRUE)
    fday$pred <- pred
    attr(fday, "co") <- as.list(co[i, c("long", "lat")])
    nd3[[paste("s", i, sep = "")]] <- fday
  }

  nd4 <- data.frame("day" = 1:365)
  nd4$fdaymu <- predict(rainmodel, newdata = nd4, model = "mu", term = "(day)", intercept = FALSE)
  nd4$fdaysigma <- predict(rainmodel, newdata = nd4, model = "sigma", term = "(day)", intercept = FALSE)

  colors.rain <- function (n, h = c(-160, -38), c. = c(10, 80), l = c(86, 39), 
    power = c(2.75806451612903, 1), fixup = FALSE, gamma = NULL, 
    alpha = 1, ...) 
  {
    if (!is.null(gamma)) 
        warning("'gamma' is deprecated and has no effect")
    if (n < 1L) 
        return(character(0L))
    h <- rep(h, length.out = 2L)
    c <- rep(c., length.out = 2L)
    l <- rep(l, length.out = 2L)
    power <- rep(power, length.out = 2L)
    rval <- seq(1, 0, length = n)
    rval <- hex(polarLUV(L = l[2L] - diff(l) * rval^power[2L], 
        C = c[2L] - diff(c) * rval^power[1L], H = h[2L] - diff(h) * 
            rval), fixup = fixup, ...)
    if (!missing(alpha)) {
        alpha <- pmax(pmin(alpha, 1), 0)
        alpha <- format(as.hexmode(round(alpha * 255 + 1e-04)), 
            width = 2L, upper.case = TRUE)
        rval <- paste(rval, alpha, sep = "")
    }
    return(rval)
  }

  if(!file.exists("rainmodel0.rda")) {
    f <- list(sqrt(raw) ~ 1, sigma ~ 1)
    rainmodel0 <- bamlss(f, data = homstart, family = "cnorm",
      results = FALSE, samplestats = FALSE,
      binning = TRUE, before = TRUE, gam.side = FALSE)
    save(rainmodel0, file = "rainmodel0.rda")
  } else {
    load("rainmodel0.rda")
  }

  stations <- unique(homstart[, c("long", "lat")])
  orange <- rgb(242, 146, 0, maxColorValue = 255)

  plotUnionAustria <- function(...) {
    plot(unionSpatialPolygons(Austria,
      rep(1L, length = length(Austria))), ...)
  }

  epng("figures/rainmodel-data-stations.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot(Austria, col = gray(0.9), lwd = 0.3)
  plotUnionAustria(add = TRUE)
  points(stations[, 1], stations[, 2], pch = 16, cex = 1, col = "blue")
  points(stations[, 1], stations[, 2], cex = 1)
  box()
  axis(1)
  axis(2)
  mtext("Longitude [deg]", side = 1, line = 3)
  mtext("Latitude [deg]", side = 2, line = 3)
  legend("topleft", "Meteorological station", pch = 21,
    col = "black",
    pt.bg = "blue",
    box.col = NA, bg = NA, cex = 0.95)
  dev.off()

  epng("figures/rainmodel-data-hist.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  mf <- model.frame(rainmodel0)
  y <- mf[["sqrt(raw)"]]
  hist(y, freq = FALSE, main = "", col = gray(0.9), breaks = 50,
    xlab = expression(paste("Daily ", sqrt(observations))), ylab = "Density")
  ff <- gF2(cens, left = 0)
  cr <- coef(rainmodel0)
  eta <- list(mu = cr[1], sigma = cr[2])
  y2 <- seq(min(y), max(y), length = 200)
  dy <- ff$d(y = y2, par = ff$map2par(eta))
  lines(dy ~ y2, col = orange, lwd = 2)
  legend("right", "Fitted censored distribution", lwd = 2, col = orange,
    box.col = NA, bg = NA, cex = 0.95)
  box()
  dev.off()

  epng("figures/rainmodel-effects-season-mu.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  redblue1 <- hcl(c(260, 0, 0), c(80, 0, 80), 30, alpha = c(0.15, 0.1, 0.15))
  redblue2 <- hcl(c(260, 0, 0), c(80, 0, 80), 30, alpha = c(0.15, 0.1, 0.15) * 3)
  latbreaks <- c(46.4, 46.7, 48.2, 48.8)
  latcat <- cut(co$lat, breaks = latbreaks)
  ylim.mu <- max(abs(range(c(nd2[, grep("fmu", names(nd2))], nd2$fmu))))
  ylim.sigma <- max(abs(range(c(nd2[, grep("fsigma", names(nd2))], nd2$fsigma))))
  ylim.mu <- c(-1, 1) * ylim.mu
  ylim.sigma <- c(-1, 1) * ylim.sigma
  matplot(nd2$day, nd2[, grep("fmu", names(nd2))], type = "l", lty = 1,
    col = redblue1[latcat], lwd = 2, axes = FALSE,
    xlab = "Time", ylab = expression(paste("Effects on ", mu)),
    ylim = ylim.mu)
  lines(fdaymu ~ day, data = nd4, col = "black", lwd = 2, lty = 2)
  legend("bottom", c("Latitude", paste(latbreaks[3:1], latbreaks[4:2], sep = "-")),
    col = c(NA, rev(redblue2)), lty = 1, lwd = 2, bty = "n", cex = 0.8)
  legend("topright", c("Mean effect", "Spatial-varying effect"),
    col = "black", lty = 2:1, box.col = NA, bg = NA, cex = 0.7) 
  abline(h = 0, lwd = 0.1)
  Axis(as.Date(c("1970-01-01", "1970-12-31")), side = 1)
  axis(2)
  box()
  main(expression(paste("Seasonal ", mu, " effect")), line = 0.3)
  dev.off()

  epng("figures/rainmodel-effects-season-sigma.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  matplot(nd2$day, nd2[, grep("fsigma", names(nd2))], type = "l", lty = 1,
    col = redblue1[latcat], lwd = 2, axes = FALSE,
    xlab = "Time", ylab = expression(paste("Effects on ", log(sigma))),
    ylim = ylim.sigma)
  lines(fdaysigma ~ day, data = nd4, col = "black", lwd = 2, lty = 2)
  abline(h = 0, lwd = 0.1)
  Axis(as.Date(c("1970-01-01", "1970-12-31")), side = 1)
  axis(2)
  box()
  main(expression(paste("Seasonal ", sigma, " effect")), line = 0.3)
  dev.off()

  epng("figures/rainmodel-effects-spatial-mu.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot(Austria, xlab = "Longitude [deg]", ylab = "Latitude [deg]", lwd = 0.3)
  xymap(long, lat, fmu, data = nd, pos = "topleft", layout = FALSE, map = FALSE,
    add = TRUE, color = diverge_hcl, shift = c(0.09, 0.04), distance.labels = 0,
    width = 0.3, symmetric = TRUE, swap = FALSE, range = ylim.mu, digits = 1)
  plot(Austria, add = TRUE, lwd = 0.3)
  plotUnionAustria(add = TRUE)
  box()
  axis(1)
  axis(2)
  main(expression(paste("Spatial ", mu, " effect")), line = 0.3)
  dev.off()

  epng("figures/rainmodel-effects-spatial-sigma.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot(Austria, xlab = "Longitude [deg]", ylab = "Latitude [deg]", lwd = 0.3)
  xymap(long, lat, fsigma, data = nd, pos = "topleft", layout = FALSE, map = FALSE,
    add = TRUE, color = diverge_hcl, shift = c(0.09, 0.04), distance.labels = 0,
    width = 0.3, symmetric = TRUE, swap = FALSE, range = ylim.sigma, digits = 1)
  plot(Austria, add = TRUE, lwd = 0.3)
  plotUnionAustria(add = TRUE)
  box()
  axis(1)
  axis(2)
  box()
  main(expression(paste("Spatial ", sigma, " effect")), line = 0.3)
  dev.off()

  epng("figures/rainmodel-effects-predict.png", width = 9, height = 5, res = 200)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot(Austria, xlab = "Longitude [deg]", ylab = "Latitude [deg]", lwd = 0.3)
  xymap(long, lat, rain10, data = nd, pos = "topleft", layout = FALSE, map = FALSE,
    add = TRUE, color = colors.rain, shift = c(0.1, 0.1), distance.labels = 0,
    width = 0.3 / 2, height = 0.06 * 4/6, symmetric = FALSE, swap = FALSE, digits = 1, range = c(0, 0.6),
    lrange = round(c(0, max(nd$rain10)), 1))
  plot(Austria, add = TRUE, lwd = 0.3)
  plotUnionAustria(add = TRUE)
  box()
  axis(1)
  axis(2)
  box()
  main("Mean precipitation [mm] January 10th")
  dev.off()

  plot.mean.fit <- function(stations = 1, raw = TRUE, mean = TRUE, map = FALSE,
    col.raw = rgb(0.1, 0.1, 0.1, alpha = 0.2), col.mean = rgb(1, 0, 0, alpha = 0.2))
  {
    ylim <- NULL
    for(i in stations)
      ylim <- c(ylim , range(nd3[[i]][, 2:3]))
    ylim <- range(ylim)
    if(map)
      par(mfrow = c(2, 1))
    plot(1, 1, type = "n", ylim = ylim, xlim = c(1, 365), axes = FALSE,
      xlab = "Time", ylab = "Raw vs. fitted values")
    Axis(as.Date(c("1970-01-01", "1970-12-31")), side = 1)
    axis(2)
    box()
    if(raw) {
      for(i in stations) {
        lines(mean ~ day, data = nd3[[i]], col = col.raw, lwd = 2)
      }
    }
    if(mean) {
      for(i in stations) {
        lines(pred ~ day, data = nd3[[i]], col = col.mean, lwd = 2)
      }
    }
    if(map) {
      plot(Austria)
      for(i in stations) {
        co <- attr(nd3[[i]], "co")
        points(co$long, co$lat, pch = 16, cex = 1.5)
        text(co$long, co$lat, i, pos = 3, cex = 1.5)
      }
    }
  }
}
@

\begin{figure}[t!]
\centering
\includegraphics[width=0.46\textwidth]{figures/rainmodel-data-stations}\includegraphics[width=0.46\textwidth]{figures/rainmodel-data-hist}
\caption{\label{fig:rainmodeldata} Distribution of available meteorological stations and
  daily precipitation values.}
\end{figure}

\begin{figure}[t!]
\centering
\includegraphics[width=0.46\textwidth]{figures/rainmodel-effects-season-mu}\includegraphics[width=0.46\textwidth]{figures/rainmodel-effects-season-sigma} \\[0.5cm]
\includegraphics[width=0.46\textwidth]{figures/rainmodel-effects-spatial-mu}\includegraphics[width=0.46\textwidth]{figures/rainmodel-effects-spatial-sigma} \\[0.5cm]
\includegraphics[width=0.92\textwidth]{figures/rainmodel-effects-predict}
\caption{\label{fig:rainmodeleffects} Estimated effects of the rainmodel.}
\end{figure}


\subsection{Cox-regression} \label{sec:coxreg}

<<echo=FALSE, results=hide>>=
if(!file.exists("firemodel.rda") & FALSE) {
  library("spatstat")
  library("sp")
  library("maptools")
  library("raster")
  library("rgeos")

  data("LondonFire")

  f <- list(
    Surv(arrivaltime) ~ ti(arrivaltime,k=20) + ti(arrivaltime,lon,lat,d=c(1,2),mp=FALSE,k=c(5,30)),
    gamma ~ s(fsintens) + s(daytime,bs="cc",k=30) + s(lon,lat,k=60)
  )

  f <- list(
    Surv(arrivaltime) ~ ti(arrivaltime,k=20) + ti(arrivaltime,lon,lat,d=c(1,2),mp=FALSE,k=c(5,30)),
    gamma ~ s(fsintens) + ti(daytime,bs="cc",k=30) + ti(lon,lat,k=80,d=2) +
      ti(daytime,lon,lat,bs=c("cc","cr"),d=c(1,2),mp=FALSE,k=c(10,30))
  )

  firemodel <- bamlss(f, data = LondonFire, family = "cox",
    subdivisions = 10, nu = 0.01, n.iter = 2000, burnin = 1000, thin = 5, cores = 4,
    maxit = 1000)


  plot_daytime <- function(x, daytime = 1, n = 30, ...)
  {
    options(warn = -1)
    gpclibPermit()
    xy <- bbox(LondonBoroughs)
    co <- expand.grid(
      "lon" = seq(min(xy[1, 1]), max(xy[1, 2]), length = n),
      "lat" = seq(min(xy[2, 1]), max(xy[2, 2]), length = n)
    )
    ob <- unionSpatialPolygons(LondonBoroughs,
      rep(1L, length = length(LondonBoroughs)))
    nob <- length(slot(slot(ob, "polygons")[[1]], "Polygons"))
    pip <- NULL
    for(j in 1:nob) {
     oco <- slot(slot(slot(ob, "polygons")[[1]], "Polygons")[[j]], "coords")
     pip <- cbind(pip, point.in.polygon(co$lon, co$lat, oco[, 1L], oco[, 2L], mode.checked = FALSE) < 1L)
    }
    pip <- apply(pip, 1, function(x) all(x))
    co <- co[pip < 1, , drop = FALSE]
    co$daytime <- daytime
    co$spatial_daytime <- predict(x, newdata = co, model = "gamma",
      term = "ti(daytime,lon,lat)", intercept = FALSE)
    plot(LondonBoroughs, xlab = "Longitude [deg]", ylab = "Latitude [deg]",
      main = paste("Daytime =", daytime))
    lr <- range(co$spatial_daytime)
    lr <- c(-1 * max(abs(lr)), max(abs(lr)))
    xr <- quantile(co$spatial_daytime, probs = 0.9)
    xr <- c(-1 * xr, xr)
    xymap(lon, lat, spatial_daytime, data = co, pos = "bottomright",
      layout = FALSE, map = FALSE, color = diverge_hcl, swap = TRUE,
      shift = c(0.03, 0.05), symmetric = TRUE, add = TRUE,
      side.legend = 2, digits = 1, range = xr, lrange = round(lr, 1),
      width = 0.2, height = 0.04, ...)
    plot(LondonBoroughs, add = TRUE)
    box()
    axis(1)
    axis(2)
    options(warn = 0)
    return(invisible(NULL))
  }

  data_basehaz <- function(n = 30, target = 6, k = 20, ...)
  {
    gpclibPermit()

    spatial_daytime <- grepl("(daytime,lon,lat)",
      paste(all.labels.formula(terms(firemodel, model = "gamma")), collapse = "+"), fixed = TRUE)

    firemodel$family <- cox.bamlss()

    xy <- bbox(LondonBoroughs)
    co <- expand.grid(
      "lon" = seq(min(xy[1, 1]), max(xy[1, 2]), length = n),
      "lat" = seq(min(xy[2, 1]), max(xy[2, 2]), length = n)
    )
    ob <- unionSpatialPolygons(LondonBoroughs,
      rep(1L, length = length(LondonBoroughs)))
    nob <- length(slot(slot(ob, "polygons")[[1]], "Polygons"))
    pip <- NULL
    for(j in 1:nob) {
     oco <- slot(slot(slot(ob, "polygons")[[1]], "Polygons")[[j]], "coords")
     pip <- cbind(pip, point.in.polygon(co$lon, co$lat, oco[, 1L], oco[, 2L], mode.checked = FALSE) < 1L)
    }
    pip <- apply(pip, 1, function(x) all(x))

    co <- co[pip < 1, , drop = FALSE]
    nd <- NULL
    atime <- with(as.data.frame(LondonFire), seq(min(arrivaltime), max(arrivaltime), length = 100))
    if(spatial_daytime)
      dtime <- with(as.data.frame(LondonFire), seq(min(daytime), max(daytime), length = 100))
    for(i in 1:nrow(co)) {
      td <- if(spatial_daytime) {
        data.frame("arrivaltime" = atime, "daytime" = dtime)
      } else data.frame("arrivaltime" = atime)
      td$lon <- co$lon[i]
      td$lat <- co$lat[i]
      td$id <- i
      nd <- rbind(nd, td)
    }

    nd$id <- as.factor(nd$id)
    nd$p50atime <- predict(firemodel, newdata = nd, model = "lambda", FUN = mean, intercept = FALSE)
    if(spatial_daytime)
      nd$p50dtime <- predict(firemodel, newdata = nd, model = "gamma", term = "daytime", intercept = FALSE)
    nd$atime <- nd$arrivaltime
    if(spatial_daytime)
      nd$dtime <- nd$daytime

    fbh <- fdt <- NULL
    for(i in unique(nd$id)) {
      j <- nd$id == i
      fbh <- cbind(fbh, nd$p50atime[j])
      if(spatial_daytime)
        fdt <- cbind(fdt, nd$p50dtime[j])
    }
    fbh <- cbind(atime, fbh)
    if(spatial_daytime)
      fdt <- cbind(dtime, fdt)

    nd$daytime <- 8.5
    nd$arrivaltime <- target
    nd <- unique(nd[, c("lon", "lat", "arrivaltime", "daytime")])

    co <- bbox(LondonBoroughs)
    co <- owin(co["x", ], co["y", ])
    fsppp <- ppp(x = LondonFStations$lon, LondonFStations$lat, window = co)
    fsintens <- density.ppp(fsppp, bw.diggle)
    fsintens <- raster(fsintens)
    proj4string(fsintens) <- CRS("+init=epsg:4326")
    nd$fsintens <- extract(fsintens, as.matrix(nd[ , c("lon", "lat")]))

    nd$spatial_prob <- predict(firemodel, newdata = nd,
      term = c("(arrivaltime)", "(arrivaltime,lon,lat)", "(fsintens)", "(daytime)", "(lon,lat)"),
      intercept = TRUE, type = "prob", time = target, ...)
    nd$spatial_tc <- predict(firemodel, newdata = nd, model = "gamma",
      term = "(lon,lat)", intercept = FALSE)
    nd$spatial_td <- predict(firemodel, newdata = nd, model = "lambda",
      term = "(arrivaltime,lon,lat)", intercept = FALSE)
    if(spatial_daytime) {
      nd$spatial_daytime <- predict(firemodel, newdata = nd, model = "gamma",
        term = "(daytime,lon,lat)", intercept = FALSE)
    }

    return(list("curves" = fbh, "daytime" = fdt, "spatial" = nd, "target" = target))
  }

  firemodel_plotdata <- data_basehaz(80, 6, subdivisions = 15)

  save(firemodel, firemodel_plotdata, file = "firemodel_plotdata2.rda")
}

if(!file.exists("figures/firemodel-data.png")) {
  library("sp")
  library("maptools")
  library("rgeos")

  data("LondonFire")
  load("firemodel_plotdata2.rda")

  plot.firemodel <- function(data, what = c("curves", "spatial_prob", "spatial_td", "spatial_tc",
    "fsintens", "daytime"), spar = FALSE, main = FALSE, ...)
  {
    if(spar)
      par(mfrow = n2mfrow(length(what)), mar = c(4.1, 4.1, 3.1, 1.1))
    if("curves" %in% what) {
      matplot(data$curves[, 1], data$curves[, -1], type = "l", lty = 1,
        col = rgb(0.1, 0.1, 0,1, alpha = 0.01), xlab = "Arrivaltime",
        ylab = "Effect on log relative risk")
      plot2d(firemodel$results$lambda$s.effects[["ti(arrivaltime)"]], c.select = c(1, 3),
        col.lines = rainbow_hcl(1), add = TRUE, rug = FALSE, lwd = 2)
      abline(v = data$target, col = "blue", lty = 2)
      legend("bottomright", c("Mean baseline", "Spatial-varying baseline"), lwd = c(2, 1),
        col = c(rainbow_hcl(1), "black"), box.col = NA, bg = NA, cex = 0.95)
      if(main) main("Baseline-hazard effects")
    }
    if("daytime_curves" %in% what & !is.null(data$daytime)) {
      matplot(seq(0, 24, length = 100), data$daytime[, -1], type = "l", lty = 1,
        col = rgb(0.1, 0.1, 0,1, alpha = 0.01), xlab = "Time of day",
        ylab = "Effect of time of day")
      plot2d(firemodel$results$gamma$s.effects[["ti(daytime)"]], c.select = c(1, 3),
        col.lines = rainbow_hcl(1), add = TRUE, rug = FALSE, lwd = 2)
      abline(v = 8.5, col = "blue", lty = 2)
      legend("bottomright", c("Mean daytime effect", "Spatial-varying effect"), lwd = c(2, 1),
        col = c(rainbow_hcl(1), "black"), box.col = NA, bg = NA, cex = 0.95)
      if(main) main("Spatial-varying daytime effect")
    }
    if("spatial_prob" %in% what) {
      plot(LondonBoundaries, xlab = "Longitude [deg]", ylab = "Latitude [deg]")
      lr <- c(0, max(data$spatial$spatial_prob))
      xr <- c(0, quantile(data$spatial$spatial_prob, probs = 0.95))
      xymap(lon, lat, spatial_prob, data = data$spatial, pos = "bottomright",
        layout = FALSE, map = FALSE, color = heat_hcl,
        shift = c(0.03, 0.05), symmetric = FALSE, add = TRUE,
        side.legend = 2, digits = 1, range = xr, lrange = round(lr, 1),
        width = 0.2, height = 0.04, ...)
      plot(LondonBoroughs, add = TRUE, lwd = 0.3)
      plot(LondonBoundaries, col = NA, add = TRUE)
      box()
      axis(1)
      axis(2)
      if(main) main(paste("Prob(T > ", data$target, ")", sep = ""))
    }
    if("fsintens" %in% what) {
      plot(firemodel, model = "gamma", term = "(fsintens)", spar = FALSE,
        xlab = "Fire station intensity",
        ylab = "Effect on log relative risk", rug = FALSE, scheme = 2, grid = 100)
      if(main) main("Effect of fire station intensity")
    }
    if("spatial_td" %in% what) {
      plot(LondonBoundaries, xlab = "Longitude [deg]", ylab = "Latitude [deg]")
      lr <- range(data$spatial$spatial_td)
      lr <- c(-1 * max(abs(lr)), max(abs(lr)))
      xr <- quantile(data$spatial$spatial_td, probs = 0.9)
      xr <- c(-1 * xr, xr)
      xymap(lon, lat, spatial_td, data = data$spatial, pos = "bottomright",
        layout = FALSE, map = FALSE, color = diverge_hcl, swap = TRUE,
        shift = c(0.03, 0.05), symmetric = TRUE, add = TRUE,
        side.legend = 2, digits = 1, range = xr, lrange = round(lr, 1),
        width = 0.2, height = 0.04, ...)
      plot(LondonBoroughs, add = TRUE, lwd = 0.3)
      plot(LondonBoundaries, col = NA, add = TRUE)
      box()
      axis(1)
      axis(2)
      if(main) main(paste("Time-dependent spatial effect (t = ", data$target, ")", sep = ""))
    }
    if("daytime" %in% what) {
      plot(firemodel, model = "gamma", term = "(daytime)", spar = FALSE, rug = FALSE,
        xlab = "Time of day", ylab = "Effect on log relative risk",
        scheme = 2, grid = 100)
      if(main) main("Effect of time of day")
    }
    if("spatial_tc" %in% what) {
      plot(LondonBoundaries, xlab = "Longitude [deg]", ylab = "Latitude [deg]")
      lr <- range(data$spatial$spatial_tc)
      lr <- c(-1 * max(abs(lr)), max(abs(lr)))
      xr <- quantile(data$spatial$spatial_tc, probs = 0.9)
      xr <- c(-1 * xr, xr)
      xymap(lon, lat, spatial_tc, data = data$spatial, pos = "bottomright",
        layout = FALSE, map = FALSE, color = diverge_hcl, swap = TRUE,
        shift = c(0.03, 0.05), symmetric = TRUE, add = TRUE,
        side.legend = 2, digits = 1, range = xr, lrange = round(lr, 1),
        width = 0.2, height = 0.04, ...)
      plot(LondonBoroughs, add = TRUE, lwd = 0.3)
      plot(LondonBoundaries, col = NA, add = TRUE)
      box()
      axis(1)
      axis(2)
      if(main) main("Time-constant spatial effect")
    }
    if("spatial_daytime" %in% what) {
      plot(LondonBoundaries, xlab = "Longitude [deg]", ylab = "Latitude [deg]")
      lr <- range(data$spatial$spatial_daytime)
      lr <- c(-1 * max(abs(lr)), max(abs(lr)))
      xr <- quantile(data$spatial$spatial_daytime, probs = 0.9)
      xr <- c(-1 * xr, xr)
      xymap(lon, lat, spatial_daytime, data = data$spatial, pos = "bottomright",
        layout = FALSE, map = FALSE, color = diverge_hcl, swap = TRUE,
        shift = c(0.03, 0.05), symmetric = TRUE, add = TRUE,
        side.legend = 2, digits = 1, range = xr, lrange = round(lr, 1),
        width = 0.2, height = 0.04, ...)
      plot(LondonBoroughs, add = TRUE, lwd = 0.3)
      plot(LondonBoundaries, col = NA, add = TRUE)
      box()
      axis(1)
      axis(2)
      if(main) main("Spatial daytime effect")
    }
    if("stations" %in% what) {
      co <- bbox(LondonBoroughs)
      scale <- 0.5
      ylim <- c(co["y", 1], co["y", 2] + scale * abs(diff(co["y", ])))
      plot(LondonBoroughs, main = "",
        xlab = "Longitude [deg]", ylab = "", ylim = ylim,
        col = gray(0.9), lwd = 0.3)
      cfun <- function(n) { heat_hcl(n, alpha = 0.8) }
      pal <- make_pal(col = cfun, ncol = 99, data = LondonFire$arrivaltime, symmetric = FALSE,
        range = c(3, 8), swap = TRUE)
      ld <- as.data.frame(LondonFire)
      ld <- ld[order(ld$arrivaltime, decreasing = TRUE), ]
      points(ld$lon, ld$lat, pch = 4, col = pal$map(ld$arrivaltime), cex = 0.6)
      points(LondonFStations, pch = 16, col = "blue", cex = 0.8)
      points(LondonFStations, cex = 0.8)
      plot(LondonBoundaries, col = NA, add = TRUE)
      box()
      axis(1)
      axis(4, at = round(seq(co[2, 1] + 0.07, co[2, 2] - 0.07, length = 4), 2))
      mtext(paste("Latitude [deg]",
        paste(rep(" ", 30), collapse = "", sep = "")), side = 4, line = 3)
      legend("bottomleft", c("Fire", "Station"), pch = c(4, 21),
        col = c("black", "black"), pt.bg = c(NA, "blue"), box.col = NA, bg = NA, cex = 0.95)
      i <- order(LondonFire$arrivaltime, decreasing = TRUE)
      atimes <- LondonFire$arrivaltime[i]
      lon <- LondonFire$lon[i]
      shift <- scale * 0.1 * abs(diff(co["y", ]))
      y <- scale2(atimes, co["y", 2] + shift, ylim[2])
      rect(lon - 0.0015, rep(co["y", 2] + shift,length = length(y)), lon + 0.0015, y,
        col = pal$map(atimes), border = NA)
      lines(co[1, ], rep(co["y", 2] + shift, 2))
      wt <- c(min(atimes), 6, 12, 20)
      wt2 <- scale2(wt, co["y", 2] + shift, ylim[2])
      axis(2, at = wt2, labels = fmt(wt, 2, 0))
      if(main) main(paste(paste(rep(" ", 70), collapse = "", sep = ""), "Arrivaltime [min]"))
    }
  }

  plot.griddata <- function(n = 800, FUN = NULL,
    color = heat_hcl, symmetric = FALSE, swap = TRUE, type = "regular",
    main = NULL, xlab = "Longitude [deg]", ylab = "Latitude [deg]", ...)
  {
    if(is.null(FUN))
      FUN <- function(x) { sum(x > 6, na.rm = TRUE) / length(x) }

    LBP0 <- unionSpatialPolygons(LondonBoroughs,
      rep(1L, length = length(LondonBoroughs)))
    LBP <- spTransform(LBP0, CRS("+init=epsg:27700"))
    xy <- bbox(LondonBoroughs)
    dx <- abs(diff(range(xy[1, ])))
    dy <- abs(diff(range(xy[2, ])))
    scale <- 0.05
    co <- expand.grid(
      "lon" = seq(min(xy[1, 1]) - scale * dx, max(xy[1, 2]) + scale * dx, length = n),
      "lat" = seq(min(xy[2, 1]) - scale * dy, max(xy[2, 2]) + scale * dy, length = n)
    )
    coordinates(co) <- c("lon", "lat")
    proj4string(co) <- CRS("+init=epsg:4326")
    co <- spTransform(co, CRS("+init=epsg:27700"))
    Pts <- spsample(co, n = n, type = type, offset = c(0.5, 0.5))
    if(type == "hexagonal") {
      Pols <- HexPoints2SpatialPolygons(Pts)
    } else {
      Pols <- points2grid(Pts)
      Pols <- as(Pols, "SpatialPolygons")
      proj4string(Pols) <- CRS("+init=epsg:27700")
    }
    Pols <- spTransform(Pols, CRS("+init=epsg:4326"))

    clip <- gIntersection(LBP0, Pols, byid = TRUE, drop_lower_td = TRUE)
    agg <- aggregate(LondonFire["arrivaltime"], clip, FUN = FUN)
    
    colors <- colorlegend(x = agg$arrivaltime, plot = FALSE,
      color = color, symmetric = symmetric, swap = swap, ...)

    plot(LondonBoundaries, col = gray(0.9), xlab = xlab, ylab = ylab,
      main = main)
    plot(agg, col = colors$map(agg$arrivaltime), add = TRUE, border = NA)
    plot(LondonBoundaries, col = NA, add = TRUE)
    plot(LondonBoroughs, lwd = 0.3, add = TRUE)

    colorlegend(x = agg$arrivaltime, plot = FALSE, add = TRUE,
      color = color, swap = swap, symmetric = symmetric, width = 0.2, height = 0.04,
      pos = "bottomright", side.legend = 2, shift = c(0.03, 0.05), ...)
  }

  plot.firedata <- function()
  {
    par(mfrow = c(2, 2), mar = rep(0, 4), oma = c(4.1, 4.1, 4.1, 4.1))
    plot(LondonBoundaries, col = gray(0.9))
    plot(LondonBoroughs, lwd = 0.3, add = TRUE)
    points(LondonFire, pch = 4, col = rgb(1, 0, 0, alpha = 0.3), cex = 0.4)
    points(LondonFStations, pch = 16, col = rgb(0, 0, 1), cex = 0.8)
    points(LondonFStations, cex = 0.8)
    box()
    axis(2)
    axis(3)
    legend("topright", c("Fire", "Station"), pch = c(4, 21),
      col = c(rgb(1, 0, 0, alpha = 1), "black"),
      pt.bg = c(NA, rgb(0, 0, 1)), box.col = NA, bg = NA, cex = 0.95)

    plot.griddata(type = "hexagonal", at = c(0, 0.5, 1), labels = c("0.0", "0.5", "1.0"),
      main = "", xlab = "", ylab = "")
    box()
    axis(3)
    legend("topright", "% Arrivatime > 6min", box.col = NA, bg = NA, cex = 0.95)

    plot.griddata(type = "hexagonal", digits = 0,
      main = "", xlab = "", ylab = "", FUN = length, range = c(1, 35), lrange = c(1, 55))
    box()
    axis(2)
    legend("topright", "#Number of fires", box.col = NA, bg = NA, cex = 0.95)

    hist(LondonFire$arrivaltime, breaks = 50, col = gray(0.9), freq = FALSE,
      xlab = "", main = "", axes = FALSE)
    abline(v = 6, lty = 2, col = "blue", lwd = 2)
    box()
    axis(1)
    axis(4)
    mtext("Arrivaltime [min]", side = 1, line = 3)
    mtext("Density", side = 4, line = 3)
    F <- ecdf(LondonFire$arrivaltime)
    P <- round(1 - F(6), 2)
    legend("topright", "t = 6min",
      lwd = 2, lty = 2, col = "blue",
      title = paste("Prob(T > 6min) =", P),
      box.col = NA, bg = NA, cex = 0.95)

    mtext("Latitude [deg]", side = 2, line = 3, outer = TRUE)
    mtext("Longitude [deg]", side = 3, line = 3, outer = TRUE)
  }

  png("figures/firemodel-data.png", units = "in", res = 120, width = 8 * 1.25, height = 6.5 * 1.25)
  plot.firedata()
  dev.off()

  epng("figures/firemodel-effects-baseline.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot.firemodel(firemodel_plotdata, what = "curves", main = TRUE)
  dev.off()

  epng("figures/firemodel-effects-fsintens.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot.firemodel(firemodel_plotdata, what = "fsintens", main = TRUE)
  dev.off()

  epng("figures/firemodel-effects-daytime.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot.firemodel(firemodel_plotdata, what = "daytime", main = TRUE)
  dev.off()

  epng("figures/firemodel-effects-prob.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot.firemodel(firemodel_plotdata, what = "spatial_prob", main = TRUE)
  dev.off()

  epng("figures/firemodel-effects-spatial-td.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot.firemodel(firemodel_plotdata, what = "spatial_td", main = TRUE)
  dev.off()

  epng("figures/firemodel-effects-spatial-tc.png", width = 4.5, height = 3.5)
  par(mar = c(4.1, 4.1, 1.5, 1.5))
  plot.firemodel(firemodel_plotdata, what = "spatial_tc", main = TRUE)
  dev.off()
}
@

\begin{figure}[t!]
\centering
\includegraphics[width=0.92\textwidth]{figures/firemodel-data}
\caption{\label{fig:londonfiredata} Distribution of dwelling fires and fire stations in London (2015).}
\end{figure}

\begin{figure}[t!]
\centering
\includegraphics[width=0.46\textwidth]{figures/firemodel-effects-baseline}\includegraphics[width=0.46\textwidth]{figures/firemodel-effects-prob} \\[0.5cm]
\includegraphics[width=0.46\textwidth]{figures/firemodel-effects-fsintens}\includegraphics[width=0.46\textwidth]{figures/firemodel-effects-spatial-td} \\[0.5cm]
\includegraphics[width=0.46\textwidth]{figures/firemodel-effects-daytime}\includegraphics[width=0.46\textwidth]{figures/firemodel-effects-spatial-tc}
\caption{\label{fig:londonfiredeffects} Estimated effects of the fire emergency response times
  survival model.}
\end{figure}


\section{Summary}\label{sec:conclusion}


\section*{Acknowledgments}


\bibliography{bamlss}


\clearpage


\begin{appendix}

\end{appendix}


\end{document}

