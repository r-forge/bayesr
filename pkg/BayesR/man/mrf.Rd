\name{mrf}
\alias{mrf}

\title{Create Design and Penalty Matrices for a Markov Random Field}

\description{
This function generates the 0/1 incidence design matrix. For estimation a neighborhoodmatrix can be either supplied by the user 
or generated by the function \code{\link{neighbormatrix}}, 
which will be used for the generation of a penalty matrix for the \code{\link{gibbs}} sampler.}

\usage{
mrf(ind, neighbor, by = NULL, lambda = NULL, center = TRUE)}
 
\arguments{
  \item{ind}{the indicator variable, which maps every observation to some certain region}
  \item{neighbor}{the neighborhoodmatrix, must be supplied by the user}
  \item{by}{specify a variable the \code{mrf} term is varying for}
  \item{lambda}{the hyperparameter which controls for the penalties on the estimated coefficients, if supplied only this parameter will be used}
  \item{center}{specifies if the smooth should be centered or not}}

\value{
  This function return the 0/1 incidence design matrix as well as the neighborhood penalty matrix
  \item{basis}{the 0/1 design matrix}
  \item{by}{if supplied, a variable the smooth is varying by}
  \item{K}{the penalty matrix, i.e. the neighborhoodmatrix}
  \item{names}{the variable names from the function call}
  \item{lambda}{if supplied, the value of the hyperparameter}
  \item{ind}{the original indicator variable}
  \item{\dots}{ }}

\references{ ~put references to the literature/web site here ~ }

\author{Nikolaus Umlauf \email{nikolaus.umlauf@uibk.ac.at} and Stefan Lang \email{stefan.lang@uibk.ac.at}}

\seealso{\code{\link{gibbs}}}

\examples{
# estimate a model with regional information
# load a simple sample map
data(polyloc)

# create the corresponding neighborhoodmatrix
neighbor<-neighbormatrix(polyloc)

# generate some values for different regions
n<-1000
x1<-runif(n,0,1)
ind<-round(runif(n,1,length(polyloc)))
m<-nlevels(as.factor(ind))

loc<-rep(0,n)
truth<-c(3,2,2.5,12,13,14,11,15,5,10)
for(i in 1:m)
	loc[ind==i]<-truth[i]
mloc<-mean(loc)
loc<-loc-mloc
truth<-truth-mloc

f2<-function(x){X<-0.2*x^11*(10*(1-x))^6+10*(10*x)^3*(1-x)^10
                X <- X-mean(X)}

# generate data
y<-10+f2(x1)+loc+rnorm(n,sd=1.2)	

# estimate model
b<-gibbs(y~s(x1)+s(ind,bs="mrf",xt=list(neighbor)))
summary(b)

par(mfrow=c(1,3))
plot(b,which=1)
plot(b,which=2,map=polyloc,main="Estimated regional effects",
     colored=TRUE,names=TRUE,pal="heat")
# plot estimated spatial effects with a 3d map
plot(b,which=2,map=polyloc,p3d=TRUE)

# true values
truth

# now estimate the spatial effect with a geospline
b<-gibbs(y~s(x1)+s(ind,polyloc,bs="ste",xt=list(geo=TRUE)))
plot(b,which=2,image=TRUE)

# optional plot the map
for(i in 1:length(polyloc))
	polygon(polyloc[[i]][,1],polyloc[[i]][,2])


\dontrun{
# a more sophisticated example
set.seed(111)

# simulate some geographical data
data(germany)
N<-length(germany)
names(germany)<-1:N
n<-N*5
f2<-sort(runif(N,0,5))
f2<-f2-mean(f2) # center for better comparison
id<-rep(1:N,n/N)
neighbor<-neighbormatrix(germany,type=2)

# first generate some univariate data
x1<-runif(n,-3,3)
f1<-sin(x1)

y<-10+f1+f2[id]+rnorm(n,sd=1.2)

# estimate model
m<-gibbs(y~s(x1)+s(id,bs="mrf",xt=list(neighbor=neighbor)))
summary(m)

par(mfrow=c(1,3))
plot(m,2,pal="hcl",map=germany,main="Estimate",resid=T)
plotmap(germany,values=cbind(1:N,f2),colored=TRUE,pal="hcl",main="Truth")
plot(unique(fitted(m,type=2)[[2]][,2])~f2,xlab="True effects",ylab="Fitted")
lines(c(f2)~f2,col=2)}
}

\keyword{models} 
\keyword{smooth} 
\keyword{regression} 
