\documentclass[article]{jss}
%\documentclass[nojss]{jss}
\usepackage{amsmath,amssymb,amsfonts,thumbpdf}

%% additional commands
\newcommand{\squote}[1]{`{#1}'}
\newcommand{\dquote}[1]{``{#1}''}
\newcommand{\fct}[1]{{\texttt{#1()}\index{#1@\texttt{#1()}}}}
\newcommand{\class}[1]{\dquote{\texttt{#1}}}
%% for internal use
\newcommand{\fixme}[1]{\emph{\marginpar{FIXME} (#1)}}
\newcommand{\readme}[1]{\emph{\marginpar{README} (#1)}}

\author{Nikolaus Umlauf\\Universit\"at Innsbruck \And
        Thomas Kneib\\Universit\"at Oldenburg \And
        Stefan Lang\\Universit\"at Innsbruck \And        
        Achim Zeileis\\Universit\"at Innsbruck}
\Plainauthor{Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis}

\title{Structured Additive Regression Models: An \proglang{R} Interface to BayesX}
\Plaintitle{Structured Additive Regression Models: An R Interface to BayesX}

\Keywords{STAR models, MCMC, REML, stepwise, \proglang{R}}
\Plainkeywords{STAR models, MCMC, REML, stepwise, R}

%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

\Abstract{
  Structured additive regression models (STAR) provide a flexible framework for modeling possible 
  nonlinear effects of covariates: They contain the well established frameworks of generalized 
  linear models (GLM) and generalized additive models (GAM) as special cases but also allow a wider 
  class of effects, e.g., for geographical or spatio-temporal data. This allows for the 
  specification of complex and realistic models that can typically be conveniently estimated using 
  Bayesian inference based on modern Markov chain Monte Carlo (MCMC) simulation techniques or a 
  mixed model representation. 
  Besides the already quite extensive existing toolset in \proglang{R} supporting GLMs and GAMs, 
  another standalone software package called BayesX, based on open-source \proglang{C++}, developed 
  to a very comprehensive regression toolbox over last few years, especially for those models from 
  the STAR class utilizing Bayesian inference, wherefore availability in \proglang{R} is currently 
  difficult.
%
%  Although there is already a quite extensive existing toolset in 
%  \proglang{R} supporting GLMs and GAMs, many of the more complex models from the STAR class, 
%  especially those utilizing Bayesian inference, are currently not easily available. They are, 
%  however, provided in BayesX, a very comprehensive semiparametric regression toolbox based on 
%  open-source \proglang{C++}, which not only covers models for responses from univariate exponential 
%  families, but also models from non-standard regression situations such as models for categorical 
%  responses with either ordered or unordered categories, continuous time survival data, or 
%  continuous time multi-state models. 
%  
  Since there has been increasing interest in an \proglang{R} interface to BayesX, the former 
  implemented CRAN package \pkg{BayesX}, which previously provided mainly functions for exploring 
  estimation results, is now extended to a full interactive interface. With the new version of the 
  package, STAR models can be conveniently specified using \proglang{R}'s formula language (with 
  some extended terms), fitted using the BayesX binary, represented in \proglang{R} with objects of 
  suitable classes, and finally printed/summarized/plotted.
}

\Address{
  Nikolaus Umlauf, Stefan Lang, Achim Zeileis\\
  Department of Statistics\\
  Universit\"at Innsbruck\\
  Universit\"atsstr.~15\\
  A-6020 Innsbruck, Austria\\
  E-mail: \email{Nikolaus.Umlauf@uibk.ac.at},\\
  \phantom{E-mail: }\email{Stefan.Lang@uibk.ac.at},\\
  \phantom{E-mail: }\email{Achim.Zeileis@R-project.org}\\
  URL: \url{http://www.uibk.ac.at/statistics/personal/umlauf/},\\
  \phantom{URL: }\url{http://www.uibk.ac.at/statistics/personal/lang/},\\
  \phantom{URL: }\url{http://eeecon.uibk.ac.at/~zeileis/}\\
  
  Thomas Kneib\\
  Department of Mathematics\\
  Universit\"at Oldenburg\\
  D-26111 Oldenburg, Germany \\
  E-mail: \email{Thomas.Kneib@uni-oldenburg.de}\\
  URL: \url{http://www.staff.uni-oldenburg.de/thomas.kneib/}
}

%% Sweave/vignette information and metadata
%% need no \usepackage{Sweave}
\SweaveOpts{engine = R, eps = FALSE, keep.source = TRUE}
%\VignetteIndexEntry{Structured Additive Regression Models: An R Interface to BayesX}
%\VignetteDepends{colorspace,mgcv,BayesX,akima}
%\VignetteKeywords{STAR models, MCMC, REML, stepwise, R}
%\VignettePackage{R2BayesX}

<<preliminaries, echo=FALSE, results=hide>>=
options(width = 70, prompt = "R> ", continue = "+  ")
library("R2BayesX")
data("ZambiaBnd")
data("BeechBnd")
@


\begin{document}


\section{Introduction} \label{sec:intro}

The public domain software BayesX \citep{Brezger+Kneib+Lang:2005} is a standalone program which 
comprises powerful tools for Bayesian and mixed model based inference for complex semiparametric 
regression models. To gain improved estimation runtime performance of the supported models, the 
algorithms implemented utilize efficient (sparse) matrix computations and are written in a 
\proglang{C++} environment. The idea to embed BayesX in \proglang{R} \citep{R}, and therefore make 
the project available to \proglang{R}'s permanently growing community, has been in mind for quite a 
while. However, since the development status of the software package is already very advanced, and 
there has been more and more recent interest of an \proglang{R} version of BayesX, the compromise of 
creating an interface, compared to a full code portation, was seen advantageous, not only because of 
a faster development time, but also offering already familiar users a toolset, that even, beside the 
possibility to formulate STAR models directly on the console, allows to use existing code and model 
output, within \proglang{R}. 

Therefore, the implementation is structured in a few independent operating functions that basically 
collect and configure the necessary model components at first, send these to the BayesX binary for 
processing, read the returned output files back into \proglang{R} by conversion to objects of 
suitable classes, which may then be printed, summarized and visualized. All interface functions have 
been added to the CRAN package \pkg{BayesX} \citep{Kneib+Heinzl+Brezger:2011}, which previously 
provided mainly functions for exploring estimation results.

Designing an user friendly setup requires a comfortable translation method of \proglang{R} specific 
syntax to BayesX interpretable commands. For this reason, the package layout is orientated and 
dependent on the recommended CRAN package \pkg{mgcv} \citep{Wood:2011}, amongst others, since 
\pkg{mgcv} already features functionality, which allows to set up new model terms within 
\proglang{R}'s formula language relatively easy, and secondly, the package covers a number of the 
model terms implemented in BayesX. This means, some of the model formulas specified within the 
\pkg{mgcv} main model fitting-function \fct{gam}, may also be used in \pkg{BayesX} and vice versa. 
Hence, users primarily familiar with \pkg{mgcv} and its GAM formula definition may use the interface 
with little additional effort, only. This is illustrated in the following, where some data is 
simulated and models are estimated with \fct{gam}, using generalized cross validation (GCV) for 
optimization, and the \pkg{BayesX} interface primary model-fitting function \fct{bayesx} applying 
MCMC: 
<<fit-illustration-pspline, echo=TRUE, eval=FALSE, fig=FALSE>>=
## simulate some data
set.seed(0) 
dat <- gamSim(1, n = 400, dist = "normal", scale = 2)

## model formula
mf <- y ~ s(x0, bs = "ps") + s(x1, bs = "ps") + 
  s(x2, bs = "ps") + s(x3, bs = "ps")

## estimate models with
## mgcv GCV and BayesX MCMC
b1 <- gam(mf, method = "GCV.Cp", data = dat)
b2 <- bayesx(mf, method = "MCMC", data = dat)

## plot estimated effects
plot(b1)
plot(b2)
@
<<fit-illustration-geo, echo=FALSE, eval=FALSE, fig=FALSE>>=
set.seed(333)
     
## simulate some geographical data
data("MunichBnd")
N <- length(MunichBnd); n <- N*2
names(MunichBnd) <- 1:N
     
## regressors
dat <- data.frame(x1 = runif(n, -3, 3),
  id = as.factor(rep(names(MunichBnd), length.out = n)))
dat$sp <- with(dat, sort(runif(N, -1, 1), decreasing = TRUE)[id])
     
## response
dat$y <- with(dat, 1.5 + sin(x1) + sp + rnorm(n, sd = 0.3))

## geokriging
b3 <- bayesx(y ~ s(id, bs = "gk", k = 20, xt = list(map = MunichBnd)) + 
  s(x1, bs = "ps"), method = "REML", data = dat)
@
<<cache-illustration, echo=FALSE, eval=TRUE, fig=FALSE>>=
if(file.exists("illustration-pspline.rda")) {
load("illustration-pspline.rda")
} else {
<<fit-illustration-pspline>>
save(b1, b2, file = "illustration-pspline.rda")
}
if(file.exists("illustration-geo.rda")) {
load("illustration-geo.rda")
} else {
<<fit-illustration-geo>>
save(b3, file = "illustration-geo.rda")
}
@
\begin{figure}[h!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<plot-illustration-pspline-BayesX, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b1, select = 3, ylim = c(-6.9, 6), 
  shade = TRUE)
@
<<plot-illustration-pspline-mgcv, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b2, term = "s(x2)", ylim = c(-6.9, 6),
  c.select = c("x", "Mean", "2.5%", "97.5%"), 
  fill.select = c(0, 0, 1, 1))
@ 
\\[2ex]
<<plot-illustration-geo-image, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b3, term = "s(id)", image = TRUE, grid = 200, 
  xpd = TRUE, distance.labels = 5)
@
<<plot-illustration-geo-persp, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 4.1, 0, 0))
plot(b3, term = "s(id)", resid = TRUE, 
  cex.resid = 0.3, theta = -40)
@
\end{center}
\caption{\label{fig:illustration} Visualization examples: Comparison of estimated effects for 
covariate \code{x2}, black lines, together with 95\% credible intervals shaded in gray, of the 
package \pkg{mgcv} model-fitting function \fct{gam} using GCV, upper left panel, and the 
\pkg{BayesX} model-fitting function \fct{bayesx} applying MCMC, upper right panel respectively.
The lower left panel illustrates visualization of an estimated geoadditive model term using an image 
plot with a color legend, the lower right panel shows the same effect with a perspective plot and 
partial residuals.}
\end{figure}
Several standard base \proglang{R} extractor functions and methods, e.g. \fct{plot} and 
\fct{summary}, also, with similar behavior as in \pkg{mgcv}, are available for the returned 
fitted-model objects of \fct{bayesx}. Here, the comparison plot of the estimated effect for covariate 
\code{x2} of the two models, generated with the code above, is shown in 
figure~\ref{fig:illustration}, together with examples of more sophisticated graphics supported by 
the plotting method. Consequently, estimating models with more complex term structures, e.g. 
applying stationary Gaussian random fields, is managed by function \fct{s}, which facilitates a 
consistent way of smooth terms specifications in GAM and STAR formulas. In addition, BayesX supports 
non-standard regression situations such as models for categorical responses with either ordered or 
unordered categories, continuous time survival data, or continuous time multi-state models, which 
may be adopted in the same manner. 

To present the extensive capabilities of the software in more detail, the next section briefly 
discusses the methodological background of regression models with a structured additive predictor, 
before a description of the implementation is provided in section~\ref{sec:implementation}. In 
section~\ref{sec:illustrations}, the interface usability is further demonstrated on a complex 
example with data concerning childhood malnutrition in Zambia as well as on a dataset on forest 
health.


\section{STAR models} \label{sec:model} 

The STAR model class supported by \pkg{BayesX} is based on the framework of (Bayesian) generalized 
linear models (GLM) \citep{Nelder+Wedderburn:1972, Fahrmeir+Tutz:2001}. GLMs assume that, given 
covariates $\mathbf{x}$ and unknown parameters $\gamma$, the distribution of the response variable 
$y$ belongs to an exponential family with mean $\mu = E(y | \mathbf{x}, \boldsymbol{\gamma})$ linked 
to a linear predictor $\eta$ by
\begin{equation} \label{eqn:glm}
\mu = h(\eta) \qquad \eta = \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation}
where $h$ is a known link function and $\boldsymbol{\gamma}$ are unknown regression parameters. For 
STAR models, the linear predictor is replaced by a more general and flexible, so called structured 
additive predictor
\begin{equation} \label{eqn:structadd}
\eta = f_1(z_1) + \ldots + f_p(z_p) + \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation}
where covariates $z_j$, $j = 1,\ldots,p$, are of generic type and dimension, and $f_j$ are possibly 
smooth functions comprising effects (and combination of effects) as e.g. given by             
\begin{itemize}
\item nonlinear effects of continuous covariate $x$: $f_j(z_j) = f(x)$,
\item two-dimensional surfaces: $f_j(z_j) = f(x_1,x_2)$,
\item spatially correlated effects: $f_j(z_j) = f_{spat}(s)$, 
\item varying coefficients: $f_j(z_j) = x_1f(x_2)$, 
\item spatially varying effects: $f_j(z_j) = x_1f_{spat}(s)$ or $f_j(z_j) = x_1f(x_2, x_3)$, 
\item random intercepts with cluster index $c$: $f_j(z_j) = b_c$, 
\item random slopes with cluster index $c$: $f_j(z_j) = x \, b_c$. 
\end{itemize}
Therefore, STAR models cover a number of well known model classes as special cases, including
generalized additive models (GAM) \citep{Hastie+Tibshirani:1990}, generalized additive mixed models
(GAMM) \citep{Lin+Zhang:1999}, geoadditive models \citep{Kamman+Wand:2003}, varying coefficient 
models \citep{Hastie+Tibshirani:1993}, and geographically weighted regression 
\citep{Fotheringham+Brunsdon+Charlton:2002}.

The unified representation of a STAR predictor arises from the fact that all functions $f_j$ in 
(\ref{eqn:structadd}) may be specified by a basis function approach, where the vector of function  
evaluations $\mathbf{f}_j = (f_j(z_{1j}),\ldots,f_j(z_{nj}))$, with $i = 1,\ldots,n$ observations, 
can be written in matrix notation 
\begin{equation} \label{eqn:matnot}
\mathbf{f}_j = \mathbf{Z}_j\boldsymbol{\beta}_j,
\end{equation}
with $\mathbf{Z}_j$ as a design matrix, that only depends on the prior assumptions about smoothness 
of $f_j$, and $\boldsymbol{\beta}_j$ are unknown regression coefficients which have to be estimated. 
Hence, the predictor of (\ref{eqn:structadd}) may be rewritten by
\begin{equation} \label{eqn:structaddmat}
\boldsymbol{\eta} = \mathbf{Z}_1\boldsymbol{\beta}_1 + \ldots \mathbf{Z}_p\boldsymbol{\beta}_p 
+ \mathbf{X}\boldsymbol{\gamma},
\end{equation}
where $\mathbf{X}$ corresponds to the usual design matrix for the fixed effects.

In BayesX, estimation of regression parameters is based on two inferential concepts, Markov chain 
Monte Carlo simulation techniques corresponding to full Bayesian inference \citep{Brezger+Lang:2006}
and mixed model methodology corresponding to penalized likelihood or empirical Bayes inference
\citep{Fahrmeir+Kneib+Lang:2004}. As a third alternative BayesX provides a penalized least squares
(respectively penalized likelihood) approach for estimating structured additive regression tools. In
addition, a powerful variable and model selection tool is included. Model choice and estimation of
the parameters is done simultaneously \citep{Belitz+Lang:2008}.

For all inferential concepts, the prior for the functions $f_j$ depends on the design matrix 
$\mathbf{Z}_j$, as e.g. determined by the functional types described above, and a prior for the 
vector $\boldsymbol{\beta}_j$, which may also be written in a general form given by
\begin{equation} \label{eqn:prior}
p(\boldsymbol{\beta}_j | \tau_j^2) \propto exp \left(- \frac{1}{2\tau_j^2} 
\boldsymbol{\beta_j}^{\prime}\mathbf{K}_j\boldsymbol{\beta}_j\right),
\end{equation}
with $\mathbf{K}_j$ as a quadratic penalty matrix that shrinks parameters towards zero or penalizes 
too abrupt jumps between neighboring parameters. In most cases $K_j$ will be rank deficient and the 
prior for $\boldsymbol{\beta}_j$ is partially improper.

The variance parameter $\tau_j^2$ is equivalent to the inverse smoothing parameter in a frequentist
approach and controls the trade off between flexibility and smoothness. For full Bayesian inference,
weakly informative inverse Gamma hyperpriors $\tau_j^2 \sim IG(a_j, b_j)$ are assigned to 
$\tau_j^2$, with $a_j = b_j = 0.001$ as a standard option. For empirical Bayes inference, $\tau_j^2$ 
is considered an unknown constant which is determined as a restricted maximum likelihood estimate 
(REML).

A thorough (and for most practical purposes sufficient) introduction into the regression models 
supported by the program is provided in the BayesX methodology manual 
\citep{Belitz+Brezger+Kneib+Lang:2011}.


\section[Implementation in R]{Implementation in \proglang{R}} \label{sec:implementation}

Before STAR models can be fitted with \pkg{BayesX}, the binary command line version of the 
program needs to be installed. This may be accomplished differently and system specific: one 
opportunity is to download the \proglang{C++} source-code from 
\begin{center}
\url{http://www.stat.uni-muenchen.de/~bayesx}, 
\end{center}
and compile the sources with the GNU \proglang{C++} compiler, besides on Windows operating systems, 
a pre-compiled computing kernel including a Java graphical interface may be installed, which 
automatically installs the command line version of BayesX, also. Another, and the recommended option 
on UNIX and Windows systems is to install the binary within \proglang{R} by calling the function 
\fct{install.bayesx}, which basically executes the described above. For all other platforms and 
possible problems, please see the help sites on the BayesX web-page. Installing BayesX from 
\proglang{R} then ideally only requires running
<<install-bayesx, echo=TRUE, eval=FALSE>>=
install.bayesx(inst.dir = NULL, source.dir = NULL)
@
if the computer is connected to the internet and the user holds writing permissions for the 
\pkg{BayesX} package library folders, otherwise a valid installation directory must be supplied (in 
the majority of cases) as well as the source-code directory, if the source-code is already stored 
locally and does not need to be downloaded. After the successful installation, the full path to the 
command line binary must be set either within \proglang{R} directly, using e.g.
<<install-bayesx, echo=TRUE, eval=FALSE>>=
options(bayesx.bin = "/path/to/BayesX")
@
where \code{"/path/to/BayesX"} on Windows systems may be specified e.g. with \\
\code{"C:/BayesX/commandline/bayesx.exe"}, or adding the installation directory of the binary to the 
environment PATH variable is sufficient. Afterwards, the function call
<<install-bayesx, echo=TRUE, eval=FALSE>>=
check.install.bayesx()
@
will check if BayesX may be called from \proglang{R}. 
 
The main model-fitting function in \pkg{BayesX} is called \fct{bayesx}, which is basically a 
collection of functions described in table~\ref{tab:bayesxfun}, 
\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Function                 & Description \\ \hline
\fct{parse.bayesx.input} & parses \fct{bayesx} input parameters to be send to 
                           \fct{write.bayesx.input}. \\ \hline
\fct{write.bayesx.input} & takes an object from \fct{parse.bayesx.input} and translates the input to 
                           an executable program and, if necessary, a data file, which may be 
                           processed with BayesX. \\ \hline
\fct{run.bayesx}         & runs BayesX program files from \proglang{R}. \\ \hline
\fct{read.bayesx.output} & automatically reads in BayesX estimation output stored in a declared 
                           output directory by transforming objects to suitable classes, which may 
                           be printed, summarized and plotted. \\ \hline
\end{tabular}
\caption{\label{tab:bayesxfun} Main functions of the interface.}
\end{center}
\end{table}
that are executed one after another, and may also be used independently. 
The arguments of \fct{bayesx} are
\begin{Sinput}
bayesx(formula, data, weights = NULL, subset = NULL, 
  offset = NULL, na.action = na.fail, contrasts = NULL, 
  control = bayesx.control(...), ...)
\end{Sinput}
and mostly represent the standard model frame specifications \citep[see][]{Chambers+Hastie:1992}. 
The last argument specifies several parameters controlling the processing of the BayesX binary which 
are arranged by function \fct{bayesx.control}, e.g. the choice between the inferential 
concepts, set within argument \code{method}, which are currently Markov chain Monte Carlo simulation 
techniques - \code{"MCMC"}, mixed model based estimation - \code{"REML"} and penalized least squares 
including model selection - \code{"STEP"}, or the distribution assigned to the response, set with 
argument \code{family}. An overview of all available distributions is given in 
table~\ref{tab:familiy}.
\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|p{4cm}|p{2.5cm}|l|}
\hline
\code{family} & Response distribution & Link & \code{method} \\ \hline
\code{"gaussian"} & Gaussian & identity & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"gamma"} & gamma & log & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"binomial"} & binomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"binomialprobit"} & binomial & probit  & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"multinomial"} & unordered multinomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ 
  \hline
\code{"poisson"} & Poisson & log-link & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"cumprobit"} & cumulative threshold & probit & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"cox"} & continuous-time survival data & -  & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"multistate"} & continuous-time multi-state data & - & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"multinomialprobit"} & unordered multinomial & probit & \code{"MCMC"} \\ \hline
\code{"nbinomial"} & negative binomial & log-link & \code{"MCMC"} \\ \hline
\code{"zip"} & zero inflation & log-link & \code{"MCMC"} \\ \hline
\code{"binomialcomploglog"} & binomial & complementary log-log & \code{"REML"} \\ \hline
\code{"cumlogit"} & cumulative multinomial & logit & \code{"REML"} \\ \hline
\code{"seqlogit"} & sequential multinomial & logit & \code{"REML"} \\ \hline
\code{"seqprobit"} & sequential multinomial & probit & \code{"REML"}  \\ \hline
\code{"multinomialcatsp"} & unordered multinomial (with category-specific covariates) & logit & 
  \code{"REML"} \\ \hline
\end{tabular}
\caption{\label{tab:familiy} Distributions implemented for \code{method}s \code{"MCMC"}, 
\code{"REML"} and \code{"STEP"} within the \pkg{BayesX} package.}
\end{center}
\end{table}

As mentioned in the introduction, package \pkg{BayesX} utilizes function \fct{s} from the \pkg{mgcv} 
package to build the additive components of a STAR predictor within \proglang{R}'s formula language.
In addition, unit- or cluster specific unstructured effects may be incorporated into the 
\code{formula} using the random effects term constructor function \fct{r}. Then, a typical STAR 
predictor with some response \code{y}, covariate \code{x1} with a possibly nonlinear effect modeled 
by a P-spline, covariate \code{id} representing some cluster index modeled as random effect and 
covariate \code{x2} entering linearly, is e.g. formulated by
\begin{Sinput}
y ~ s(x1, bs = "ps") + r(id) + x2
\end{Sinput} 
where argument \code{bs} of function \fct{s} specifies the smooth bases, the type of term that 
should enter the \code{formula}. A list of the implemented model terms in \pkg{BayesX} is provided 
in table~\ref{tab:terms}.
Setting additional arguments for a model term is generally restricted to argument \code{xt} 
within function \fct{s} and \fct{r}, i.e. \code{xt} must be a named \fct{list} including these 
parameters, where all possibilities for each \code{bs} type may be looked up calling function 
\fct{bayesx.term.options}. As an example, using \code{bs = "mrf"} to estimate a spatially correlated
effect with Markov random fields with some location identification covariate \code{id}, requires an 
additional map boundary (\fct{read.bnd}) or graph file (\fct{read.gra}) for the calculation of a 
neighborhood-matrix to guarantee smooth estimates over adjacent regions, which must be provided 
within \code{xt}, then 
\begin{Sinput}
s(id, bs = "mrf", xt = list(map = SomeMap)) 
\end{Sinput} 
constructs the setup for this type of model term.

Past the execution of all computations with the BayesX binary, the model output files are written 
into the declared output directory, which per default is the temporary directory of the running
session, and are read back into \proglang{R} using function \fct{read.bayesx.output}. The returned 
fitted-model object is a list of class \code{"bayesx"}, wherefore a set of standard extractor 
functions and methods, listed in table~\ref{tab:funmethods}, is available. 

The quite flexible \code{S3} class function \fct{plot.bayesx}, usually called from the generic 
\fct{plot}, is handy generating model diagnostic plots, term effects plots, applying 2d, 3d, 
image and map graphics, as well as sampling paths of coefficients and variances for MCMC estimated 
models, e.g.
\setkeys{Gin}{width=0.49\textwidth}
<<plot-illustration-model-samples-01, echo=TRUE, eval=FALSE, fig=FALSE, width=5, height=4>>=
plot(b2, term = "s(x0)", which = "coef-samples")
@
\begin{figure}[t!]
\setkeys{Gin}{width=0.6\textwidth}
\begin{center}
<<plot-illustration-model-samples-02, echo=FALSE, fig=TRUE, width=7, height=7>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b2, term = "s(x2)", which = "coef-samples", main = "")
@
\end{center}
\caption{\label{fig:illustration-samples} Illustration example: Plots of the sampling paths of the 
coefficients of term \code{s(x2)} in model \code{b2}.}
\end{figure}
produces plots of coefficient sampling paths as shown in figure~\ref{fig:illustration-samples}. 

Another noteworthy feature of package \pkg{BayesX} is the internal handling of data. During MCMC
simulation, BayesX only uses different observations of covariates, where the number of unique
observations is typically much smaller than the total number of observations in the dataset. I.e.
this primarily allows for a potential speedup of algorithm run-times, and secondly reduces the risk
of possible storage problems in the computer memory. To exploit this within \proglang{R} using a
large dataset, which might produce difficulties with \proglang{R}'s object memory allocation, the 
user may specify the \code{data} argument in function \fct{bayesx} as the path to a dataset stored 
in the respective directory. As a consequence, this dataset will not be loaded within \proglang{R} 
and is only used internally by the BayesX binary, and as a result, the output files written will 
typically have much less memory size and may be imported to \proglang{R} for further analysis. To 
give an example we generate a large dataset and store it on disc in the temporary folder of the 
running session with
<<large-data-01, echo=TRUE, eval=FALSE>>=
n <- 100000
file <- paste(tempdir(), "/data.raw", sep = "")
write.table(matrix(c("x", "y"), nrow = 1), file = file, 
  quote = FALSE, row.names = FALSE, col.names = FALSE)
for(i in 1:50) {
  dat <- data.frame(x = round(runif(n, -3, 3), 2))
  dat$y <- with(dat, sin(x) + rnorm(n, sd = 2))
  write.table(dat, file = file, append = TRUE, 
    quote = FALSE, row.names = FALSE, col.names = FALSE)
}
@ 
This produces a dataset of approximately 110Mb with only 601 unique observations for covariate 
\code{x}. The path to the dataset is stored in object \code{file}, which may then provided to the 
function call
<<large-data-01, echo=TRUE, eval=FALSE>>=
b <- bayesx(y ~ s(x, bs = "ps"), data = file, 
  iter = 3000, burnin = 500, step = 2, predict = FALSE)
@ 
to start BayesX. Argument \code{predict} is set to \code{FALSE}, i.e. only output files of estimated
effects will be returned, otherwise an expanded dataset would be written in the output directory,
also containing the data used for estimation. \fixme{Runtime\dots}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|p{2cm}|p{10cm}|}
\hline
\code{bs} & Description \\ \hline
\code{"lasso"} \code{"nigmix"} \code{"ridge"} & shrinkage of fixed effects: defines a 
                                                shrinkage-prior for the corresponding parameters 
                                                $\gamma_j$, $j = 1, \ldots, q$, $q \geq 1$ of the 
                                                linear effects $x_1, \ldots, x_q$. There are three 
                                                priors possible: ridge-, lasso- and Normal Mixture 
                                                of inverse Gamma (NMIG)-prior. \\ \hline
\code{"bl"} & nonlinear baseline effect in hazard regression or multi-state models: defines a 
              P-spline with second order random walk penalty for the parameters of the spline for 
              the log-baseline effect $log(\lambda(time))$. \\ \hline
\code{"kr"} & kriging with stationary Gaussian random fields. \\ \hline
\code{"gk"} & geokriging with stationary Gaussian random fields: estimates a stationary Gaussian 
              random field based on the centroids of a map object provided in boundary format within
              the \code{xt} argument of function \fct{s}. \\ \hline
\code{"gs"} & geosplines based on two-dimensional P-splines with first order random walk penalty: 
              defines a two-dimensional P-spline for the spatial covariate region with a 
              two-dimensional first order random walk penalty for the parameters of the spline. 
              Estimation is based on the coordinates of the centroids of the regions provided by a 
              map object in in boundary format within the \code{xt} argument of function \fct{s}.\\ 
              \hline
\code{"mrf"} & Markov random fields: defines a Markov random field prior for a spatial covariate, 
               where geographical informations are provided by a map object in boundary or graph 
               file format within the \code{xt} argument of function \fct{s}.\\ \hline
\code{"ps"} & P-spline with first or second order difference penalty. \\ \hline
\code{"rw1"} \code{"rw2"} & zero degree P-splines: defines a zero degree P-spline with first or 
                            second order difference penalty. A zero degree P-spline typically 
                            estimates for every distinct covariate value in the data set a separate 
                            parameter. Usually there is no reason to prefer zero degree P-splines 
                            over higher order P-splines. An exception are ordinal covariates or 
                            continuous covariates with only a small number of different values. 
                            For ordinal covariates higher order P-splines are not meaningful while 
                            zero degree P-splines might be an alternative to modeling nonlinear 
                            relationships via a dummy approach with completely unrestricted 
                            regression parameters\\ \hline
\code{"season"} & seasonal effect of a time scale. \\ \hline
\code{"te"} & defines a two-dimensional P-spline based on the tensor product of one-dimensional 
              P-splines with a two-dimensional first order random walk penalty for the parameters of 
              the spline. \\ \hline
\code{"generic"} & general purpose model term. \\ \hline
\end{tabular}
\caption{\label{tab:terms} Possible BayesX model terms within function \fct{s}.}
\end{center}
\end{table}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Function & Description \\ \hline
\fct{AIC}, \fct{BIC}, \fct{DIC}, \fct{GCV} & compute information criteria, availability is dependent 
                                             on the \code{method} used. \\ \hline
\fct{c} & combines several objects of class \code{"bayesx"}, all functions and methods may be 
          applied on the returned object. \\ \hline
\fct{coef} & extracts coefficients of linear modeled terms, for \code{"MCMC"} estimated models, 
             the samples of the coefficients are provided within the object attribute 
             \code{"sample"}. \\ \hline
\fct{confint} & compute confidence interval of linear modeled terms if \code{method = "REML"}, for
                \code{"MCMC"} the quantiles of the coefficient samples according to a specified 
                level are computed. \\ \hline
\fct{cprob} & extract contour probabilities of a particular P-spline term, only meaningful if 
              \code{method = "MCMC"} and e.g. argument \code{contourprob} is specified within
              argument \code{xt} in function \fct{s}, e.g. 
              \code{s(x, bs = "ps", xt = list(contourprob = 4))}. \\ \hline
\fct{fitted} & fitted values of either the linear predictor, or a select model term. \\ \hline
\fct{logLik} & extract fitted log-likelihood, only if \code{method = "REML"}. \\ \hline
\fct{plot} & either model diagnostic plots or effect plots of particular terms. \\ \hline
\fct{print} & simple printed display of the initial call and some additional information of the
              fitted model. \\ \hline
\fct{residuals} & extract model or partial residuals for a select term. \\ \hline
\fct{summary} & returns an object of class \code{"summary.bayesx"} containing the relevant summary 
                statistics (which has a \fct{print} method). \\ \hline
\fct{terms} & extract terms of model components. \\ \hline
\end{tabular}
\caption{\label{tab:funmethods} Functions and methods for objects of class \code{"bayesx"}.}
\end{center}
\end{table}


\newpage


\section{STAR models in practice} \label{sec:illustrations}

The focus of this section is on demonstrating the various features of the \pkg{BayesX} package, 
therefore, the examples provided are replicate analysis taken from \citet{Brezger+Kneib+Lang:2005} 
and \citet{Fahrmeir+Kneib+Lang:2009}, the \pkg{VGAM} package \citep{Yee:2009} and the \pkg{mgcv} 
package, which ensure straightforward traceability of the code presented, since all datasets may be 
loaded within the discussed CRAN packages. 


\subsection{Childhood malnutrition in Zambia} \label{subsec:zambia}

This analysis has already been conducted by \citet{Kandala+Lang+Klasen+Fahrmeir:2001} and has also 
been used as a demonstrating example in \citet{Brezger+Kneib+Lang:2005}. Stunting is one of the 
leading drivers of a number of problems development countries are faced with, for instance, a direct 
consequence of stunting is a high mortality rate. Here, the primary interest is to model the 
dependence of stunting of newborn children, with an age ranging from 0 to 5 years, on covariates 
such as the body mass index of the mother, the age of the child and others presented in 
table~\ref{tab:zambia}. 
\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Variable           & Description \\ \hline
\code{stunting}    & standardised Z-score for stunting. \\ \hline
\code{bmi}         & body mass index of the mother. \\ \hline
\code{agechild}    & age of the child in months. \\ \hline
\code{district}    & district where the mother lives. \\ \hline
\code{memployment} & mother's employment status with categories `working' and 
                     `not working'. \\ \hline
\code{education}   & mother's educational status with categories for complete primary but incomplete 
                     secondary `no/incomplete', complete secondary or higher `minimum primary' and 
                     no education or incomplete primary `minimum secondary'. \\ \hline
\code{urban}       & locality of the domicile with categories `yes' and `no'. \\ \hline
\code{gender}      & gender of the child with categories `male' and `female'. \\ \hline
\end{tabular}
\caption{\label{tab:zambia} Variables in the data set on childhood malnutrition in Zambia.}
\end{center}
\end{table}
The response \code{stunting} is defined in terms of a reference 
category, i.e in this dataset the stunting for child $i$ is represented by
\begin{equation*}
\texttt{stunting}_i = \frac{\texttt{AI}_i - \texttt{MAI}_i}{\sigma},
\end{equation*}
where \texttt{AI} refers to the child's anthropometric indicator (height at a certain age in our 
example), while \texttt{MAI} and $\sigma$ correspond to the median and the standard deviation in the 
reference population, respectively.

The data for this analysis is provided in the \pkg{BayesX} package and can be loaded with
<<data-zambia, echo=TRUE, eval=TRUE>>=
data("ZambiaNutrition", package = "R2BayesX")
@
For the final model, incorporating a structured spatial effect for the districts in Zambia using a 
Markov random fields term within the \code{formula} specifiaction, BayesX needs some information 
about the district neighborhood structure, which e.g. is enclosed in 
<<data-zambia-bnd, echo=TRUE, eval=TRUE>>=
data("ZambiaBnd", package = "R2BayesX")
@
With the information of the boundary file an appropriate penalty is computed, allowing for a 
smoothly varying effect of neighboring regions. The object \code{ZambiaBnd} has class \code{"bnd"} 
and is basically a \fct{list} of polygon matrices, one matrix for each district, with $x$-, in the 
first, and $y$-coordinates, in the second column respectively, of the boundary points. There is a 
generic plotting method implemented for objects of class \code{"bnd"}, which in principle calls 
function \fct{plotmap}, e.g. a simple map, as shown in figure~\ref{fig:zambia-simple-map}, of the districts in Zambia is drawn typing
<<plot-zambia-map-01, echo=TRUE, eval=FALSE>>=
plot(ZambiaBnd)
@ 
\begin{figure}[h!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<plot-zambia-map-02, echo=FALSE, eval=TRUE, fig = TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(ZambiaBnd)
@ 
\end{center}
\caption{\label{fig:zambia-simple-map} Example on childhood malnutrition: A simple map of the 
districts in Zambia.}
\end{figure}
Having loaded the necessary files, the model \code{formula} is then specified with
<<formula-zambia, echo=TRUE, eval=TRUE>>=
mf <- stunting ~ memployment + education + urban + gender + 
  s(bmi, bs = "ps") + s(agechild, bs = "ps") +
  s(district, bs = "mrf", xt = list(map = ZambiaBnd)) + r(district)
@
where the two continuous covariates \code{bmi} and \code{agechild} are assumed to have a possibly 
nonlinear effect on \code{stunting} and are modeled with P-splines, \code{bs = "ps"}. Furthermore, 
a decomposition of the spatial effect is achieved by specifying a Markov random field term with 
\code{bs = "mrf"} for the structured and a random effects term, using function \fct{r}, for an
unstructured spatial effect. Finally, a gaussian model is fitted using MCMC by calling
<<fit-zambia-model, echo=TRUE, eval=FALSE>>=
zm <- bayesx(mf, method = "MCMC", iter = 12000, 
  burnin = 2000, step = 10, data = ZambiaNutrition)
@
<<cache-zambia-model, echo=FALSE, eval=TRUE>>=
if(file.exists("zambia-model.rda")) {
load("zambia-model.rda")
} else {
<<fit-zambia-model>>
save(zm, file = "zambia-model.rda")
}
@
where argument \code{iter}, \code{burnin} and \code{step} set the number of iterations of the MCMC 
simulation, the burnin period, which will be removed from the generated samples, and the step length 
for which samples should be stored, i.e. \code{step = 10} forces saving of only every 10th sampled 
parameter.

After the model has been successfully fitted, the generic call  
<<summary-zambia-model>>=
summary(zm)
@
provides summary statistics of the MCMC fitted-model object, which typically includes mean, standard 
deviation and quantiles of sampled linear effects, smooth terms variances and random effects 
variances, as well as goodness of fit criteria. The estimated effects for covariates 
\code{agechild} and \code{bmi} may be visualized with
<<zambia-agechild-bmi-plot, echo=TRUE, eval=FALSE>>=
plot(zm, term = c("s(agechild)", "s(bmi)"))
@
\begin{figure}[h!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<zambia-agechild, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "s(agechild)")
@
<<zambia-bmi, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "s(bmi)")
@
\end{center}
\caption{\label{fig:zambia-agechild} Example on childhood undernutrition: Effect of the body 
mass index of the child's mother and of the age of the child together with pointwise 80\% and 95\% 
credible intervals.}
\end{figure}
and are show in figure~\ref{fig:zambia-agechild}. 
Figure~\ref{fig:zambia-district-structured-unstructured} shows estimates of the structured and 
unstructured spatial effect, generated with
<<zambia-agechild-bmi-plot, echo=TRUE, eval=FALSE>>=
plot(zm, term = c("s(district)", "r(district)"), 
  map = ZambiaBnd, pos = "topleft", 
  density = 20, angle = 90)
@
\begin{figure}[h!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<zambia-district-structured, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(zm, term = "s(district)", map = ZambiaBnd, 
  pos = "topleft", width = 0.6, height = 0.2, 
  distance.labels = 2, swap = TRUE)
@
<<zambia-district-unstructured, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(zm, term = "r(district)", map = ZambiaBnd, 
  pos = "topleft", width = 0.6, height = 0.2, 
  distance.labels = 2L, swap = TRUE, 
  density = 20, angle = 90)
@
\end{center}
\caption{\label{fig:zambia-district-structured-unstructured} Example on childhood malnutrition:
Structured, left panel, and unstructured spatial effect, right panel respectively.}
\end{figure}
noting that if argument \code{map} is not supplied, the effects will also be visualized using 
function \fct{blockplot}. Besides plotting of sampling paths, as mentioned in 
section~\ref{sec:implementation}, for any term in the model, the samples of the parameters are 
stored as an attribute in the fitted term object and are e.g. extracted for term \code{s(bmi)} by 
the following
<<zambia-coef-extract, echo=TRUE, eval=TRUE, fig=FALSE>>=
fit.bmi <- fitted(zm, term = "s(bmi)")
head(attr(fit.bmi, "sample"), 4)
head(attr(fit.bmi, "variance.sample"), 4)
@
where \code{"sample"} represents samples of regression coefficients and \code{"variance.sample"}
samples of the variance parameter of the smooth. In addition, autocorrelation functions may be 
drawn, for instance of the variance samples, as shown in figure~\ref{fig:zambia-autocorr}, by typing
<<zambia-autocorr-01, echo=TRUE, eval=FALSE>>=
plot(zm, term = "s(bmi)", which = "var-samples", 
  acf = TRUE, lag.max = 250)
@
\begin{figure}[h!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<zambia-autocorr-02, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(1.1, 1.1, 0.1, 0.1))
plot(zm, term = "s(bmi)", which = "var-samples", 
  acf = TRUE, lag.max = 250, main = NA)
@
\end{center}
\caption{\label{fig:zambia-autocorr} Example on childhood undernutrition: Autocorrelation function
of the samples of the variance parameter of term \code{s(bmi)}.}
\end{figure}


\newpage


\subsection{Forest health data set} \label{subsec:forest}

The forest health dataset comprises information on the defoliation of beech trees, which serves as 
an indicator of overall forest health here. The data was collected annually from 1980 to 1997 during 
a project of visual inspection of trees around Rothenbuch, Germany, and is discussed in detail in 
\citet{Fahrmeir+Kneib+Lang:2009}, wherein the percentage rate of defoliation of each tree is 
aggregated into three ordinal categories, also see table~\ref{tab:forest} for a description of all 
variables in the dataset. 
\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Variable           & Description \\ \hline
\code{id}          & tree location identification number. \\ \hline
\code{year}        & year of census. \\ \hline
\code{defoliation} & percentage of tree defoliation in three ordinal
                     categories, 0 == `defoliation < 12.5\%', 1 == `12.5\% $\leq$
                     defoliation < 50\%' and 2 == `defoliation $\geq$ 50\%'. \\ \hline
\code{x}           & x-coordinate of the tree location. \\ \hline
\code{y}           & y-coordinate of the tree location. \\ \hline
\code{age}         & age of stands in years. \\ \hline
\code{canopy}      & forest canopy density in percent. \\ \hline
\code{inclination} & slope inclination in percent. \\ \hline
\code{elevation}   & elevation (meters above sea level). \\ \hline
\code{soil}        & soil layer depth in cm. \\ \hline
\code{ph}          & soil pH at 0-2cm depth. \\ \hline
\code{moisture}    & soil moisture level with categories 1 == `moderately
                     dry', 2 == `moderately moist' and 3 == `moist or temporarily
                     wet'. \\ \hline
\code{alkali}      & proportion of base alkali-ions with categories 1 == `low' 
                     to 4 == `high'. \\ \hline
\code{humus}       & humus layer thickness in cm. \\ \hline
\code{stand}       & stand type with categories `deciduous' and `mixed'. \\ \hline
\code{fertilized}  & fertilization applied with categories `yes' and `no'. \\ \hline
\end{tabular}
\caption{\label{tab:forest} Variables in the forest health data set.}
\end{center}
\end{table}

Following \citet{Fahrmeir+Kneib+Lang:2009}, we start with the following three categorical ordered 
logit model, where $P(\texttt{defoliation}_{it} = r)$ of tree $i$ at time $t$, $r = 1,2$, is modeled
in terms of a set of linearly and smooth entering covariates specified with
<<forest-model-formula-01, echo=TRUE, eval=TRUE>>=
data("ForestHealth", package = "R2BayesX")
mf <- defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22)
@
fit this model using REML and a cumulative multinomial distribution for the response by
<<fit-forest-model-01, echo=TRUE, eval=FALSE>>=
fm1 <- bayesx(mf, family = "cumlogit", 
  method = "REML", data = ForestHealth)
@
<<fit-forest-model-02, echo=FALSE, eval=FALSE>>=
data("BeechBnd", "BeechGra", package = "R2BayesX")
fm2 <- bayesx(defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22) + 
  s(id, bs = "mrf", xt = list(map = BeechGra)),
  family = "cumlogit", method = "REML", data = ForestHealth)
@
<<cache-forest-model, echo=FALSE, eval=TRUE>>=
if(file.exists("forest-model.rda")) {
load("forest-model.rda")
} else {
<<fit-forest-model-01>>
<<fit-forest-model-02>>
save(fm1, fm2, file = "forest-model.rda")
}
@
and finally visualize the estimated effects for the nonparametric modeled terms 
<<fit-forest-model-01-plots, echo=TRUE, eval=FALSE>>=
plot(fm2, term = c("s(age)","s(inclination)",
  "s(canopy)","s(year)","s(elevation)"))
@
as shown in figure~\ref{fig:forest-no-spatial}. In this example some contradictory results occur. 
The effect of covariate \code{age} on the \code{defoliation} seems to decline for both, younger and 
older trees, which intuitively should be a monotone increasing effect, this also holds for the 
effect of \code{elevation}. In addition, the extremely raw estimate of \code{inclination} is hardly
interpretable. Therefore, the authors extend the model by a spatial effect, which we model with a
Markov random field using a graph file including the neighborhood information of the adjacent trees.
The graph file and a boundary file needed for producing a map plot of the effect, are loaded 
<<forest-model-gra-bnd, echo=TRUE, eval=FALSE>>=
data("BeechBnd", "BeechGra", package = "R2BayesX")
@
where \code{BeechGra} is a square matrix with the total number of neighbors of each tree on its 
diagonal
<<forest-model-gra-bnd, echo=TRUE, eval=FALSE>>=
diag(BeechGra)
@
and otherwise entries \code{-1} if trees are neighbors, else \code{0}.
<<fit-forest-model-02, echo=TRUE, eval=FALSE>>=
fm2 <- bayesx(defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22) + 
  s(id, bs = "mrf", xt = list(map = BeechGra)),
  family = "cumlogit", method = "REML", data = ForestHealth)
@


<<summary-forest-model>>=
summary(c(fm1, fm2))
@

\begin{figure}[t!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<forest-no-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(age)")
@
<<forest-no-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(inclination)")
@ 
\\[2ex]

<<forest-no-spatial-canopy, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(canopy)")
@
<<forest-no-spatial-year, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(year)")
@ 
\\[2ex]

<<forest-no-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(elevation)")
@
\end{center}
\caption{\label{fig:forest-no-spatial} Forest damage: Estimates of nonparametric effects including
80\% and 95\% point-wise confidence intervals of the model without the spatial effect.}
\end{figure}

\begin{figure}[t!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<forest-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(age)")
@
<<forest-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(inclination)")
@
\\[2ex]

<<forest-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(elevation)")
@
\end{center}
\caption{\label{fig:forest-spatial-nonpara} Forest damage: Estimates of particular nonparametric 
effects including 80\% and 95\% point-wise confidence intervals of the model including the spatial 
effect.}
\end{figure}

\begin{figure}[t!]
\setkeys{Gin}{width=0.7\textwidth}
\begin{center}
<<forest-spatial-id, echo=FALSE, fig=TRUE, width=7, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(fm2, term = "s(id)", map = BeechBnd, 
  pos = "topleft", width = 0.4, height = 0.2, 
  distance.labels = 2)
@
\end{center}
\caption{\label{fig:forest-spatial} Forest damage: Estimate of the spatial effect.}
\end{figure}

\section{Summary}\label{sec:conclusion}


\section*{Acknowledgments}

\nocite{Kneib+Heinzl+Brezger:2011}
\bibliography{R2BayesX}


\end{document}
