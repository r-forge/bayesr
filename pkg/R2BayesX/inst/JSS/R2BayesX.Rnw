\documentclass[article]{jss}
%\documentclass[nojss]{jss}
\usepackage{amsmath,amssymb,amsfonts,thumbpdf}
\usepackage{multirow,longtable}

%% additional commands
\newcommand{\squote}[1]{`{#1}'}
\newcommand{\dquote}[1]{``{#1}''}
\newcommand{\fct}[1]{{\texttt{#1()}\index{#1@\texttt{#1()}}}}
\newcommand{\class}[1]{\dquote{\texttt{#1}}}
%% for internal use
\newcommand{\fixme}[1]{\emph{\marginpar{FIXME} (#1)}}
\newcommand{\readme}[1]{\emph{\marginpar{README} (#1)}}

\author{Nikolaus Umlauf\\Universit\"at Innsbruck \And
        Thomas Kneib\\Universit\"at Oldenburg \And
        Stefan Lang\\Universit\"at Innsbruck \And
        Achim Zeileis\\Universit\"at Innsbruck}
\Plainauthor{Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis}

\title{Structured Additive Regression Models: An \proglang{R} Interface to \pkg{BayesX}}
\Plaintitle{Structured Additive Regression Models: An R Interface to BayesX}

\Keywords{STAR models, MCMC, REML, stepwise, \proglang{R}}
\Plainkeywords{STAR models, MCMC, REML, stepwise, R}

%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

\Abstract{
Structured additive regression (STAR) models provide a flexible framework for modeling possible
nonlinear effects of covariates: They contain the well established frameworks of generalized linear
models (GLM) and generalized additive models (GAM) as special cases but also allow a wider class of
effects, e.g.\, for geographical or spatio-temporal data. This allows to specify complex and 
realistic models that can be estimated using Bayesian inference based on modern Markov chain Monte 
Carlo (MCMC) simulation techniques, based on a mixed model representation of STAR models, or with 
stepwise regression techniques combining penalized least squares estimation with model selection.
Software for fitting STAR models is provided in the standalone software package \pkg{BayesX}: a
comprehensive open-source regression toolbox written in \proglang{C++} code. \pkg{BayesX} not only 
covers models for responses from univariate exponential families, but also models from less-standard
regression situations such as models for multi-categorical responses with either ordered or 
unordered categories, continuous time survival data, or continuous time multi-state models. This
paper presents the full interactive \proglang{R} interface \pkg{R2BayesX} to \pkg{BayesX}. With the 
new package, STAR models can be conveniently specified using \proglang{R}'s formula language (with
some extended terms), fitted using the \pkg{BayesX} binary, represented in \proglang{R} with objects
of suitable classes, and finally printed/summarized/plotted. As a result of the superior graphics 
capabilities of \proglang{R} package \pkg{R2BayesX} greatly enhances the usability of \pkg{BayesX}. 
On the other hand some of the more complex models from the STAR class, especially models for 
multivariate responses, extend the already impressive capabilities for semiparametric regression in  
\proglang{R}. Moreover, \pkg{R2BayesX} is the most comprehensive package for simulation based
Bayesian semiparametric regression in \proglang{R}.
}

\Address{
  Nikolaus Umlauf, Stefan Lang, Achim Zeileis\\
  Department of Statistics\\
  Universit\"at Innsbruck\\
  Universit\"atsstr.~15\\
  A-6020 Innsbruck, Austria\\
  E-mail: \email{Nikolaus.Umlauf@uibk.ac.at},\\
  \phantom{E-mail: }\email{Stefan.Lang@uibk.ac.at},\\
  \phantom{E-mail: }\email{Achim.Zeileis@R-project.org}\\
  URL: \url{http://www.uibk.ac.at/statistics/personal/umlauf/},\\
  \phantom{URL: }\url{http://www.uibk.ac.at/statistics/personal/lang/},\\
  \phantom{URL: }\url{http://eeecon.uibk.ac.at/~zeileis/}\\

  Thomas Kneib\\
  Department of Mathematics\\
  Universit\"at Oldenburg\\
  D-26111 Oldenburg, Germany \\
  E-mail: \email{Thomas.Kneib@uni-oldenburg.de}\\
  URL: \url{http://www.staff.uni-oldenburg.de/thomas.kneib/}
}

%% Sweave/vignette information and metadata
%% need no \usepackage{Sweave}
\SweaveOpts{engine = R, eps = FALSE, keep.source = TRUE}
%\VignetteIndexEntry{Structured Additive Regression Models: An R Interface to BayesX}
%\VignetteDepends{colorspace,mgcv,BayesX,akima}
%\VignetteKeywords{STAR models, MCMC, REML, stepwise, R}
%\VignettePackage{R2BayesX}

<<preliminaries, echo=FALSE, results=hide>>=
options(width = 70, prompt = "R> ", continue = "+  ")
library("R2BayesX")
data("ZambiaBnd")
data("BeechBnd")
@


\begin{document}


\section{Introduction} \label{sec:intro}

The free software \pkg{BayesX} \citep{R2BayesX:Brezger+Kneib+Lang:2005} is a standalone program
comprising powerful tools for Bayesian and mixed model based inference in complex semiparametric
regression models with structured additive predictor (STAR, see Section~\ref{sec:model}). To gain
improved computational performance, the algorithms implemented utilize numerically efficient
(sparse) matrix architectures and are written in a \proglang{C++} environment. Besides exponential
family regression, \pkg{BayesX} also supports models for multi-categorical responses, hazard
regression for continuous survival times, and continuous time multi-state models.

In this article, we describe the full interactive \proglang{R} \citep{R2BayesX:R} interface to the
command-line binary version of BayesX, which is an extension of package \pkg{BayesX}
\citep{R2BayesX:Kneib+Heinzl+Brezger:2011}, that mainly provides functionality for exploring
estimation results. The \proglang{R} package is called \pkg{R2BayesX} and has recently been added to
the Comprehensive \proglang{R} Archive Network (CRAN,
\url{http://CRAN.R-project.org/package=R2BayesX}). Within the new package, users are now provided
with a typical \proglang{R} front end that may 
\begin{itemize}
\item specify and estimate STAR models with \pkg{BayesX} directly from the console \\
  (function \fct{bayesx}, Section~\ref{subsec:processing}),
\item apply a set of extractor functions and methods on \pkg{BayesX} fitted model objects, e.g.\ 
  producing high level graphics of estimated effects, model diagnostic plots, summary statistics and 
  more \\
  (Table~\ref{tab:funmethods}), 
\end{itemize}
In addition, users can
\begin{itemize}
\item run already existing \pkg{BayesX} input program files from \proglang{R} \\
  (function \fct{run.bayesx}, Section~\ref{sec:addoptions}),
\item automatically import \pkg{BayesX} output files into \proglang{R} \\
  (function \fct{read.bayesx.output}, Section~\ref{sec:addoptions}).
\end{itemize}

Furthermore, the models supported by \pkg{BayesX} are conveniently specified using \proglang{R}'s 
formula language definition, wherefore several special model term constructor functions, such as
the main \pkg{R2BayesX} constructor functions \fct{sx} and \fct{r} for smooth and random effects,
respectively, as well as the functions \fct{s} and \fct{te} from the \pkg{mgcv} package
\citep{R2BayesX:Wood:2011, R2BayesX:Wood:2006}, facilitate a consistent way to translate
\proglang{R} syntax into \pkg{BayesX} interpretable commands (see Section~\ref{subsec:addterms}).

The reminder of this paper is as follows. The next section gives a first example of a common 
\proglang{R} session using \pkg{R2BayesX} on a dataset on childhood malnutrition in Zambia.
Section~\ref{sec:model} briefly discusses the methodological background of regression models with a
structured additive predictor, before a description of the package functionality is given in
Section~\ref{sec:userinterface}. In Section~\ref{sec:illustrations}, the interface usability is further
illustrated with the childhood malnutrition data and a dataset on forest health.


\section{Motivating example} \label{sec:motivation}

To give an introductory example of the various features of the interface, we estimate a Bayesian
geoadditive regression model for the childhood malnutrition dataset in Zambia (see
Section~\ref{subsec:zambia}, \citealp{R2BayesX:Kandala+Lang+Klasen+Fahrmeir:2001}) using Markov
chain Monte Carlo (MCMC) simulation. 

The data consists of 4847 observations including 8 variables, both continuous and categorical. In
this analysis, the main interest is on modeling the dependence of stunting (\code{stunting}),
represented by anthropometric indicators of newborn children, on covariates including the age of the
child (\code{age}), the body mass index of the mother (\code{mbmi}) and the district the child lives
in (\code{district}). The model is given by
\begin{equation*}
\texttt{stunting}_i = \gamma_0 + f_1(\texttt{agechild}_i) + f_2(\texttt{mbmi}_i) +
  f_{spat}(\texttt{district}_i) + \varepsilon_i, \qquad \varepsilon_i \sim N(0, \sigma^2),
\end{equation*}
where the functions $f_1$ and $f_2$ of continuous covariates \code{agechild} and \code{mbmi} have
possible nonlinear effects on \code{stunting} and are  modeled nonparametrically using
P(enalized)-splines. Here, the spatially correlated effect $f_{spat}$ of locational covariate
\code{district} is modeled using Kriging based on centroid coordinates (geokriging) of the districts
in Zambia. To estimate the model with \pkg{BayesX} from \proglang{R}, the data together with a
boundary map file of the districts in Zambia is loaded with
<<data-illustration, echo=TRUE, eval=TRUE, fig=FALSE>>=
data("ZambiaNutrition", "ZambiaBnd", package = "R2BayesX")
@
Boundary files are basically shapefiles (see also package \pkg{shapefiles},
\citealp{R2BayesX:Stabler:2006}) that only include information on the polygons that form the map and
may be constructed using function \fct{shp2bnd} or imported with \fct{read.bnd}. The model formula
is specified by
<<formula-illustration, echo=TRUE, eval=TRUE, fig=FALSE>>=
f <- stunting ~ sx(agechild) + sx(mbmi) +
  sx(district, bs = "gk", map = ZambiaBnd, full = TRUE)
@

Finally, the model is fitted with the main model-fitting function \fct{bayesx}
<<fit-illustration, echo=TRUE, eval=FALSE, fig=FALSE>>=
b <- bayesx(f, family = "gaussian", method = "MCMC",
  data = ZambiaNutrition)
@
<<cache-illustration, echo=FALSE, eval=TRUE>>=
if(file.exists("illustration-model.rda")) {
load("illustration-model.rda")
} else {
<<fit-illustration>>
save(b, file = "illustration-model.rda")
}
@

Thereafter, a model summary is displayed by calling
<<summary-illustration, echo=TRUE, fig=FALSE, eval=TRUE>>=
summary(b)
@

\begin{figure}[t!]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<plot-illustration-mbmi, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b, term = "sx(mbmi)")
@
<<plot-illustration-agechild, echo=FALSE, fig=TRUE, width=5, height=4, pdf=FALSE, png=TRUE>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b, term = "sx(agechild)", residuals = TRUE, cex = 0.1, rug = FALSE)
@
\\[2ex]
\setkeys{Gin}{width=0.46\textwidth}
\hspace*{0.3cm}
<<plot-illustration-district, echo=FALSE, fig=TRUE, width=5.3, height=4, pdf=FALSE, png=TRUE>>=
par(mar = c(0, 0, 0, 0))
plot(b, term = "sx(district)", map = ZambiaBnd, swap = TRUE)
@
\caption{\label{fig:illustration} Visualization examples: Estimated effect for covariate \code{mbmi}
(black line) together with 95\% and 80\% credible intervals (upper left panel). The upper right
panel shows the estimated effect of \code{agechild} including partial residuals. The lower panel
illustrates visualization of the estimated spatial effect for covariate \code{district} using
a map effect plot.}
\end{figure}
A plot of the estimated effect for covariate \code{mbmi} may then be produced by typing
<<illustration-plot-mbmi, echo=TRUE, fig=FALSE, eval=FALSE>>=
plot(b, term = "sx(mbmi)")
@
and for covariate \code{agechild} including partial residuals by
<<illustration-plot-agechild, echo=TRUE, fig=FALSE, eval=FALSE>>=
plot(b, term = "sx(agechild)", residuals = TRUE)
@
The estimated effect of the correlated spatial effect of the districts in Zambia may e.g.\
visualized using a map effect plot generated by
<<summary-illustration, echo=TRUE, fig=FALSE, eval=FALSE>>=
plot(b, term = "sx(district)", map = ZambiaBnd)
@
The plots are shown in Figure~\ref{fig:illustration}. 


\section{STAR models} \label{sec:model}

The STAR model class supported by \pkg{R2BayesX} is based on the framework of (Bayesian) generalized
linear models (GLM) (e.g.\ see \citealp{R2BayesX:Fahrmeir+Kneib+Lang:2009} and
\citealp{R2BayesX:Fahrmeir+Tutz:2001}). GLMs assume that, given covariates $\mathbf{x}$ and unknown
parameters $\boldsymbol{\gamma}$, the distribution of the response variable $y$ belongs to an
exponential family with mean
$\mu = E(y | \mathbf{x}, \boldsymbol{\gamma})$ linked to a linear predictor $\eta$ by
\begin{equation*} \label{eqn:glm}
\mu = h^{-1}(\eta), \qquad \eta = \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation*}
where $h$ is a known link function and $\boldsymbol{\gamma}$ are unknown regression coefficients. In
STAR models \citep{R2BayesX:Fahrmeir+Kneib+Lang:2004, R2BayesX:Brezger+Lang:2006}, the linear
predictor is replaced by a more general and flexible, structured additive predictor
\begin{equation} \label{eqn:structadd}
\eta = f_1(\mathbf{z}) + \ldots + f_p(\mathbf{z}) + \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation}
with $\mu = E(y | \mathbf{x}, \mathbf{z}, \boldsymbol{\gamma}, \boldsymbol{\theta})$ and $\mathbf{z}$
represents a generic vector of all nonlinear modeled covariates. The functions $f_j$ are possibly
smooth functions comprising effects as e.g.\ given by
\begin{itemize}
  \item nonlinear effects of continuous covariates: $f_j(\mathbf{z}) = f(z_1)$,
  \item two-dimensional surfaces: $f_j(\mathbf{z}) = f(z_1, z_2)$,
  \item spatially correlated effects: $f_j(\mathbf{z}) = f_{spat}(z_s)$,
  \item varying coefficients: $f_j(\mathbf{z}) = z_1f(z_2)$,
  \item spatially varying effects: $f_j(\mathbf{z}) = z_1f_{spat}(z_s)$ or
    $f_j(\mathbf{z}) = z_1f(z_2, z_3)$,
  \item random intercepts with cluster index $c$: $f_j(\mathbf{z}) = \beta_c$,
  \item random slopes with cluster index $c$: $f_j(\mathbf{z}) = z_1\beta_c$.
\end{itemize}
STAR models cover a number of well known model classes as special cases, including generalized
additive models (GAM, \citealp{R2BayesX:Hastie+Tibshirani:1990}), generalized additive mixed models
(GAMM, \citealp{R2BayesX:Lin+Zhang:1999}), geoadditive models \citep{R2BayesX:Kamman+Wand:2003},
varying coefficient models \citep{R2BayesX:Hastie+Tibshirani:1993}, and geographically weighted
regression \citep{R2BayesX:Fotheringham+Brunsdon+Charlton:2002}.

The unified representation of a STAR predictor arises from the fact that all functions $f_j$ in
(\ref{eqn:structadd}) may be specified by a basis function approach, where the vector of function
evaluations $\mathbf{f}_j = (f_j(\mathbf{z}_{1}),\ldots,f_j(\mathbf{z}_{n}))$ of the
$i = 1,\ldots,n$ observations can be written in matrix notation
\begin{equation*} \label{eqn:matnot}
\mathbf{f}_j = \mathbf{Z}_j\boldsymbol{\beta}_j,
\end{equation*}
where the design matrix $\mathbf{Z}_j$ depends on the specific term structure chosen for $f_j$
and $\boldsymbol{\beta}_j$ are unknown regression coefficients to be estimated. Hence, the predictor
 (\ref{eqn:structadd}) may be rewritten as
\begin{equation*} \label{eqn:structaddmat}
\boldsymbol{\eta} = \mathbf{Z}_1\boldsymbol{\beta}_1 + \ldots \mathbf{Z}_p\boldsymbol{\beta}_p
+ \mathbf{X}\boldsymbol{\gamma},
\end{equation*}
where $\mathbf{X}$ corresponds to the usual design matrix for the linear effects.

To ensure particular functional forms, prior distributions are assigned to the regression
coefficients. The general form of the prior for $\boldsymbol{\beta}_j$ is
\begin{equation*} \label{eqn:prior}
p(\boldsymbol{\beta}_j | \tau_j^2) \propto \exp \left(- \frac{1}{2\tau_j^2}
\boldsymbol{\beta_j}^{\prime}\mathbf{K}_j\boldsymbol{\beta}_j\right),
\end{equation*}
where $\mathbf{K}_j$ is a quadratic penalty matrix that shrinks parameters towards zero or penalizes
too abrupt jumps between neighboring parameters. In most cases $\mathbf{K}_j$ will be rank deficient and the
prior for $\boldsymbol{\beta}_j$ is partially improper.

The variance parameter $\tau_j^2$ is equivalent to the inverse smoothing parameter in a frequentist
approach and controls the trade off between flexibility and smoothness. For full Bayesian inference,
weakly informative inverse Gamma hyperpriors $\tau_j^2 \sim IG(a_j, b_j)$ are assigned to
$\tau_j^2$, with $a_j = b_j = 0.001$ as a standard option. Small values for $a_j$ and $b_j$
correspond to an approximate uniform distribution for $\log \tau_j^2$. For empirical Bayes inference,
$\tau_j^2$ is considered an unknown constant which is determined via restricted maximum likelihood
(REML).

In \pkg{BayesX}, estimation of regression parameters is based on three inferential concepts:
\begin{enumerate}
\item \textit{Full Bayesian inference via MCMC} \\
A fully Bayesian interpretation of STAR models is obtained by specifying prior distributions for all
unknown parameters. Estimation is carried out using Markov chain Monte Carlo simulation techniques.
\pkg{BayesX} provides numerically efficient implementations of MCMC schemes for structured additive
regression models. Suitable proposal densities have been developed to obtain rapidly mixing,
well-behaved sampling schemes without the need for manual tuning
\citep{R2BayesX:Brezger+Lang:2006}.

\item \textit{Inference via a mixed model representation} \\
Another concept used for estimation is based on mixed model methodology. The general idea is to take
advantage of the close connection between penalty concepts and corresponding random effects
distributions. The smoothing variances of the priors then transform to variance components in the
random effects (mixed) model. While regression coefficients are estimated based on penalized
likelihood, restricted maximum likelihood or marginal likelihood estimation forms the basis for the
determination of smoothing parameters. From a Bayesian perspective, this yields empirical
Bayes/posterior mode estimates for the STAR models. However, estimates can also merely be
interpreted as penalized likelihood estimates from a frequentist perspective
\citep{R2BayesX:Fahrmeir+Kneib+Lang:2004}.

\item \textit{Penalized likelihood including variable selection} \\
As a third alternative \pkg{BayesX} provides a penalized least squares (or penalized likelihood)
approach for estimating STAR models. In addition, a powerful variable and model selection tool is
included. Model choice and estimation of the parameters is done simultaneously. The algorithms are
able to
\begin{itemize}
  \item decide whether a particular covariate enters the model,
  \item decide whether a continuous covariate enters the model linearly or nonlinearly,
  \item decide whether a spatial effect enters the model,
  \item decide whether a unit- or cluster-specific heterogeneity effect enters the model
  \item select complex interaction effects (two dimensional surfaces, varying coefficient terms)
  \item select the degree of smoothness of nonlinear covariate, spatial or cluster specific
    heterogeneity effects.
\end{itemize}
Inference is based on penalized likelihood in combination with fast algorithms for selecting
relevant covariates and model terms. Different models are compared via various goodness of fit
criteria, e.g.\ AIC, BIC, GCV and 5 or 10 fold cross validation \citep{R2BayesX:Belitz+Lang:2008}.
\end{enumerate}

A thorough introduction into the regression models supported by the program is also provided in the
\pkg{BayesX} methodology manual \citep{R2BayesX:Belitz+Brezger+Kneib+Lang:2011}.


\section[Implementation in R]{Implementation in \proglang{R}} \label{sec:implementation}

The design of the \proglang{R} interface to \pkg{BayesX} attempts to concern the following major
issues: First, the interfacing function calls needed to be as practical as possible and oriented at
\proglang{R}'s standards for regression model fitting functions, and secondly, to provide a set of
functions and methods for easy representation of fitted model objects, that would enhance the
usability of \pkg{BayesX}. 

In \proglang{R}, several packages for semiparametric regression models exist. The probably
best-known and recommended package is \pkg{mgcv} \citep{R2BayesX:Wood:2011}, which provides fast an
stable algorithms for estimating GAM's (see \citealp{R2BayesX:Wood:2004},
\citealp{R2BayesX:Wood:2008}). Vector generalized additive models (VGAM) for categorical responses
are covered by package \pkg{VGAM} \citep{R2BayesX:Yee:2009}. Another comprehensive package for
GAM's accounting



\section[User interface]{User interface} \label{sec:userinterface}

\subsection[Installing the BayesX binary from R]{Installing the \pkg{BayesX} binary from 
  \proglang{R}}

Before STAR models can be fitted with package \pkg{R2BayesX} from \proglang{R}, the binary
command-line version of the program \pkg{BayesX} needs to be installed and linked to \proglang{R}.
The recommended option on UNIX and Windows systems is to auto-compile/install the \pkg{BayesX}
command-line binary within \proglang{R} by calling the function \fct{install.bayesx}. Therefore
package \pkg{R2BayesX} needs to be loaded:
<<load-bayesx, echo=TRUE, eval=FALSE>>=
library("R2BayesX")
@
Installing BayesX from \proglang{R} then ideally only requires running function
\begin{Sinput}
install.bayesx(inst.dir = NULL, source.dir = NULL, type = NULL)
\end{Sinput}
where argument \code{inst.dir} is a path to a valid installation directory with user writing
permissions (e.g.\ for Windows systems \code{inst.dir = "C:/BayesX"}).
If \code{source.dir = NULL}, the necessary installation files will automatically tried to be
downloaded from the \pkg{BayesX} homepage (url: \url{http://www.stat.uni-muenchen.de/~bayesx}).
Otherwise \code{source.dir} specifies the path where \fct{install.bayesx} may either find the packed
sources \code{bayesxsource.zip} (url:
\url{http://www.stat.uni-muenchen.de/~bayesx/install/bayesxsource.zip}), or using Windows, the
installer \code{BayesX\_windows.exe} (url:
\url{http://www.stat.uni-muenchen.de/~bayesx/install/BayesX_windows.exe}). If the corresponding
file is available, \fct{install.bayesx} will then attempt to execute the Windows installation
process as described in the Appendix~\ref{appendix:wininstall}, or to compile the sources as shown
in Appendix~\ref{appendix:otherinstall}, respectively. If argument \code{type} is set to
\code{type = "sources"}, compilation of the sources using the GNU Compiler Collection (GCC) C
compiler is forced on any platform.


\subsection[Linking the BayesX binary to R]{Linking the \pkg{BayesX} binary to \proglang{R}}
\label{subsec:linking}
After the successful compilation/installation, usually the full path to the command-line binary
needs to be declared to \proglang{R} at the beginning of every new session by setting
<<options-bayesx, echo=TRUE, eval=FALSE>>=
options(bayesx.bin = "/path/to/BayesX")
@
where \code{"/path/to/BayesX"} is e.g.\ the path provided to argument \code{inst.dir} of function \\
\fct{install.bayesx}, with the name of the \pkg{BayesX} binary at last. On Windows platforms the 
name of the binary is \code{"bayesx.exe"}, on all other platforms commonly \code{"BayesX"}. Hence,
on Windows systems the user may specify e.g.\
<<options-bayesx-windows, echo=TRUE, eval=FALSE>>=
options(bayesx.bin = "C:/BayesX/commandline/bayesx.exe")
@
To avoid setting the path to the binary each time \proglang{R} is starting, it is suggested to add
the code above to the \proglang{R} startup profile site, see also  Appendix~\ref{appendix:linking}.
Afterwards, the function call
<<check-install-bayesx, echo=TRUE, eval=FALSE>>=
check.install.bayesx()
@
will check if \pkg{BayesX} is available from \proglang{R}.

\subsection[Processing BayesX from R]{Processing \pkg{BayesX} from \proglang{R}}
\label{subsec:processing}

\hypertarget{bayesx}{The} main model-fitting function in the package \pkg{R2BayesX} is called
\fct{bayesx}. The arguments of \fct{bayesx} are
\begin{Sinput}
bayesx(formula, data, weights = NULL, subset = NULL,
  offset = NULL, na.action = na.fail, contrasts = NULL,
  family = "gaussian", method = "MCMC", control = bayesx.control(...),
  ...)
\end{Sinput}
where the first two lines basically represent the standard model frame specifications
\citep[see][]{R2BayesX:Chambers+Hastie:1992}. However, the object supplied to argument \code{data}
is not necessarily an \proglang{R} data object, it is also possible to provide a character string
with a path to a dataset stored on disc, which may be reasonable when using large datasets. An 
example is given in Section~\ref{sec:addoptions}. Additional contrast specifications for 
factor variables can be passed to argument \code{contrasts}. Using factors, we recommend deviation
or effect coding (see function \fct{contr.sum}) rather than the usual dummy coding of factors as it
typically improves the convergence of estimation algorithms used in \pkg{BayesX}. The distribution
assigned to the response may be set with argument \code{family}, the default is
\code{family = "gaussian"}. Note that family objects are currently not supported by BayesX. Argument
\code{method} determines the inferential concept used for estimation. Options are: Markov chain
Monte Carlo simulation - \code{"MCMC"}, mixed model based estimation using restricted maximum
likelihood/marginal likelihood - \code{"REML"} and penalized likelihood including model selection
- \code{"STEP"}. An overview of all available distributions for the different methods is given in
Table~\ref{tab:family}.
\begin{table}[t!]
\centering
\begin{tabular}{|lp{4cm}p{1.3cm}l|}
\hline
\code{family} & Response distribution & Link & \code{method} \\ \hline
\code{"binomial"} & binomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\
\code{"binomialprobit"} & binomial & probit  & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\
\code{"gamma"} & gamma & log & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\
\code{"gaussian"} & Gaussian & identity & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\
\code{"multinomial"} & unordered multinomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\
\code{"poisson"} & Poisson & log-link & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"cox"} & continuous-time survival data &  & \code{"MCMC"} \code{"REML"} \\
\code{"cumprobit"} & cumulative threshold & probit & \code{"MCMC"} \code{"REML"} \\
\code{"multistate"} & continuous-time multi-state data & & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"binomialcomploglog"} & binomial & compl. log-log & \code{"REML"} \\
\code{"cumlogit"} & cumulative multinomial & logit & \code{"REML"} \\
\code{"multinomialcatsp"} & unordered multinomial (with category-specific covariates) & logit &
  \code{"REML"} \\
\code{"multinomialprobit"} & unordered multinomial & probit & \code{"MCMC"} \\
\code{"seqlogit"} & sequential multinomial & logit & \code{"REML"} \\
\code{"seqprobit"} & sequential multinomial & probit & \code{"REML"}  \\ \hline
\end{tabular}
\caption{\label{tab:family} Distributions implemented for \code{method}s \code{"MCMC"},
\code{"REML"} and \code{"STEP"}.}
\end{table}
The last argument specifies several parameters controlling the processing of the \pkg{BayesX} binary 
that are arranged by function \fct{bayesx.control}. Note that all additional controlling arguments
are automatically parsed within function \fct{bayesx} using the dot do dot argument ``\code{...}'',
which is send to \fct{bayesx.control}. The most important parameters for the different methods are
listed in Table~\ref{tab:control}.
\begin{table}[!ht]
\renewcommand\multirowsetup{\centering}
\centering
\begin{tabular}{|llp{10.3cm}|}
\hline
\code{method} & Parameter & Description \\ \hline
\multirow{3}{*}[-0.8cm]{\code{"MCMC"}} & \code{iterations} & integer, sets the number of iterations
                                         for the sampler, default: 12000. \\
 & \code{burnin} & integer, sets the burn-in period of the sampler, default: 2000. \\
 & \code{step} & integer, defines the thinning parameter for MCMC simulation. E.g.,\code{step = 50}
              means, that only every 50th sampled parameter will be stored and used to compute
              characteristics of the posterior distribution as means, standard deviations or
              quantiles, default: 10. \\ \hline
\multirow{2}{*}[-1.5cm]{\code{"REML"}} & \code{eps} & numeric, defines the termination criterion of
                                         the estimation process. If both the relative changes in the
                                         regression coefficients and the variance parameters are
                                         less than \code{eps}, the estimation process is assumed to
                                         have converged, default: 0.00001. \\
 & \code{maxit} & integer, defines the maximum number of iterations to be used in estimation. Since
               the estimation process will not necessarily converge, it may be useful to define an
               upper bound for the number of iterations. \\ \hline
\multirow{3}{*}[-3.2cm]{\code{"STEP"}} & \code{algorithm} & character, specifies the selection
                   algorithm. Possible values are \code{"cdescent1"} (adaptive algorithms see
                   subsection 6.3 in \citealp{R2BayesX:Belitz+Brezger+Kneib+Lang:2011}),
                   \code{"cdescent2"} (adaptive algorithms 1 and 2 with backfitting, see remarks 1
                   and 2 of section 3 in \citealp{R2BayesX:Belitz+Lang:2008}), \code{"cdescent3"}
                   (search according to cdescent1 followed by cdescent2 using the selected model in
                   the first step as the start model) and \code{"stepwise"} (stepwise algorithm
                   implemented in the \code{gam} function of \proglang{S}-plus, see
                   \citealp{R2BayesX:Chambers+Hastie:1992}), default: \code{"cdescent1"}. \\
 & \code{criterion} & character, specifies the goodness of fit criterion. If
                   \code{criterion = "MSEP"} is specified the data are randomly divided into a
                   test- and validation dataset. The test dataset is used to estimate the models
                   and the validation dataset is used to estimate the mean squared prediction error
                   (MSEP) which serves as the goodness of fit criterion to compare different
                   models, possible criterions are: \code{"GCV"}, \code{"GCVrss"}, \code{"AIC"}, 
                   \code{"AIC\_imp"}, \code{"BIC"}, \code{"MSEP"}, \code{"CV5"}, \code{"CV10"} and
                   \code{"AUC"}, default: \code{"AIC\_imp"}. \\
 & \code{startmodel} & character, defines the start model for variable selection. Options are
                    \code{"linear"}, \code{"empty"}, \code{"full"} and \code{"userdefined"},
                    default: \code{"linear"}. \\
\hline
\end{tabular}
\caption{\label{tab:control} Most important controlling parameters for the different methods using
function \fct{bayesx}. (A detailed documentation is provided in the manual of function
\fct{bayesx.control} of package \pkg{R2BayesX}.)}
\end{table}

The returned fitted model object is a list of class \code{"bayesx"}, which is supported by several
standard extractor functions, such as \fct{plot} and \fct{summary}. For models estimated using
method \code{"REML"}, function \fct{summary} generates summary statistics similar to objects
returned from the main model fitting function \fct{gam} of the \pkg{mgcv} package. For \code{"MCMC"}
estimated models, the mean, standard deviation and quantiles of parameter samples are provided.
Using \code{"STEP"}, the parametric part of the summary statistics is represented like
\code{"MCMC"}, i.e.\ if computed, the confidence bands are based on an MCMC algorithm subsequent to
the model selection, while the remaining summary is similar to \code{"REML"}. The implemented
\proglang{S}3 methods for plotting fitted term objects are quite flexible, i.e., depending on the
term structure, the generic function \fct{plot} calls one of the following functions: for 2d plots
function \fct{plot2d} or \fct{plotblock} (for factors, unit- or cluster specific plots, draws a
block for every estimated parameter including mean and credible intervals), for perspective or image
and contour plots function \fct{plot3d}, map effects plots are produced by function \fct{plotmap},
with or without colorlegends drawn by function \fct{colorlegend}, amongst others. See
Table~\ref{appendix:plotting} in the Appendix for an overview of the most important arguments for
the plotting functions. In some situations it may be useful to inspect the log file generated by the
\pkg{BayesX} binary. The file can either be viewed directly during processing if argument
\code{verbose} is set to \code{TRUE} in function \fct{bayesx.control}, or extracted from the fitted
model object using function \fct{bayesx\_logfile}. For MCMC post estimation diagnosis, besides the
implemented trace and autocorrelation plots, samples of the parameters may also be extracted using
function \fct{samples}. The sampling paths are provided as a data frame, and hence may e.g.\ be
converted to objects of class \code{"mcmc"} using the \pkg{coda} package
\citep{R2BayesX:Plummer+Best+Cowles+Vines:2006} for further analysis. In addition, an \proglang{R}
script for the estimated model, including function calls for saving, loading, plotting of term
effects and diagnostic plots, may be generated using function \fct{getscript}. The produced
\proglang{R} script may be useful for less experienced users of the package to get a quick overview
of post estimation commands. Moreover, the script facilitates the final preparation of plots and
diagnostics to be included in publications. A list of all available functions and methods of package
\pkg{R2BayesX} can be found in Table~\ref{tab:funmethods}.
\begin{table}[t!]
\centering
\begin{tabular}{|p{3.2cm}p{11cm}|}
\hline
Function & Description \\ \hline
\fct{print} & simple printed display of the initial call and some additional information of the
              fitted model. \\
\fct{summary} & returns an object of class \code{"summary.bayesx"} containing the relevant summary
                statistics (which has a \fct{print} method). \\ \hline
\fct{coef} & extracts coefficients of the linear modeled terms. \\
\fct{confint} & compute confidence intervals of linear modeled terms if \code{method = "REML"}, for
                \code{"MCMC"} the quantiles of the coefficient samples according to a specified
                probability level are computed. \\
\fct{cprob} & extract contour probabilities of a particular P-spline term, only meaningful if
              \code{method = "MCMC"} and argument \code{contourprob} is specified as an additional
              argument in the term constructor function \fct{sx}, or within argument \code{xt} in
              function \fct{s}. E.g.\ in the introductory example, contour probabilities for the
              term using covariate \code{mbmi} are estimated with
              \code{s(mbmi, bs = "ps", xt = list(contourprob = 4))} (see also
              Section~\ref{subsec:addterms}). \\
\fct{fitted} & fitted values of either the mean and linear predictor, or a selected model term. \\
\fct{bayesx\_logfile}, \fct{bayesx\_prgfile}, \fct{bayesx\_runtime} & extracts the internal 
                                             \pkg{BayesX} log file, the program file and the overall 
                                             runtime of the binary. \\
\fct{residuals} & extract model or partial residuals for a selected term. \\
\fct{samples} & extract samples of parameters from MCMC simulation. \\ \hline
\fct{terms} & extract terms of model components. \\
\fct{model.frame} & extract/generate a model frame. \\
\fct{logLik} & extract fitted log-likelihood, only if \code{method = "REML"}. \\ \hline
\fct{plot} & either model diagnostic plots or effect plots of particular terms. \\
\fct{getscript} & generate an \proglang{R} script for term effect, diagnostic plots and model
                  summary statistics. \\ \hline
\fct{AIC},$\phantom{n}$\fct{BIC}, \fct{DIC},$\phantom{n}$\fct{GCV} & computes information criteria,
                                             availability is dependent on the \code{method} used.
                                             \\ \hline
\end{tabular}
\caption{\label{tab:funmethods} Functions and methods for objects of class \code{"bayesx"}. (A
detailed documentation is provided in the manual of package \pkg{R2BayesX}.)}
\end{table}

\clearpage

\subsection[Available additive terms]{Available additive terms}
\label{subsec:addterms}
In package \pkg{R2BayesX}, the main constructor function for specifying additive terms in STAR
\code{formula}s is called \fct{sx}. The function is basically an interface to the term constructor
function \fct{s} of package \pkg{mgcv}, i.e.\ it is possible to either use \fct{sx} or \fct{s} for
\code{formula}s within function \fct{bayesx}. Function \fct{s} is a very flexible function for
implementing new terms for the model fitting function \fct{gam}, but also greatly supports the
syntax translation methods implemented in \pkg{R2BayesX}. The major reason for interfacing function
\fct{s} is to provide a similar adjustable, but more adaptive set up to the \pkg{BayesX} specific
model terms, specifications and defaults. Furthermore, using MCMC estimation, the number of options
that may be set for particular model terms is large, wherefore the representation of a function call
to \fct{sx} is slightly more parsimonious. 

The arguments of function \fct{sx} are
\begin{Sinput}
sx(x, z = NULL, bs = "ps", by = NA, ...)
\end{Sinput}
where \code{x} represents the covariate that is used for univariate and \code{z} for bivariate model
terms. Argument \code{bs} chooses the basis/type of the term, possible options are shown in
Table~\ref{tab:terms}.
\begin{table}[t!]
\centering
\begin{tabular}{|p{3.2cm}p{10.5cm}|}
\hline
\code{bs} & Description \\ \hline
\code{"rw1"}, \code{"rw2"} & zero degree P-splines: defines a zero degree P-spline with first or
                            second order difference penalty. A zero degree P-spline typically
                            estimates for every distinct covariate value in the dataset a separate
                            parameter. Usually there is no reason to prefer zero degree P-splines
                            over higher order P-splines. An exception are ordinal covariates or
                            continuous covariates with only a small number of different values.
                            For ordinal covariates higher order P-splines are not meaningful while
                            zero degree P-splines might be an alternative to modeling nonlinear
                            relationships via a dummy approach with completely unrestricted
                            regression parameters. \\
\code{"season"} & seasonal effect of a time scale. \\
\code{"ps"}, \code{"psplinerw1"}, \code{"psplinerw2"} & P-spline with first or second order 
                                                        difference penalty. \\
\code{"te"}, \code{"pspline2dimrw1"} & defines a two-dimensional P-spline based on the tensor 
              product of one-dimensional P-splines with a two-dimensional first order random walk 
              penalty for the parameters of the spline. \\
\code{"kr"}, \code{"kriging"} & kriging with stationary Gaussian random fields. \\ \hline
\code{"gk"}, \code{"geokriging"} & geokriging with stationary Gaussian random fields: estimates a 
              stationary Gaussian random field based on the centroids of a map object provided in 
              boundary format (see function \fct{read.bnd} and \fct{shp2bnd}) as an additional
              argument named \code{map} within function \fct{sx}, or supplied within argument
              \code{xt} when using function \fct{s}, e.g.\ \code{xt = list(map = MapBnd)}. \\
\code{"gs"}, \code{"geospline"} & geosplines based on two-dimensional P-splines with first order 
              random walk penalty: defines a two-dimensional P-spline for the spatial covariate 
              region with a two-dimensional first order random walk penalty for the parameters of 
              the spline. Estimation is based on the coordinates of the centroids of the regions 
              of a map object provided in boundary format (see function \fct{read.bnd} and
              \fct{shp2bnd}) as an additional argument named \code{map} within function \fct{sx}, or
              supplied within argument \code{xt} when using function \fct{s}, e.g.\
              \code{xt = list(map = MapBnd)}. \\
\code{"mrf"}, \code{"spatial"} & Markov random fields: defines a Markov random field prior for a 
               spatial covariate, where geographical information is provided by a map object in 
               boundary or graph file format (see function \fct{read.bnd}, \fct{read.gra} and
               \fct{shp2bnd}), as an additional argument named \code{map} within function \fct{sx},
               or supplied within argument \code{xt} when using function \fct{s}, e.g.\
               \code{xt = list(map = MapBndorGra)}. \\ \hline
 & \\
\multicolumn{2}{|r|}{continued on next page} \\ \hline
\end{tabular}
\end{table}

\begin{table}[t!]
\centering
\begin{tabular}{|p{3.2cm}p{10.5cm}|}
\hline
\multicolumn{2}{|l|}{continued from previous page} \\ 
 & \\ \hline
\code{"bl"}, \code{"baseline"} & nonlinear baseline effect in hazard regression or multi-state 
              models: defines a P-spline with second order random walk penalty for the parameters of 
              the spline for the log-baseline effect $\log(\lambda(time))$. \\
\code{"factor"} & special \pkg{BayesX} specifier for factors, especially meaningful if
                  \code{method = "STEP"}, since the factor term is then treated as a full term,
                  which is either included or removed from the model. \\
\code{"ridge"}, \code{"lasso"}, \code{"nigmix"} & shrinkage of fixed effects: defines a
                                                shrinkage-prior for the corresponding parameters
                                                $\gamma_j$, $j = 1, \ldots, q$, $q \geq 1$ of the
                                                linear effects $x_1, \ldots, x_q$. There are three
                                                priors possible: ridge-, lasso- and Normal Mixture
                                                of inverse Gamma prior. \\ \hline
\end{tabular}
\caption{\label{tab:terms} Possible \pkg{BayesX} model terms within function \fct{sx} and \fct{s}.}
\end{table}
Note that it is possible to specify all term type versions presented in the table, the short and
the original ones that are used within \pkg{BayesX}, e.g.\
\code{bs = "ps"} or \code{bs = "psplinerw2"} result in the same type of model term. A numeric or a
factor variable can be provided to argument \code{by} to estimate varying coefficient terms, where
the effect of the variable provided to \code{by} varies over the range of the covariate(s) of this
term. The dot dot dot ``\code{...}'' argument is used to specify term specific control parameters
or additional geographical information. In the example Section~\ref{sec:motivation}, to modify the
degree and the inner knots for the P-spline term \code{sx(mbmi)}, the user may e.g.\ type
\code{sx(mbmi, degree = 2, knots = 10)}. For supplying additional boundary or graph files (see
function \fct{read.bnd}, \fct{read.gra}, \fct{shp2bnd} and \fct{bnd2gra} for importing and creation
of spatial objects that may be send to \pkg{BayesX}), that are used to compute suitable neighborhood
penalty matrices for terms using Markov random field priors, or to calculate the centroids of
particular regions for geosplines and geokriging terms, an argument named \code{map} needs to be
provided. For instance, the necessary boundary file \code{ZambiaBnd} for the geokriging term in
Section~\ref{sec:motivation} is included with \code{sx(district, bs = "gk", map = ZambiaBnd)}.
Information about all possible extra arguments for a particular term basis/type can be looked up
using function \fct{bayesx.term.options}, e.g.\ possible options for P-splines using \code{"MCMC"}
are printed to the console by 
\begin{Sinput}
R> bayesx.term.options(bs = "ps", method = "MCMC")

possible options for 'bs = "ps"': 

     degree: the degree of the B-spline basis functions.
            Default: integer, 'degree = 3'.

      knots: number of inner knots.
            Default: integer, 'knots = 20'.

\end{Sinput}
For reasons of simplicity only the first two additional controlling arguments are shown.

Some care has to be taken with the identifiability of varying coefficients terms. The standard in
\pkg{BayesX} is to center nonlinear main effects terms around zero whereas varying coefficient terms 
are not centered. This makes sense since main effects nonlinear terms are not identifiable and 
varying coefficients terms are usually identifiable. However, there are situations where a varying
coefficients term is not identifiable. Then the term must be centered. Since centering is not
automatically accomplished it has to be enforced by the user by adding option \code{center = TRUE}
in function \fct{sx}. To give an example, the varying coefficient terms in
$\eta = \ldots + g_1(z_1)z + g_2(z_2)z + \gamma_0 + \gamma_1 z + \ldots$ are not identified, whereas
in $\eta = \ldots + g_1(z_1)z + \gamma_0 + \ldots$, the varying coefficient term is identifiable. In
the first case, centering is necessary, in the second case, it is not.

As mentioned above, users may optionally call the constructor function \fct{s} directly. The usage
of \fct{s} in \pkg{R2BayesX} is in principle similar to package \pkg{mgcv}. The applicable arguments
are
\begin{Sinput}
s(..., k = -1, bs = "ps", m = NA, by = NA, xt = NULL)
\end{Sinput}
Within \fct{s}, the list of covariates used for the model term is set with argument ``\code{...}''. 
For instance, in the example of Section~\ref{sec:motivation}, the term for the body mass index of the
mother may also be included in the model formula by \code{s(mbmi)}, a term with two covariates is
specified e.g.\ with \code{s(mbmi, agechild)}. Here, the parameter \code{k} controls the dimension
of the basis used for smooth terms. Setting argument \code{m} is only meaningful for P-splines,
i.e.\ \code{bs = "ps"}, and controls the degree of the B-spline basis functions and the order of the
difference penalty. E.g.\ a B-spline of degree 3 with a 2nd order difference penalty is set with
\code{s(mbmi, bs = "ps", m = c(1, 2))} (note that argument \code{m} is slightly different than
argument \code{degree} in function \fct{sx} using P-splines, see also the manual of \fct{s}).
Argument \code{by} is used in the same way as for \fct{sx}. The additional parameters that are
specified by argument ``\code{...}'' in function \fct{sx}, may be set in \fct{s} within argument
\code{xt}, e.g.\ similar to the example above, the boundary object \code{ZambiaBnd} is supplied with
\code{s(district, bs = "gk", xt = list(map = ZambiaBnd))}. Besides \fct{s}, \pkg{R2BayesX} also
supports calls to the tensor product constructor function \fct{te}, however, only a small set of the 
features of this function is supported.

In addition to \fct{sx}, \fct{s} and \fct{te}, unit- or cluster specific unstructured (random)
effects may be incorporated into the model \code{formula} using the random effects term constructor
function \fct{r}. The arguments of \fct{r} are
\begin{Sinput}
r(id, by = NA, xt = NULL)
\end{Sinput}
where \code{id} is the unit or cluster identification covariate the random effects should be
estimated for. E.g.\ the model formula from the introduction could be extended by a random effects
term for the districts in Zambia with \code{r(district)}.  Argument \code{by} takes covariates
for which random slopes may be estimated. Argument \code{xt} is used in the same way as
described for function \fct{s}, i.e.\ similar to the above, e.g.\ hyperpriors $a$ and $b$ for the
variance parameter are set  with \code{r(district, xt = list(a = 0.0001, b = 0.0001))}.


\subsection[Additional options]{Additional options} \label{sec:addoptions}

For most practical purposes fitting models with function \fct{bayesx} may be sufficient. However,
the interfacing functions that are consecutively called within \fct{bayesx} can also be used
independently. This could be meaningful for two reasons: First, users may want to use already
existing \pkg{BayesX} program files wherefore a new setup within \proglang{R} is not required, and
secondly, there might be a need for automated importing of \pkg{BayesX} output files into 
\proglang{R} for further analysis.

\hypertarget{run.bayesx}{Function} \fct{run.bayesx} is used to run an arbitrary \pkg{BayesX} program 
file. The arguments of \fct{run.bayesx} are
\begin{Sinput}
run.bayesx(dir, prg.name = "bayesx.estim.input.prg",
  verbose = FALSE, bin = getOption("bayesx.bin"))
\end{Sinput}
where \code{dir} is a character string with the directory the program file is stored in and
\code{prg.name} is the name of the corresponding program file. During processing of \pkg{BayesX} 
several informations will be printed to the \proglang{R} console if \code{verbose = TRUE}. Argument
\code{bin} specifies the location of the \pkg{BayesX} \code{bin}ary the program file is sent to, see 
also Section~\ref{subsec:linking}. The function returns a list including the log file returned by
\pkg{BayesX} as well as information on the total runtime.

\hypertarget{read.bayesx.output}{Model} output files are imported using function
\begin{Sinput}
read.bayesx.output(dir, model.name = NULL)
\end{Sinput}
Here, \code{dir} is again a directory and \code{model.name} the name of the model the files are
imported for, also provided as character strings. Note that the function will search for all
different BayesX estimated models in the declared directory if argument \code{model.name} is set to
\code{NULL}. The returned object is also of class \code{"bayesx"}, i.e.\ all the functions and
methods described in Table~\ref{tab:funmethods} may be applied.

Another noteworthy feature of package \pkg{R2BayesX} is the internal handling of data. \pkg{BayesX} 
uses numerically efficient algorithms including sparse matrix computations which in principle allow 
to estimate models using large datasets. Moreover, the number of different observations for 
particular covariates is usually much smaller than the total number of observations. That is, the 
output files returned by the binary only include estimates for unique covariate values. Since these 
files typically reserve much less disc space, importing the fitted model objects into \proglang{R} 
using \fct{read.bayesx.output} is straightforward in most cases, whereas handling the complete 
dataset within \proglang{R} may be problematic. As mentioned in Section~\ref{subsec:processing}, 
users can exploit this by providing a character string to argument \code{data} in function 
\fct{bayesx}, which includes the path to a dataset instead of an \proglang{R} data object. As a 
consequence, this dataset will not be loaded within \proglang{R} and is only used internally by the 
\pkg{BayesX} binary. To give an example, we generate a large dataset that might produce problems 
with \proglang{R}'s memory allocation using a model fitting function, especially if the model 
contains a large number of parameters. Therefore, we store the data on disc in the temporary folder 
of the running session with
<<large-data, echo=TRUE, eval=FALSE>>=
set.seed(321)
file <- paste(tempdir(), "/data.raw", sep = "")
n <- 5e+06
dat <- data.frame(x = rep(runif(1000, -3, 3), length.out = n))
dat$y <- with(dat, sin(x) + rnorm(n, sd = 2))
write.table(dat, file = file, quote = FALSE, row.names = FALSE)
@ %$
This produces a dataset of approximately 170Mb with only 1000 unique observations for covariate
\code{x}. The path to the dataset is stored in object \code{file} and is provided to argument
\code{data} in the function call
<<large-data-01, echo=TRUE, eval=FALSE>>=
b <- bayesx(y ~ sx(x), family = "gaussian", method = "MCMC", 
  iterations = 3000, burnin = 1000, step = 2, predict = FALSE, 
  data = file, seed = 123)
@
For illustration purposes, the number of iterations is only set to 3000. Note that argument
\code{predict} is set to \code{FALSE}, i.e.\ only output files of estimated effects will be returned,
otherwise an expanded dataset using all observations would be written in the output directory, also
containing the data used for estimation. The runtime of this example is about 4 1/2 hours
\begin{Sinput}
R> bayesx_runtime(b)

    user   system  elapsed 
16442.12     7.56 16461.33 
\end{Sinput}
on a Linux system with an Intel 2.33GHz Dual Core processor, while the returned object \code{b} uses
\begin{Sinput}
R> print(object.size(b), units = "Mb")

0.4 Mb
\end{Sinput}
of memory size.


\clearpage


\section{STAR models in practice} \label{sec:illustrations}

The focus of this section is on demonstrating the various features of the \pkg{R2BayesX} package.
Therefore, the examples provided are replicate analysis taken from
\citet{R2BayesX:Brezger+Kneib+Lang:2005} and \citet{R2BayesX:Fahrmeir+Kneib+Lang:2009}. The
presented datasets have been added to package \pkg{R2BayesX}, ensuring straightforward traceability
of the following code. In the first example, a Gaussian regression model is estimated using Markov
chain Monte Carlo simulation. The second example covers estimation based on mixed model technology,
where a cumulative threshold model is assigned for the response variable (see
\citet{R2BayesX:Fahrmeir+Tutz:2001} and \citet{R2BayesX:Kneib+Fahrmeir:2004} for
cumulative threshold models). The last example
illustrates the approach of the stepwise algorithm for model and variable selection.

\subsection{Childhood malnutrition in Zambia: Analysis with MCMC} \label{subsec:zambia}

This analysis has already been conducted by \citet{R2BayesX:Kandala+Lang+Klasen+Fahrmeir:2001} and
has also been used as a demonstrating example in \citet{R2BayesX:Brezger+Kneib+Lang:2005}. Stunting
is one of the leading drivers of a number of problems development countries are faced with, for
instance, a direct consequence of stunting is a high mortality rate. Here, the primary interest is
to model the dependence of stunting of newborn children, with an age ranging from 0 to 5 years, on
covariates such as the body mass index of the mother, the age of the child and others presented in
Table~\ref{tab:zambia}.
\begin{table}[htbp]
\centering
\begin{tabular}{|lp{10cm}|}
\hline
Variable           & Description \\ \hline
\code{stunting}    & standardized Z-score for stunting. \\
\code{mbmi}        & body mass index of the mother. \\
\code{agechild}    & age of the child in months. \\
\code{district}    & district where the mother lives. \\
\code{memployment} & mother's employment status with categories `yes' and `no'. \\
\code{meducation}  & mother's educational status with categories for no education or incomplete
                     primary `no', complete primary but incomplete secondary `primary' and complete
                     secondary or higher `secondary'. \\
\code{urban}       & locality of the domicile with categories `yes' and `no'. \\
\code{gender}      & gender of the child with categories `male' and `female'. \\ \hline
\end{tabular}
\caption{\label{tab:zambia} Variables in the dataset on childhood malnutrition in Zambia.}
\end{table}
The response \code{stunting} is standardized in terms of a reference population, i.e in this dataset
stunting for child $i$ is represented by
\begin{equation*}
\texttt{stunting}_i = \frac{AI_i - MAI}{\sigma},
\end{equation*}
where $AI$ refers to a child's anthropometric indicator (height at a certain age in our example),
while MAI and $\sigma$ correspond to the median and the standard deviation in the reference
population, respectively.

Following \citet{R2BayesX:Kandala+Lang+Klasen+Fahrmeir:2001}, we estimate a structured additive
regression model with predictor
\begin{eqnarray} \label{eqn:zambia-eta}
\eta &=& \gamma_0 + \gamma_1\texttt{memploymentyes} + \gamma_2\texttt{urbanno} +
         \gamma_3\texttt{genderfemale} + \nonumber \\
     & & \gamma_4\texttt{meducationno} + \gamma_5\texttt{meducationprimary} + 
         \nonumber \\
     & & f_1(\texttt{mbmi}) + f_2(\texttt{agechild}) + f_{str}(\texttt{district}) +
         f_{unstr}(\texttt{district})
\end{eqnarray}
where \code{memploymentyes} is the deviation (effect) coded version of covariate \code{memployment},
generated with function \fct{contr.sum} by setting the contrasts argument of the factor variable,
i.e.\ \code{memploymentyes} contains of values -1, corresponding to `yes', and 1, `no'
respectively, likewise for covariates \code{genderfemale}, \code{urbanno}, \code{meducationno}
and \code{meducationprimary}. As mentioned in the introduction, functions $f_1$ and $f_2$ of
the continuous covariates \code{agechild} and \code{mbmi} are assumed to have a possibly nonlinear
effect on \code{stunting} and are therefore modeled with P-splines. Furthermore, the spatial effect
is decomposed into a structured effect $f_{str}$, modeled by a Gaussian Markov random field, and an
unstructured effect $f_{unstr}$, using a random effects term for the districts in Zambia.

The data for this analysis is provided in the \pkg{R2BayesX} package and can be loaded with
<<data-zambia, echo=TRUE, eval=TRUE>>=
data("ZambiaNutrition", package = "R2BayesX")
@
Since function $f_{str}$ is modeled by a Markov random fields term, \pkg{BayesX} needs information
about the district neighborhood structure, which e.g.\ is enclosed in the file
<<data-zambia-bnd, echo=TRUE, eval=TRUE>>=
data("ZambiaBnd", package = "R2BayesX")
@
The object \code{ZambiaBnd} has class \code{"bnd"} and is basically a \fct{list} of polygon
matrices, with $x$- and $y$-coordinates of the boundary points in the first and second column
respectively. To read in an arbitrary boundary file into \proglang{R} function \fct{read.bnd} can
be used. With the information of the boundary file \pkg{BayesX} may compute an appropriate adjacency 
matrix, allowing for a smoothly varying effect of the neighboring regions. There is a generic 
plotting method implemented for objects of class \code{"bnd"}, which in principle calls function
\fct{plotmap}. E.g.\ a simple map, as shown in Figure~\ref{fig:zambia-simple-map}, of the districts
in Zambia is drawn by typing
<<plot-zambia-map-01, echo=TRUE, eval=FALSE>>=
plot(ZambiaBnd)
@
\begin{figure}[!t]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<plot-zambia-map-02, echo=FALSE, eval=TRUE, fig = TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(ZambiaBnd, col = "lightgray")
@
\caption{\label{fig:zambia-simple-map} Example on childhood malnutrition: A simple map of the
districts in Zambia.}
\end{figure}
Having loaded the necessary files, the model \code{formula} is specified with
<<formula-zambia, echo=TRUE, eval=TRUE>>=
f <- stunting ~ memployment + urban + gender + meducation +
  sx(mbmi) + sx(agechild) + sx(district, bs = "mrf", map = ZambiaBnd) + 
  r(district)
@
The model is then fitted using MCMC by calling
<<fit-zambia-model, echo=TRUE, eval=FALSE>>=
zm <- bayesx(f, family = "gaussian", method = "MCMC",
  iterations = 12000, burnin = 2000, step = 10,
  seed = 123, data = ZambiaNutrition)
@
<<cache-zambia-model, echo=FALSE, eval=TRUE>>=
if(file.exists("zambia-model.rda")) {
load("zambia-model.rda")
} else {
<<fit-zambia-model>>
save(zm, file = "zambia-model.rda")
}
@
Argument \code{iterations}, \code{burnin} and \code{step} set the number of iterations of the MCMC
simulation, the burnin period, which will be removed from the generated samples, and the step length
for which samples should be stored, i.e.\ if \code{step = 10}, every 10th sampled parameter will
be saved. In most applications 12000 iterations should be enough for a valid fit with sufficiently
small autocorrelations of stored parameters, at least in the model building stage. However, it is
absolutely necessary to take a look at sampled parameters and autocorrelation functions to check the
mixing behavior (see below). Moreover, it is generally advisable to specify a higher number of
iterations for the final model that appears in publications. Argument \code{seed} sets the state of
the random number generator in \pkg{BayesX}, which is meaningful for exact replication of the 
examples.

After the model has been successfully fitted, summary statistics of the MCMC estimated model object
may be printed with
<<summary-zambia-model>>=
summary(zm)
@
which typically includes mean, standard deviation and quantiles of sampled linear effects, smooth
terms variances and random effects variances, as well as goodness of fit criteria and some other
information about the model. The estimated effects for covariates \code{agechild} and \code{mbmi}
may then be visualized with
<<zambia-agechild-mbmi-plot, echo=TRUE, eval=FALSE>>=
plot(zm, term = c("sx(mbmi)", "sx(agechild)"))
@
\begin{figure}[!t]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<zambia-mbmi, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "sx(mbmi)")
@
<<zambia-agechild, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "sx(agechild)")
@
\caption{\label{fig:zambia-agechild} Example on childhood malnutrition: Effect of the body mass
index of the child's mother and of the age of the child together with pointwise 80\% and 95\%
credible intervals.}
\end{figure}
and are shown in Figure~\ref{fig:zambia-agechild}.

A visual representation of the structured and unstructured spatial effect can be obtained
in two ways. Using the plain plot function
<<zambia-district-example-kde, echo=TRUE, eval=FALSE>>=
plot(zm, term = c("sx(district)", "r(district)"))
@
produces a kernel density estimator of the posterior mean of the effects, see Figure
\ref{fig:zambia-district-structured-unstructured-kde}.
\begin{figure}[!t]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<zambia-district-structured-kde, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.4, 1.1))
plot(zm, term = "sx(district)", map = FALSE, main = "")
@
<<zambia-district-unstructured-kde, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.4, 1.1))
plot(zm, term = "r(district)", map = FALSE, main = "")
@
\caption{\label{fig:zambia-district-structured-unstructured-kde} Example on childhood malnutrition:
Kernel density estimates of the mean of the structured, left panel, and the unstructured spatial
effect, right panel respectively.}
\end{figure}
The kernel densities reveal the general form of the random effects distributions. To view the
spatial structure of the correlated effect we have to use the plot function in combination with the
boundary object \code{ZambiaBnd}:
<<zambia-district-example, echo=TRUE, eval=FALSE>>=
plot(zm, term = "sx(district)", map = ZambiaBnd)
@
The generated map effect plot is shown in Figure~\ref{fig:zambia-district-structured-unstructured}.
\begin{figure}[!t]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<zambia-district-structured, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(zm, term = "sx(district)", map = ZambiaBnd, swap = TRUE)
@
<<zambia-district-unstructured-samescale, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
range <- max(abs(range(fitted(zm, term = "sx(district)")$Mean)))
range <- lrange <- c(-1 * range, range)
plot(zm, term = "r(district)", map = ZambiaBnd,
  swap = TRUE, range = range, lrange = lrange)
@
\caption{\label{fig:zambia-district-structured-unstructured} Example on childhood malnutrition:
Estimated mean effect of the structured spatial effect (left panel), together with the unstructured
spatial effect using the color and legend scaling of the structured effect (right panel).}
\end{figure}
As a default the districts of Zambia are colored in a symmetrical range within
$+- max(|min(pmean)|,|max(pmean)|)$. In many situations the visual impression of the colored map is
problematic. This is primarily the case if there are some districts with extraordinarily high
posterior means compared to the rest of the districts. Then the map is dominated by the colors of
these outlying districts. A more informative map may be obtained by restricting the range of the
plotting area using the range option. For the Zambia data the corresponding random effects are
comparably symmetric and without outlying districts such that the plot function with default options
produces fairly informative maps. To demonstrate the range option we draw the unstructered random
effect within the same range as the structured random effect
<<zambia-district-example-redraw, echo=TRUE, eval=FALSE>>=
range <- max(abs(range(fitted(zm, term = "sx(district)")$Mean)))
range <- lrange <- c(-1 * range, range)
plot(zm, term = "r(district)", map = ZambiaBnd, 
  range = range, lrange = lrange)
@ %$
The resulting map is also shown in Figure~\ref{fig:zambia-district-structured-unstructured} (right 
panel). Using for both the structured and the unstructered effect the same scale is useful for 
comparison. In most cases one of the two effects clearly dominates the other. In our case the 
structured spatially correlated effect clearly exceeds the unstructured effect.

For MCMC post estimation diagnosis, it is also possible to extract sampling paths of parameters with
function \fct{samples}, or to plot the samples directly. For instance, coefficient sampling paths
for term \code{sx(mbmi)} are displayed with
<<zambia-mbmi-coef-samples, echo=TRUE, eval=FALSE, fig=FALSE>>=
plot(zm, term = "sx(mbmi)", which = "coef-samples")
@
see Figure~\ref{fig:zambia-mbmi-coef-samples}. The plot of sampled parameters should ideally show
white noise, i.e.\ more or less uncorrelated samples that show no particular pattern. In our case the
samples are exactly as they should be.
\begin{figure}[!t]
\setkeys{Gin}{width=0.75\textwidth}
\centering
<<zambia-mbmi-coef-samples-do, echo=FALSE, fig=TRUE, width=7, height=8>>=
par(oma = c(0.01, 0.01, 0.01, 0.01))
plot(zm, term = "sx(mbmi)", which = "coef-samples", main = NA)
@
\caption{\label{fig:zambia-mbmi-coef-samples} Example on childhood malnutrition: Sampling paths of
the first 12 coefficients of term \code{sx(mbmi)}.}
\end{figure}
In addition, autocorrelation functions may be drawn, e.g.\ for the variance samples of term
\code{sx(mbmi)}, by typing
<<zambia-autocorr-01, echo=TRUE, eval=FALSE>>=
plot(zm, term = "sx(mbmi)", which = "var-samples", acf = TRUE)
@
The maximum autocorrelation of all sampled parameters in the model are displayed with
<<zambia-autocorr-02, echo=TRUE, eval=FALSE>>=
plot(zm, which = "max-acf", acf = TRUE)
@
\begin{figure}[!t]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<zambia-autocorr-03, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "sx(mbmi)", which = "var-samples",
  acf = TRUE, main = "")
@
<<zambia-autocorr-04, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, which = "max-acf", main = "")
@
\caption{\label{fig:zambia-autocorr} Example on childhood malnutrition: Autocorrelation function
of the samples of the variance parameter of term \code{sx(mbmi)}, left panel, maximum autocorrelation
of all parameters of the model, right panel respectively.}
\end{figure}
Autocorrelations for all lags should be close to zero as is the case in our example. See
Figure~\ref{fig:zambia-autocorr}, for the autocorrelation plots.

In some situations problems may occur during processing of the \pkg{BayesX} binary, that are not
automatically detected by the main model fitting function \fct{bayesx}. Therefore the user may
inspect the log-file generated by the binary in two ways: Setting the option \code{verbose = TRUE}
in \fct{bayesx.control} will print all information produced by \pkg{BayesX} simultaneously at 
runtime. The option is especially helpful if \pkg{BayesX} crashes. Another way to obtain the 
log-file is to use function \fct{bayesx\_logfile} if \pkg{BayesX} successfully finished processing. 
In this example the log-file may be printed with
\begin{Sinput}
R> bayesx_logfile(zm)

> bayesreg b
> map ZambiaBnd
> ZambiaBnd.infile using /tmp/Rtmpa3Z6WF/bayesx/ZambiaBnd.bnd
NOTE: 57 regions read from file /tmp/Rtmpa3Z6WF/bayesx/ZambiaBnd.bnd
> dataset d
> d.infile using /tmp/Rtmpa3Z6WF/bayesx/bayesx.estim.data.raw
NOTE: 14 variables with 4847 observations read from file
/tmp/Rtmpa3Z6WF/bayesx/bayesx.estim.data.raw

> b.outfile = /tmp/Rtmpa3Z6WF/bayesx/bayesx.estim
> b.regress stunting = mbmi(psplinerw2,nrknots=20,degree=3) +
    agechild(psplinerw2,nrknots=20,degree=3) + district(spatial,map=ZambiaBnd) +
    district(random) + memploymentyes + urbanno + genderfemale + meducationno +
    meducationprimary, family=gaussian iterations=12000 burnin=2000 step=10
    setseed=123 predict using d
NOTE: no observations for region 11
NOTE: no observations for region 84
NOTE: no observations for region 96


BAYESREG OBJECT b: regression procedure

GENERAL OPTIONS:

  Number of iterations:  12000
  Burn-in period:        2000
  Thinning parameter:    10


RESPONSE DISTRIBUTION:

  Family: Gaussian
  Number of observations: 4847
  Number of observations with positive weights: 4847
  Response function: identity
  Hyperparameter a: 0.001
  Hyperparameter b: 0.001
\end{Sinput}
To simplify matters only a fragment of the log-file is shown in the above. The log-file typically
provides information on the used data, model specifications, algorithms and possible error
messages.


\subsection{Forest health dataset: Analysis with REML} \label{subsec:forest}

The dataset on forest health comprises information on the defoliation of beech trees, which serves
as an indicator of overall forest health here. The data was collected annually from 1980 to 1997
during a project of visual inspection of trees around Rothenbuch, Germany, see
\citet{R2BayesX:Goettlein+Pruscha:1996}, and is discussed in detail in
\citet{R2BayesX:Fahrmeir+Kneib+Lang:2009}. In this example, the percentage rate of defoliation of
each tree is aggregated into three ordinal categories, which are modeled in terms of covariates
characterizing the stand and site of a tree. In addition, temporal and spatial information is
available, see also Table~\ref{tab:forest}.
\begin{table}[!ht]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
Variable           & Description \\ \hline
\code{id}          & tree location identification number. \\
\code{year}        & year of census. \\
\code{defoliation} & percentage of tree defoliation in three ordinal
                     categories, `defoliation < 12.5\%', `12.5\% $\leq$ defoliation < 50\%' and
                     `defoliation $\geq$ 50\%'. \\
\code{age}         & age of stands in years. \\
\code{canopy}      & forest canopy density in percent. \\
\code{inclination} & slope inclination in percent. \\
\code{elevation}   & elevation (meters above sea level). \\
\code{soil}        & soil layer depth in cm. \\
\code{ph}          & soil pH at 0-2cm depth. \\
\code{moisture}    & soil moisture level with categories `moderately dry', `moderately moist' and
                     `moist or temporarily wet'. \\
\code{alkali}      & proportion of base alkali-ions with categories `very low', `low', `high' and
                     `very high'. \\
\code{humus}       & humus layer thickness in cm. \\
\code{stand}       & stand type with categories `deciduous' and `mixed'. \\
\code{fertilized}  & fertilization applied with categories `yes' and `no'. \\ \hline
\end{tabular}
\caption{\label{tab:forest} Variables in the forest health dataset.}
\end{table}

cumulative threshold model is assigned for the response

Similar to \citet{R2BayesX:Fahrmeir+Kneib+Lang:2009}, we start with a threshold model and cumulative
logit link, with $P(\texttt{defoliation}_{it} \leq r)$ of tree $i$ at time $t$, $r = 1,2$, and the
additive predictor
\begin{eqnarray*}
\eta_{it}^{(r)} &=& f_1(\texttt{age}_{it}) + f_2(\texttt{inclination}_{i}) +
  f_3(\texttt{canopy}_{it}) + f_4(\texttt{year}) + f_5(\texttt{elevation}_{i}) +
  \mathbf{x}_{it}^{\prime}\boldsymbol{\gamma}
\end{eqnarray*}
where  $f_1, \dots, f_5$  are possibly nonlinear smooth of the continuous covariates
and $\mathbf{x}_{it}^{\prime}\boldsymbol{\gamma}$ comprises covariates with parametric
effects using deviation (effect) coding for factor covariates.

To estimate the model within \proglang{R} the data is loaded and the model formula specified with
<<forest-model-formula-01, echo=TRUE, eval=TRUE>>=
data("ForestHealth", package = "R2BayesX")
f <- defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil +
  sx(age) + sx(inclination) + sx(canopy) + 
  sx(year) + sx(elevation)
@
The covariates entering nonlinearly are again modeled by P-splines. The model is then fitted
applying REML by assigning a cumulative logit model and calling
<<fit-forest-model-01, echo=TRUE, eval=FALSE>>=
fm1 <- bayesx(f, family = "cumlogit",
  method = "REML", data = ForestHealth)
@
<<fit-forest-model-02, echo=FALSE, eval=FALSE>>=
data("BeechBnd", package = "R2BayesX")
fm2 <- bayesx(defoliation ~  stand + fertilized +
  humus + moisture + alkali + ph + soil +
  sx(age) + sx(inclination) + sx(canopy) + sx(year) +
  sx(elevation) + sx(id, bs = "gs", map = BeechBnd),
  family = "cumlogit", method = "REML", 
  data = ForestHealth)
@
<<cache-forest-model, echo=FALSE, eval=TRUE>>=
if(file.exists("forest-model.rda")) {
load("forest-model.rda")
} else {
<<fit-forest-model-01>>
<<fit-forest-model-02>>
save(fm1, fm2, file = "forest-model.rda")
}
@
After the estimation process has converged, the estimated effects of the nonparametric modeled terms
may be visualized by typing
<<fit-forest-model-01-plots, echo=TRUE, eval=FALSE>>=
plot(fm1, term = c("sx(age)", "sx(inclination)",
  "sx(canopy)", "sx(year)", "sx(elevation)"))
@
and are shown in Figure~\ref{fig:forest-no-spatial}.
\begin{figure}[!ht]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<forest-no-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "sx(age)")
@
<<forest-no-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "sx(inclination)")
@
\\[2ex]

<<forest-no-spatial-canopy, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "sx(canopy)")
@
<<forest-no-spatial-year, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "sx(year)")
@
\\[2ex]

<<forest-no-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "sx(elevation)")
@
\caption{\label{fig:forest-no-spatial} Forest damage: Estimates of nonparametric effects including
80\% and 95\% point-wise confidence intervals of the model without the spatial effect.}
\end{figure}
In this example some contradictory results occur. The effect of covariate \code{age} on the
\code{defoliation} seems to decline for both, younger and older trees, which intuitively should be a
monotone increasing effect, this also holds for the effect of \code{elevation}. Moreover, the
extremely wiggly estimate of \code{inclination} is hardly interpretable. Therefore, the authors
extend the model by a spatial effect, which is modeled by a two dimensional geospline term of the
tree locations. The tree $x$- and $y$-coordinates are calculated by the centroid positions of tree
polygons given by the boundary map file, which may be loaded with
<<forest-model-gra-bnd, echo=TRUE, eval=TRUE>>=
data("BeechBnd", package = "R2BayesX")
@
We now fit the  model:
<<fit-forest-model-02, echo=TRUE, eval=FALSE>>=
f <- update(f, ~ . + sx(id, bs = "gs", map = BeechBnd))
fm2 <- bayesx(f, family = "cumlogit",
  method = "REML", data = ForestHealth)
@
Taking a look at model information criteria with
<<summary-forest-model, echo=TRUE, eval=TRUE>>=
BIC(fm1, fm2)
GCV(fm1, fm2)
@
clearly indicates a better fit by modeling the spatial effect of tree locations. The summary
statistics for both models gives:
<<summary-forest-model>>=
summary(fm1)
summary(fm2)
@
Most of the parametric modeled terms in the second model now have an insignificant effect on tree
defoliation, with similar findings for covariates \code{inclination} and \code{elevation}. However,
the estimate of the \code{age} effect seems to be improved in terms of monotonicity, see
Figure~\ref{fig:forest-spatial-nonpara}.
\begin{figure}[!ht]
\setkeys{Gin}{width=0.46\textwidth}
\centering
<<forest-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "sx(inclination)")
@
<<forest-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "sx(elevation)")
@
\\[2ex]

<<forest-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "sx(age)")
@
\caption{\label{fig:forest-spatial-nonpara} Forest damage: Estimated effects of covariates
\code{inclination}, \code{elevation} and \code{age}, including 80\% and 95\% point-wise confidence
intervals, of the model including the spatial effect.}
\end{figure}

A kernel density plot of the estimated spatial effect is then obtained by 
<<forest-spatial-id, echo=TRUE, eval=FALSE>>=
plot(fm2, term = "sx(id)", map = FALSE)
@
\begin{figure}[!ht]
\setkeys{Gin}{width=0.65\textwidth}
\centering
\setkeys{Gin}{width=0.46\textwidth}
<<forest-spatial-id-restrict-kde, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.4, 1.1))
plot(fm2, term = "sx(id)", map = FALSE, main = "")
@ 
\\[2ex]

\setkeys{Gin}{width=0.65\textwidth}
\centering
<<forest-spatial-id, echo=FALSE, fig=TRUE, width=7.3, height=4.5>>=
par(mar = c(0.1, 0.1, 0.1, 0.1))
range <- c(-1 * max(abs(range)), max(abs(range)))
plot(fm2, term = "sx(id)", map = BeechBnd,
  height = 0.24, width = 0.41)
@
\caption{\label{fig:forest-spatial-kde} Forest damage: Kernel density estimate of the spatial 
  effect, upper panel, together with a map effect plot, lower panel respectively.}
\end{figure}
The effect may also be visualized either using a 3d perspective plot, an image/contour plot or a map 
effect plot using the boundary file \code{BeechBnd} with
<<forest-spatial-id, echo=TRUE, eval=FALSE>>=
plot(fm2, term = "sx(id)", map = BeechBnd)
@
Both the kernel density and map effect plot are shown in Figure~\ref{fig:forest-spatial-kde}. In 
this example the coloring of the plot is strongly influenced by a few very high and low values. 
Therefore, it might be useful to restrict the color range e.g.\ according to the 10\% and 90\% 
quantiles of the kernel density estimate of the effect, e.g.\ by typing
<<forest-spatial-id-restrict, echo=TRUE, eval=FALSE>>=
plot(fm2, term = "sx(id)", map = BeechBnd, range = c(-3, 3))
@
the resulting map is shown in Figure~\ref{fig:forest-spatial-restrict}.
\begin{figure}[!ht]
\setkeys{Gin}{width=0.65\textwidth}
\centering
<<forest-spatial-id-restrict, echo=FALSE, fig=TRUE, width=7.3, height=4.5>>=
par(mar = c(0.1, 0.1, 0.1, 0.1))
range <- R2BayesX:::kde.quantiles(fitted(fm2, term = "sx(id)")$Estimate)
range <- c(-3, 3)
range <- c(-1 * max(abs(range)), max(abs(range)))
plot(fm2, term = "sx(id)", map = BeechBnd,
  height = 0.24, width = 0.41, range = range)
@ %$
\caption{\label{fig:forest-spatial-restrict} Forest damage: Estimate of the spatial effect with
color scaling based on the 5\% and 95\% quantiles of the kernel density estimate of the effect.}
\end{figure}
Trimming the color range of the plot now leads to a better representation of the effect.

Summarizing these results identify a strong influence of the spatial effect of the overall model
fit, indicating that a clear splitting of locational specific covariates and the spatial effect is
hardly possible in this example.

\subsection{Childhood malnutrition in Zambia: Analysis with STEP} \label{subsec:zambia-step}

To illustrate the implemented methodology for simultaneous selection of variables and smoothing
parameters, we proceed with the dataset on malnutrition in Zambia of
Section~\ref{subsec:zambia}. In this example, the structured additive
predictor~(\ref{eqn:zambia-eta}) contains two continuous covariates \code{mbmi} and \code{agechild},
that are assumed to have a possibly nonlinear effect on the response \code{stunting} and are modeled
with P-splines. However, a linear effect could be more appropriate and, hence, the linear effect is
also considered using the selection algorithm in \pkg{BayesX}. Additionally, for each variable and
function, the implemented procedures decide if a term is included or removed from the model. To
estimate the model applying the option \code{method = "STEP"}, we use the same  model formula of
Section~\ref{subsec:zambia} and call
<<fit-zambia-model-step-01, echo=TRUE, eval=FALSE>>=
f <- stunting ~ memployment + urban + gender +
  sx(meducation, bs = "factor") + sx(mbmi) + sx(agechild) +
  sx(district, bs = "mrf", map = ZambiaBnd) + r(district)
zms <- bayesx(f, family = "gaussian", method = "STEP",
  algorithm = "cdescent1", startmodel = "empty",
  seed = 123, data = ZambiaNutrition)
@
<<fit-zambia-model-step-02, echo=FALSE, eval=FALSE>>=
zmsccb <- bayesx(f, family = "gaussian", method = "STEP",
  algorithm = "cdescent1", startmodel = "empty",
  CI = "MCMCselect", iterations = 10000, step = 10,
  seed = 123, data = ZambiaNutrition)
@
<<cache-zambia-model-step, echo=FALSE, eval=TRUE>>=
if(file.exists("zambia-model-step.rda")) {
load("zambia-model-step.rda")
} else {
data("ZambiaNutrition", "ZambiaBnd", package = "R2BayesX")
<<fit-zambia-model-step-01>>
<<fit-zambia-model-step-02>>
save(zms, zmsccb, file = "zambia-model-step.rda")
}
@
where argument \code{algorithm} chooses the selection algorithm and \code{startmodel} the start
model for variable selection, see also Table ~\ref{tab:control} for all possible options. The
summary statistics of the final selected model are then provided with
<<zambia-model-step-summary, echo=TRUE, eval=TRUE>>=
summary(zms)
@
Note that variable \code{memployment} was removed from the model and variable \code{mbmi} is modeled
by a linear effect. Moreover, the columns \code{sd}, \code{2.5\%}, \code{50\%} and \code{97.5\%}
contain no values, likewise for the estimated  random and smooth effects. The posterior quantiles
may be computed if argument \code{CI} in function \fct{bayesx.control} is specified. E.g.\
conditional confidence bands can be calculated conditional on the selected model, i.e.\ they are
computed for selected variables and functions only. The computation of conditional confidence bands
is based on an MCMC-algorithm subsequent to the selection procedure.  For the selection of a model
with an subsequent computation of conditional confidence bands the user may type
<<fit-zambia-model-step-04, echo=TRUE, eval=FALSE>>=
zmsccb <- bayesx(f, family = "gaussian", method = "STEP",
  algorithm = "cdescent1", startmodel = "empty",
  CI = "MCMCselect", iterations = 10000, step = 10,
  seed = 123, data = ZambiaNutrition)
@
which results in the following summary
<<zambia-model-step-summary-2, echo=TRUE, eval=TRUE>>=
summary(zmsccb)
@
It is also possible to obtain unconditional confidence bands by setting \code{CI = "MCMCbootstrap"},
which additionally considers the uncertainty due to model selection.

% \section{Summary}\label{sec:conclusion}


\section*{Acknowledgments}


\nocite{R2BayesX:Kneib+Heinzl+Brezger:2011}
\bibliography{R2BayesX}


\clearpage


\begin{appendix}


\section[Details on installing BayesX]{Details on installing \pkg{BayesX}} \label{appendix:minstall}

\subsection[Windows binary]{Windows binary} \label{appendix:wininstall}
The installation routine \code{BayesX\_windows.exe} (url:
\url{http://www.stat.uni-muenchen.de/~bayesx/install/BayesX_windows.exe}) may be downloaded from the
\pkg{BayesX} homepage and executed. The routine will request all necessary information during the
installation process. It is recommended to install \pkg{BayesX} in a directory without spaces in the
path name. This will install a pre-compiled computing kernel including a Java graphical interface,
which automatically installs the necessary command-line version of \pkg{BayesX} for use within the
\proglang{R} interface. The binary is named \code{bayesx.exe} and is stored in the
\code{commandline} directory of the \pkg{BayesX} installation folder.

\subsection[From source]{From source} \label{appendix:otherinstall}
The zip archive named \code{bayesxsource.zip} (url:
\url{http://www.stat.uni-muenchen.de/~bayesx/install/bayesxsource.zip}), containing the
\proglang{C++} source code of \pkg{BayesX}, needs to be downloaded and unpacked. If the make
facility is available, one can simply type make \pkg{BayesX} in the shell and \pkg{BayesX} will be
compiled. Depending on the operating system, some minor modifications of the make file (for example
relating to the version of the installed GNU compiler or the location of the readline library) may
be necessary. For MAC OS, versions of an adjusted makefile and the main function that have been used
for a sucessful compilation may be found at the FAQ site
(\url{http://www.stat.uni-muenchen.de/~bayesx/bayesxfaq.html}).
\end{appendix}

\subsection[Editing R's profile startup site]{Editing R's profile startup site}
\label{appendix:linking}
To permanently link to the \pkg{BayesX} command line binary, \proglang{R}'s startup profile site may 
be edited. See the manual for \proglang{R}'s startup mechanism with
<<appendix-startup, echo=TRUE, eval=FALSE>>=
help("Startup")
@
to find out how to edit the startup site on specific systems that is processed at the beginning of a
new \proglang{R} session. Then, by adding the line
\begin{Sinput}
options(bayesx.bin = "path/to/BayesX")
\end{Sinput}
to the startup site will tell \proglang{R} where to find the binary permanently. The string
\code{"path/to/BayesX"} is the full path to the \pkg{BayesX} binary with the name of the binary at 
last. On Windows systems the binary name is \code{"bayesx.exe"}, on all other systems usually
\code{"BayesX"}. Hence, for Windows platforms \code{bayesx.bin} may be specified e.g.\ with
\begin{Sinput}
options(bayesx.bin = "C:/BayesX/commandline/bayesx.exe")
\end{Sinput}
depending on the installation location of the binary.

Furthermore, another possibility is to add the installation directory of the binary to the
environment PATH variable of the operating system. Both options will automatically link the binary
with \proglang{R} for the upcoming sessions.


\subsection[Most important arguments used within function plot.bayesx()]{Most important arguments
  used within function \fct{plot.bayesx}}
\label{appendix:plotting}
\begin{table}[b!]
\centering
\begin{tabular}{|p{2.5cm}p{10cm}|}
\hline
Argument & Description \\ \hline
\code{term} & the term that should be plotted, either an integer or a character, e.g.\
              \code{term = "sx(x)"}. \\
\code{which} & choose the type of plot that should be drawn, possible options are: \code{"effect"},
    \code{"coef-samples"}, \code{"var-samples"}, \code{"intcpt-samples"}, \code{"hist-resid"}, 
    \code{"qq-resid"}, \code{"scatter-resid"}, \code{"scale-resid"}, \code{"max-acf"}. Argument 
    \code{which} may also be specified as integer, e.g.\ \code{which = 1}. The first three arguments 
    are all model term specific. For the residual model diagnostic plot options \code{which} 
    may be set with \code{which = 5:8}. \\ \hline
\code{residuals} & if set to \code{TRUE}, partial residuals may also be plotted if available. \\
\code{rug} & if set to \code{TRUE}, a \fct{rug} is added to the plot. \\
\code{jitter} & if set to \code{TRUE}, a \fct{jitter}ed \fct{rug} is added to the plot. \\ \hline
\code{col.surface} & the color of the surface, may also be a function, e.g.\
    \code{col.surface = heat.colors}. \\
\code{grid} & the grid size of the surface(s). \\
\code{image} & if set to \code{TRUE}, an \fct{image.plot} is drawn. \\
\code{contour} & if set to \code{TRUE}, a \fct{contour} plot is drawn. \\ \hline
\code{map} & the map to be plotted, the map object must be a list of matrices with first column
          indicating the $x$-coordinate and second column the $y$-coordinate each, see also
          function \fct{polygon}. \\
\code{legend} & if set to \code{TRUE}, a legend will be shown. \\
\code{range} & specify the range of values the plot should be generated for, e.g.\ only values
           between -2 and 2 are of interest then \code{range = c(-2, 2)}. \\ \hline
\code{color} & the colors for the legend, may also be a function, e.g.\
           \code{colors = heat.colors}. \\
\code{pos} & the position of the legend, either a numeric vector, e.g.\ \code{pos = c(0.1, 0.2)}
          will add the legend at the 10\% point in the $x$-direction and at the 20\% point in the
          $y$-direction of the plotting window, may also be negative, or one of the following:
          \code{"bottomleft"}, \code{"topleft"}, \code{"topright"} or \code{"bottomright"}. Using
          function \fct{plotmap} option \code{"right"} is also valid. \\
\code{lrange} & specifies the range of the legend. \\
\code{symmetric} & if set to \code{TRUE}, a symmetric legend will be drawn corresponding to the
          $+- max(|x|)$ of values $x$ that are used for plotting. \\ \hline
\end{tabular}
\caption{\label{tab:plotting} Most important plotting parameters using the generic function 
\fct{plot.bayesx}. The first block describes arguments of \fct{plot.bayesx}, subsequent blocks
arguments that are passed to function \fct{plot2d}, \fct{plot3d}, \fct{plotmap} and
\fct{colorlegend} respectively.}
\end{table}


\end{document}
