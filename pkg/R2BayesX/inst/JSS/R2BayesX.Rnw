\documentclass[article]{jss}
%\documentclass[nojss]{jss}
\usepackage{amsmath,amssymb,amsfonts,thumbpdf}

%% additional commands
\newcommand{\squote}[1]{`{#1}'}
\newcommand{\dquote}[1]{``{#1}''}
\newcommand{\fct}[1]{{\texttt{#1()}\index{#1@\texttt{#1()}}}}
\newcommand{\class}[1]{\dquote{\texttt{#1}}}
%% for internal use
\newcommand{\fixme}[1]{\emph{\marginpar{FIXME} (#1)}}
\newcommand{\readme}[1]{\emph{\marginpar{README} (#1)}}

\author{Nikolaus Umlauf\\Universit\"at Innsbruck \And
        Thomas Kneib\\Universit\"at Oldenburg \And
        Stefan Lang\\Universit\"at Innsbruck \And        
        Achim Zeileis\\Universit\"at Innsbruck}
\Plainauthor{Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis}

\title{Structured Additive Regression Models: An \proglang{R} Interface to BayesX}
\Plaintitle{Structured Additive Regression Models: An R Interface to BayesX}

\Keywords{STAR models, MCMC, REML, stepwise, \proglang{R}}
\Plainkeywords{STAR models, MCMC, REML, stepwise, R}

%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

\Abstract{
  Structured additive regression models (STAR) provide a flexible framework for modeling possible 
  nonlinear effects of covariates: They contain the well established frameworks of generalized 
  linear models (GLM) and generalized additive models (GAM) as special cases but also allow a wider 
  class of effects, e.g., for geographical or spatio-temporal data. This allows for the 
  specification of complex and realistic models that can typically be conveniently estimated using 
  Bayesian inference based on modern Markov chain Monte Carlo (MCMC) simulation techniques or a 
  mixed model representation. 
  Besides the quite extensive existing toolset in \proglang{R} supporting GLMs and GAMs, another 
  standalone software package called BayesX, based on open-source \proglang{C++}, developed to a 
  very comprehensive regression toolbox over last few years, especially for those models from the 
  STAR class utilizing Bayesian inference, wherefore availability in \proglang{R} is currently 
  difficult.
%
%  Although there is already a quite extensive existing toolset in 
%  \proglang{R} supporting GLMs and GAMs, many of the more complex models from the STAR class, 
%  especially those utilizing Bayesian inference, are currently not easily available. They are, 
%  however, provided in BayesX, a very comprehensive semiparametric regression toolbox based on 
%  open-source \proglang{C++}, which not only covers models for responses from univariate exponential 
%  families, but also models from non-standard regression situations such as models for categorical 
%  responses with either ordered or unordered categories, continuous time survival data, or 
%  continuous time multi-state models. 
%  
  Since there has been increasing interest in an \proglang{R} interface to BayesX, the already 
  existing CRAN package \pkg{BayesX}, which previously provided mainly functions for exploring 
  estimation results, is now extended to a full interactive interface. With the new version of the 
  package, STAR models can be conveniently specified using \proglang{R}'s formula language (with 
  some extended terms), fitted using the BayesX binary, represented in \proglang{R} with objects of 
  suitable classes, and finally printed/summarized/plotted.
}

\Address{
  Nikolaus Umlauf, Stefan Lang, Achim Zeileis\\
  Department of Statistics\\
  Universit\"at Innsbruck\\
  Universit\"atsstr.~15\\
  A-6020 Innsbruck, Austria\\
  E-mail: \email{Nikolaus.Umlauf@uibk.ac.at},\\
  \phantom{E-mail: }\email{Stefan.Lang@uibk.ac.at},\\
  \phantom{E-mail: }\email{Achim.Zeileis@R-project.org}\\
  URL: \url{http://www.uibk.ac.at/statistics/personal/umlauf/},\\
  \phantom{URL: }\url{http://www.uibk.ac.at/statistics/personal/lang/},\\
  \phantom{URL: }\url{http://eeecon.uibk.ac.at/~zeileis/}\\
  
  Thomas Kneib\\
  Department of Mathematics\\
  Universit\"at Oldenburg\\
  D-26111 Oldenburg, Germany \\
  E-mail: \email{Thomas.Kneib@uni-oldenburg.de}\\
  URL: \url{http://www.staff.uni-oldenburg.de/thomas.kneib/}
}

%% Sweave/vignette information and metadata
%% need no \usepackage{Sweave}
\SweaveOpts{engine = R, eps = FALSE, keep.source = TRUE}
%\VignetteIndexEntry{Structured Additive Regression Models: An R Interface to BayesX}
%\VignetteDepends{colorspace,mgcv,BayesX,akima}
%\VignetteKeywords{STAR models, MCMC, REML, stepwise, R}
%\VignettePackage{R2BayesX}

<<preliminaries, echo=FALSE, results=hide>>=
options(width = 70, prompt = "R> ", continue = "+  ")
library("R2BayesX")
data("ZambiaBnd")
data("BeechBnd")
@


\begin{document}


\section{Introduction} \label{sec:intro}

The public domain software BayesX \citep{Brezger+Kneib+Lang:2005} is a standalone program which 
comprises powerful tools for Bayesian and mixed model based inference for complex semiparametric 
regression models. To gain improved estimation runtime performance of the supported models, the 
algorithms implemented utilize efficient (sparse) matrix computations and are written in a 
\proglang{C++} environment. The idea to embed BayesX in \proglang{R} \citep{R}, and therefore make 
the project available to \proglang{R}'s permanently growing community, has been in mind for quite a 
while. However, since the development status of the software package is already very advanced, and 
there has been more and more recent interest of an \proglang{R} version of BayesX, the compromise of 
creating an interface, compared to a full code portation, was seen advantageous, not only because of 
a faster development time, but also offering already familiar users a toolset, that even, beside the 
possibility to formulate STAR models directly on the console, easily allows to use existing code and 
model output, within \proglang{R}. 

Therefore, the implementation is structured in a few independent operating functions that basically 
collect and configure the necessary model components at first, send these to the BayesX binary for 
processing, read the returned output files back into \proglang{R} by conversion to objects of 
suitable classes, which may then be printed, summarized and visualized. All interface functions have 
been added to the CRAN package \pkg{BayesX} \citep{Kneib+Heinzl+Brezger:2011}, which previously 
provided mainly functions for exploring estimation results.

Designing an user friendly setup requires a comfortable translation method of \proglang{R} specific 
syntax to BayesX interpretable commands. For this reason, the package layout is orientated and 
dependent on the recommended CRAN package \pkg{mgcv} \citep{Wood:2011}, amongst others, since 
\pkg{mgcv} already features functionality, which easily allows to set up new model terms within 
\proglang{R}'s formula language, and secondly, the package covers a number of the model terms 
implemented in BayesX. This means, some of the model formulas specified within the \pkg{mgcv} main 
model fitting-function \fct{gam}, may also be used in \pkg{BayesX} and vice versa. Hence, users 
primarily familiar with \pkg{mgcv} and its GAM formula definition may use the interface with little 
additional effort, only. This is illustrated in the following, where some data is simulated and 
models are estimated with \fct{gam}, using generalized cross validation (GCV) for optimization, and 
the \pkg{BayesX} interface primary model-fitting function \fct{bayesx} applying MCMC: 
<<fit-illustration-model, echo=TRUE, eval=FALSE, fig=FALSE>>=
## simulate some data
set.seed(0) 
dat <- gamSim(1, n = 400, dist = "normal", scale = 2)

## model formula
mf <- y ~ s(x0, bs = "ps") + s(x1, bs = "ps") + 
  s(x2, bs = "ps") + s(x3, bs = "ps")

## estimate models with
## mgcv GCV and BayesX MCMC
b1 <- gam(mf, method = "GCV.Cp", data = dat)
b2 <- bayesx(mf, method = "MCMC", data = dat)

## plot estimated effects
plot(b1)
plot(b2)
@
<<cache-illustration-model, echo=FALSE, eval=TRUE, fig=FALSE>>=
if(file.exists("illustration-model.rda")) {
load("illustration-model.rda")
} else {
<<fit-illustration-model>>
save(b1, b2, file = "illustration-model.rda")
}
@
\begin{figure}[t!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<plot-illustration-model-BayesX, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b1, select = 3, ylim = c(-6.9, 6), 
  shade = TRUE)
@
<<plot-illustration-model-mgcv, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b2, term = "s(x2)", ylim = c(-6.9, 6),
  c.select = c("x", "Mean", "2.5%", "97.5%"), 
  fill.select = c(0, 0, 1, 1))
@
\end{center}
\caption{\label{fig:illustration} Illustration example: comparison of estimated effects for 
covariate \code{x2}, black lines, together with 95\% credible intervals shaded in gray, of the 
package \pkg{mgcv} model-fitting function \fct{gam} using GCV, left panel, and the \pkg{BayesX} 
model-fitting function \fct{bayesx} applying MCMC, right panel respectively.}
\end{figure}
Several standard base \proglang{R} extractor functions and methods, e.g. \fct{plot} and 
\fct{summary}, also, with similar behavior as in \pkg{mgcv}, are available for the returned 
fitted-model object \code{b2}. Here, a comparison plot of the estimated effect for covariate 
\code{x2} of the two models is shown in figure~\ref{fig:illustration}. Consequently, estimating 
models with more complex term structures, e.g. applying stationary Gaussian random fields, is 
managed by function \fct{s}, which facilitates a consistent way of smooth terms specifications in 
GAM and STAR formulas. In addition, BayesX supports non-standard regression situations such as 
models for categorical responses with either ordered or unordered categories, continuous time 
survival data, or continuous time multi-state models, also, which may be adopted in the same manner. 

To present the extensive capability of the software in more detail, the next section briefly 
discusses the methodological background of regression models with a structured additive predictor, 
before a description of the implementation is provided in section~\ref{sec:implementation}. In 
section~\ref{sec:illustrations}, the interface usability is further demonstrated on a complex 
example with data concerning childhood malnutrition in Zambia as well as on a dataset on forest 
health.


\section{STAR models} \label{sec:model} 

The STAR model class supported by \pkg{BayesX} is based on the framework of (Bayesian) generalized 
linear models (GLM) \citep{Nelder+Wedderburn:1972, Fahrmeir+Tutz:2001}. GLMs assume that, given 
covariates $\mathbf{x}$ and unknown parameters $\gamma$, the distribution of the response variable 
$y$ belongs to an exponential family with mean $\mu = E(y | \mathbf{x}, \boldsymbol{\gamma})$ linked 
to a linear predictor $\eta$ by
\begin{equation} \label{eqn:glm}
\mu = h(\eta) \qquad \eta = \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation}
where $h$ is a known link function and $\boldsymbol{\gamma}$ are unknown regression parameters. For 
STAR models, the linear predictor is replaced by a more general and flexible, so called structured 
additive predictor
\begin{equation} \label{eqn:structadd}
\eta = f_1(z_1) + \ldots + f_p(z_p) + \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation}
where covariates $z_j$, $j = 1,\ldots,p$, are of generic type and dimension, and $f_j$ are possibly 
smooth functions comprising effects (and combination of effects) as e.g. given by             
\begin{itemize}
\item nonlinear effects of continuous covariate $x$: $f_j(z_j) = f(x)$,
\item two-dimensional surfaces: $f_j(z_j) = f(x_1,x_2)$,
\item spatially correlated effects: $f_j(z_j) = f_{spat}(s)$, 
\item varying coefficients: $f_j(z_j) = x_1f(x_2)$, 
\item spatially varying effects: $f_j(z_j) = x_1f_{spat}(s)$ or $f_j(z_j) = x_1f(x_2, x_3)$, 
\item random intercepts with cluster index $c$: $f_j(z_j) = b_c$, 
\item random slopes with cluster index $c$: $f_j(z_j) = x \, b_c$. 
\end{itemize}
Therefore, STAR models cover a number of well known model classes as special cases, including
generalized additive models (GAM) \citep{Hastie+Tibshirani:1990}, generalized additive mixed models
(GAMM) \citep{Lin+Zhang:1999}, geoadditive models \citep{Kamman+Wand:2003}, varying coefficient 
models \citep{Hastie+Tibshirani:1993}, and geographically weighted regression 
\citep{Fotheringham+Brunsdon+Charlton:2002}.

The unified representation of a STAR predictor arises from the fact that all functions $f_j$ in 
(\ref{eqn:structadd}) may be specified by a basis function approach, where the vector of function  
evaluations $\mathbf{f}_j = (f_j(z_{1j}),\ldots,f_j(z_{nj}))$, with $i = 1,\ldots,n$ observations, 
can be written in matrix notation 
\begin{equation} \label{eqn:matnot}
\mathbf{f}_j = \mathbf{Z}_j\boldsymbol{\beta}_j,
\end{equation}
with $\mathbf{Z}_j$ as a design matrix, that only depends on the prior assumptions about smoothness 
of $f_j$, and $\boldsymbol{\beta}_j$ are unknown regression coefficients which have to be estimated. 
Hence, the predictor of (\ref{eqn:structadd}) may be rewritten by
\begin{equation} \label{eqn:structaddmat}
\boldsymbol{\eta} = \mathbf{Z}_1\boldsymbol{\beta}_1 + \ldots \mathbf{Z}_p\boldsymbol{\beta}_p 
+ \mathbf{X}\boldsymbol{\gamma},
\end{equation}
where $\mathbf{X}$ corresponds to the usual design matrix for the fixed effects.

In BayesX, estimation of regression parameters is based on two inferential concepts, Markov chain 
Monte Carlo simulation techniques corresponding to full Bayesian inference \citep{Brezger+Lang:2006}
and mixed model methodology corresponding to penalized likelihood or empirical Bayes inference
\citep{Fahrmeir+Kneib+Lang:2004}. As a third alternative BayesX provides a penalized least squares
(respectively penalized likelihood) approach for estimating structured additive regression tools. In
addition, a powerful variable and model selection tool is included. Model choice and estimation of
the parameters is done simultaneously \citep{Belitz+Lang:2008}.

For all inferential concepts, the prior for the functions $f_j$ depends on the design matrix 
$\mathbf{Z}_j$, as e.g. determined by the functional types described above, and a prior for the 
vector $\boldsymbol{\beta}_j$, which may also be written in a general form given by
\begin{equation} \label{eqn:prior}
p(\boldsymbol{\beta}_j | \tau_j^2) \propto exp \left(- \frac{1}{2\tau_j^2} 
\boldsymbol{\beta_j}^{\prime}\mathbf{K}_j\boldsymbol{\beta}_j\right),
\end{equation}
with $\mathbf{K}_j$ as a quadratic penalty matrix that shrinks parameters towards zero or penalizes 
too abrupt jumps between neighboring parameters. In most cases $K_j$ will be rank deficient and the 
prior for $\boldsymbol{\beta}_j$ is partially improper.

The variance parameter $\tau_j^2$ is equivalent to the inverse smoothing parameter in a frequentist
approach and controls the trade off between flexibility and smoothness. For full Bayesian inference,
weakly informative inverse Gamma hyperpriors $\tau_j^2 \sim IG(a_j, b_j)$ are assigned to 
$\tau_j^2$, with $a_j = b_j = 0.001$ as a standard option. For empirical Bayes inference, $\tau_j^2$ 
is considered an unknown constant which is determined as a restricted maximum likelihood estimate 
(REML).

A thorough (and for most practical purposes sufficient) introduction into the regression models 
supported by the program is provided in the BayesX methodology manual 
\citep{Belitz+Brezger+Kneib+Lang:2011}.


\section[Implementation in R]{Implementation in \proglang{R}} \label{sec:implementation}

Before STAR models can be fitted with \pkg{BayesX}, the binary command line version of the 
program needs to be installed. This may be accomplished differently and system specific: one 
opportunity is to download the \proglang{C++} source-code from 
\begin{center}
\url{http://www.stat.uni-muenchen.de/~bayesx}, 
\end{center}
and compile the sources with the GNU \proglang{C++} compiler, besides on Windows operating systems, 
a pre-compiled computing kernel including a Java graphical interface may be installed, which 
automatically installs the command line version of BayesX, also. Another, and the recommended option 
on UNIX and Windows systems is to install the binary within \proglang{R} by calling the function 
\fct{install.bayesx}, which basically executes the described above. For all other platforms and 
possible problems, please see the help sites on the BayesX web-page. Installing BayesX from 
\proglang{R} then ideally requires only e.g. running
<<install-bayesx, echo=TRUE, eval=FALSE>>=
install.bayesx(inst.dir = NULL, source.dir = NULL)
@
if the computer is connected to the internet and the user holds writing permissions for the 
\pkg{BayesX} package library folders, otherwise a valid installation directory must be supplied (in 
the majority of cases) as well as the source-code directory, if the source-code is already stored 
locally and does not need to be downloaded. After the successful installation, the full path to the 
command line binary must be set either within \proglang{R} directly, using e.g.
<<install-bayesx, echo=TRUE, eval=FALSE>>=
options(bayesx.bin = "/path/to/BayesX")
@
where \code{"/path/to/BayesX"} on Windows systems may be specified e.g. with \\
\code{"C:/BayesX/commandline/bayesx.exe"}, or adding the installation directory of the binary to the 
environment PATH variable is sufficient. Afterwards, the function call
<<install-bayesx, echo=TRUE, eval=FALSE>>=
check.install.bayesx()
@
will check if BayesX may be called from \proglang{R}. 
 
The main model-fitting function in \pkg{BayesX} is called \fct{bayesx}, which is basically a 
collection of functions described in table~\ref{tab:bayesxfun}, that are executed one after 
another, and may also be used independently. 
\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Function                 & Description \\ \hline
\fct{parse.bayesx.input} & parses \fct{bayesx} input parameters to be send to 
                           \fct{write.bayesx.input}. \\ \hline
\fct{write.bayesx.input} & takes an object from \fct{parse.bayesx.input} and translates the input to 
                           an executable program and, if necessary, a data file, which may be 
                           processed with BayesX. \\ \hline
\fct{run.bayesx}         & runs BayesX program files from \proglang{R}. \\ \hline
\fct{read.bayesx.output} & automatically reads in BayesX estimation output stored in a declared 
                           output directory by transforming objects to suitable classes, which may 
                           be printed, summarized and plotted. \\ \hline
\end{tabular}
\caption{\label{tab:bayesxfun} Main functions of the interface.}
\end{center}
\end{table}
The arguments of \fct{bayesx} are
\begin{Sinput}
bayesx(formula, data, weights = NULL, subset = NULL, 
  offset = NULL, na.action = na.fail, contrasts = NULL, 
  control = bayesx.control(...), ...)
\end{Sinput}
and mostly represent the standard model frame specifications \citep[see][]{Chambers+Hastie:1992}. 
The last argument specifies several parameters controlling the processing of the BayesX binary which 
are arranged by function \fct{bayesx.control}, e.g. the choice between the inferential 
concepts, set within argument \code{method}, which are currently Markov chain Monte Carlo simulation 
techniques - \code{"MCMC"}, mixed model based estimation - \code{"REML"} and penalized least squares 
including model selection - \code{"STEP"}, or the distribution assigned to the response, set with 
argument \code{family}. An overview of all available distributions is given in 
table~\ref{tab:familiy}.
\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{4cm}|p{2.5cm}|l|}
\hline
\code{family} & Response distribution & Link & \code{method} \\ \hline
\code{"gaussian"} & Gaussian & identity & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"gamma"} & gamma & log & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"binomial"} & binomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"binomialprobit"} & binomial & probit  & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"multinomial"} & unordered multinomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ 
  \hline
\code{"poisson"} & Poisson & log-link & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"cumprobit"} & cumulative threshold & probit & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"cox"} & continuous-time survival data & -  & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"multistate"} & continuous-time multi-state data & - & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"multinomialprobit"} & unordered multinomial & probit & \code{"MCMC"} \\ \hline
\code{"nbinomial"} & negative binomial & log-link & \code{"MCMC"} \\ \hline
\code{"zip"} & zero inflation & log-link & \code{"MCMC"} \\ \hline
\code{"binomialcomploglog"} & binomial & complementary log-log & \code{"REML"} \\ \hline
\code{"cumlogit"} & cumulative multinomial & logit & \code{"REML"} \\ \hline
\code{"seqlogit"} & sequential multinomial & logit & \code{"REML"} \\ \hline
\code{"seqprobit"} & sequential multinomial & probit & \code{"REML"}  \\ \hline
\code{"multinomialcatsp"} & unordered multinomial (with category-specific covariates) & logit & 
  \code{"REML"} \\ \hline
\end{tabular}
\caption{\label{tab:familiy} Distributions implemented for the different inferential concepts within 
the \pkg{BayesX} package.}
\end{center}
\end{table}

As mentioned in the introduction, package \pkg{BayesX} utilizes function \fct{s} from the \pkg{mgcv} 
package to build the additive components of a STAR predictor within \proglang{R}'s formula language.
In addition, unit- or cluster specific unstructured effects may be incorporated into the 
\code{formula} using the random effects term constructor function \fct{r}. Then, a typical STAR 
predictor with some response \code{y}, covariate \code{x1} with a possibly nonlinear effect modeled 
by a P-spline, covariate \code{id} representing some cluster index modeled as random effect and 
covariate \code{x2} entering linearly, is e.g. formulated by
\begin{Sinput}
y ~ s(x1, bs = "ps") + r(id) + x2
\end{Sinput} 
where argument \code{bs} of function \fct{s} specifies the smooth bases, the type of term that 
should enter the \code{formula}. A list of the implemented model terms in \pkg{BayesX} is provided 
in table~\ref{tab:terms}.
\begin{table}[htbp]
\begin{center}
\begin{tabular}{|p{2cm}|p{10cm}|}
\hline
\code{bs} & Description \\ \hline
\code{"lasso"} \code{"nigmix"} \code{"ridge"} & shrinkage of fixed effects: defines a 
                                                shrinkage-prior for the corresponding parameters 
                                                $\gamma_j$, $j = 1, \ldots, q$, $q \geq 1$ of the 
                                                linear effects $x_1, \ldots, x_q$. There are three 
                                                priors possible: ridge-, lasso- and Normal Mixture 
                                                of inverse Gamma (NMIG)-prior. \\ \hline
\code{"bl"} & nonlinear baseline effect in hazard regression or multi-state models: defines a 
              P-spline with second order random walk penalty for the parameters of the spline for 
              the log-baseline effect $log(\lambda(time))$. \\ \hline
\code{"kr"} & kriging with stationary Gaussian random fields. \\ \hline
\code{"gk"} & geokriging with stationary Gaussian random fields:  estimates a stationary Gaussian 
              random field based on the centroids of a map object\\ \hline
\code{"gs"} & geosplines based on two-dimensional P-splines with first order random walk penalty: 
              defines a two-dimensional P-spline for the spatial covariate region with a 
              two-dimensional first order random walk penalty for the parameters of the spline. 
              Estimation is based on the coordinates of the centroids of the regions provided by a 
              map object.\\ \hline
\code{"mrf"} & Markov random fields: defines a Markov random field prior for a spatial covariate, 
               where geographical informations are provided by a map object .\\ \hline
\code{"ps"} & P-spline with first or second order difference penalty. \\ \hline
\code{"rw1"} \code{"rw2"} & zero degree P-splines: defines a zero degree P-spline with first or 
                            second order difference penalty. A zero degree P-spline typically 
                            estimates for every distinct covariate value in the data set a separate 
                            parameter. Usually there is no reason to prefer zero degree P-splines 
                            over higher order P-splines. An exception are ordinal covariates or 
                            continuous covariates with only a small number of different values. 
                            For ordinal covariates higher order P-splines are not meaningful while 
                            zero degree P-splines might be an alternative to modeling nonlinear 
                            relationships via a dummy approach with completely unrestricted 
                            regression parameters\\ \hline
\code{"season"} & seasonal effect of a time scale. \\ \hline
\code{"te"} & defines a two-dimensional P-spline based on the tensor product of one-dimensional 
              P-splines with a two-dimensional first order random walk penalty for the parameters of 
              the spline. \\ \hline
\code{"generic"} & general purpose model term. \\ \hline
\end{tabular}
\caption{\label{tab:terms} Possible BayesX model terms within function \fct{s}.}
\end{center}
\end{table}
Setting additional arguments for a model term is generally restricted to argument \code{xt} 
within function \fct{s} and \fct{r}, i.e. \code{xt} must be a named \fct{list} including those 
parameters, where all possibilities for each \code{bs} type may be looked up calling function 
\fct{bayesx.term.options}. As an example, using \code{bs = "mrf"} to estimate a spatially correlated
effect with Markov random fields with some location identification covariate \code{id}, requires an 
additional map boundary or graph file for the calculation of a neighborhood-matrix to guarantee  
smooth estimates over adjacent regions, which must be provided within \code{xt}, then 
\begin{Sinput}
s(id, bs = "mrf", xt = list(map = SomeMap)) 
\end{Sinput} 
constructs the setup for this type of model term.

Past the execution of all computations with the BayesX binary, the model output files are written 
into the declared output directory, which per default is the temporary directory of the running
session, and are read back into \proglang{R} using function \fct{read.bayesx.output}. The returned 
fitted-model object is a list of class \code{"bayesx"}, wherefore a set of standard extractor 
functions, such as \fct{summary}, \fct{fitted}, \fct{plot} and more, 
listed in table~\ref{tab:funmethods}, is available. 

The quite flexible \code{S3} class function \fct{plot.bayesx}, called from the generic \fct{plot}, 
is practical generating model diagnostic plots, term effects plots, applying 2d, 3d, image and map
graphics, as well as sampling paths of coefficients and variances for MCMC estimated models, e.g.
\setkeys{Gin}{width=0.49\textwidth}
<<plot-illustration-model-samples-01, echo=TRUE, eval=FALSE, fig=FALSE, width=5, height=4>>=
plot(b2, term = "s(x0)", which = "coef-samples")
@
\begin{figure}[t!]
\setkeys{Gin}{width=0.6\textwidth}
\begin{center}
<<plot-illustration-model-samples-02, echo=FALSE, fig=TRUE, width=7, height=7>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b2, term = "s(x2)", which = "coef-samples", main = "")
@
\end{center}
\caption{\label{fig:illustration-samples} Illustration example: plots of the sampling paths of the 
coefficients of term \code{s(x2)} in model \code{b2}.}
\end{figure}
produces plots of coefficient sampling paths as shown in figure~\ref{fig:illustration-samples}. 

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Function & Description \\ \hline
\fct{AIC}, \fct{BIC}, \fct{DIC}, \fct{GCV} & compute information criteria, availability is dependent 
                                             on the \code{method} used. \\ \hline
\fct{c} & combines several objects of class \code{"bayesx"}, all functions and methods may be 
          applied on the returned object. \\ \hline
\fct{coef} & extracts coefficients of linear modeled terms, for \code{"MCMC"} estimated models, 
             the samples of the coefficients are provided within the object attribute 
             \code{"sample"}. \\ \hline
\fct{confint} & compute confidence interval of linear modeled terms if \code{method = "REML"}, for
                \code{"MCMC"} the quantiles of the coefficient samples according to a specified 
                level are computed. \\ \hline
\fct{cprob} & extract contour probabilities of a particular P-spline term, only meaningful if 
              \code{method = "MCMC"} and e.g. argument \code{contourprob} is specified within
              argument \code{xt} in function \fct{s}, e.g. 
              \code{s(x, bs = "ps", xt = list(contourprob = 4))}. \\ \hline
\fct{fitted} & fitted values of either the linear predictor, or a select model term. \\ \hline
\fct{logLik} & extract fitted log-likelihood, only if \code{method = "REML"}. \\ \hline
\fct{plot} & either model diagnostic plots or effect plots of particular terms. \\ \hline
\fct{print} & simple printed display of the initial call and some additional information of the
              fitted model. \\ \hline
\fct{residuals} & extract model or partial residuals for a select term. \\ \hline
\fct{summary} & returns an object of class \code{"summary.bayesx"} containing the relevant summary 
                statistics (which has a \fct{print} method). \\ \hline
\fct{terms} & extract terms of model components. \\ \hline
\end{tabular}
\caption{\label{tab:funmethods} Functions and methods for objects of class \code{"bayesx"}.}
\end{center}
\end{table}


\section{STAR models in practice} \label{sec:illustrations}

Section with two examples: Childhood malnutrition in Zambia and the forest health data.


\subsection{Childhood malnutrition in Zambia} \label{subsec:zambia}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Variable           & Description \\ \hline
\code{stunting}    & standardised Z-score for stunting. \\ \hline
\code{bmi}         & body mass index of the mother. \\ \hline
\code{agechild}    & age of the child in months. \\ \hline
\code{district}    & district where the mother lives. \\ \hline
\code{memployment} & mother's employment status with categories `working' and 
                     `not working'. \\ \hline
\code{education}   & mother's educational status with categories for complete primary but incomplete 
                     secondary `no/incomplete', complete secondary or higher `minimum primary' and 
                     no education or incomplete primary `minimum secondary'. \\ \hline
\code{urban}       & locality of the domicile with categories `yes' and `no'. \\ \hline
\code{gender}      & gender of the child with categories `male' and `female'. \\ \hline
\end{tabular}
\caption{\label{tab:zambia} Variables in the data set on childhood malnutrition in Zambia.}
\end{center}
\end{table}

<<fit-zambia-model, echo=TRUE, eval=FALSE>>=
data("ZambiaNutrition", package = "R2BayesX")
data("ZambiaBnd")
zm <- bayesx(stunting ~ memployment + education + urban + gender + 
  s(bmi, bs = "ps") + s(agechild, bs = "ps") +
  s(district, bs = "mrf", xt = list(map = ZambiaBnd)) + r(district),
  iter = 12000, burnin = 2000, step = 10, seed = 123,
  data = ZambiaNutrition)
@

<<cache-zambia-model, echo=FALSE, eval=TRUE>>=
if(file.exists("zambia-model.rda")) {
load("zambia-model.rda")
} else {
<<fit-zambia-model>>
save(zm, file = "zambia-model.rda")
}
@

<<summary-zambia-model>>=
summary(zm)
@

\begin{figure}[t!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<zambia-agechild, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "s(agechild)")
@
<<zambia-bmi, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "s(bmi)")
@
\end{center}
\caption{\label{fig:zambia-agechild} Example on childhood undernutrition: Effect of the body 
mass index of the child's mother and of the age of the child together with pointwise 80\% and 95\% 
credible intervals.}
\end{figure}

\begin{figure}[t!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<zambia-district-structured, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(zm, term = "s(district)", map = ZambiaBnd, 
  pos = "topleft", width = 0.6, height = 0.2, 
  distance.labels = 2, swap = TRUE)
@
<<zambia-district-unstructured, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(zm, term = "r(district)", map = ZambiaBnd, 
  pos = "topleft", width = 0.6, height = 0.2, 
  distance.labels = 2L, swap = TRUE, 
  density = 20, angle = 90)
@
\end{center}
\caption{\label{fig:zambia-district-structured} Example on childhood malnutrition: Structured, 
left panel, and unstructured spatial effect, right panel respectively.}
\end{figure}


\subsection{Forest health data set} \label{subsec:forest}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Variable           & Description \\ \hline
\code{id}          & tree location identification number. \\ \hline
\code{year}        & year of census. \\ \hline
\code{defoliation} & percentage of tree defoliation in three ordinal
                     categories, 0 == `defoliation < 12.5\%', 1 == `12.5\% $\leq$
                     defoliation < 50\%' and 3 == `defoliation $\geq$ 50\%'. \\ \hline
\code{x}           & x-coordinate of the tree location. \\ \hline
\code{y}           & y-coordinate of the tree location. \\ \hline
\code{age}         & age of stands in years. \\ \hline
\code{canopy}      & forest canopy density in percent. \\ \hline
\code{inclination} & slope inclination in percent. \\ \hline
\code{elevation}   & elevation (meters above sea level). \\ \hline
\code{soil}        & soil layer depth in cm. \\ \hline
\code{ph}          & soil pH at 0-2cm depth. \\ \hline
\code{moisture}    & soil moisture level with categories 1 == `moderately
                     dry', 2 == `moderately moist' and 3 == `moist or temporarily
                     wet'. \\ \hline
\code{alkali}      & proportion of base alkali-ions with categories 1 == `low' 
                     to 4 == `high'. \\ \hline
\code{humus}       & humus layer thickness in cm. \\ \hline
\code{stand}       & stand type with categories `deciduous' and `mixed'. \\ \hline
\code{fertilized}  & fertilization applied with categories `yes' and `no'. \\ \hline
\end{tabular}
\caption{\label{tab:forest} Variables in the forest health data set.}
\end{center}
\end{table}

<<fit-forest-model, echo=TRUE, eval=FALSE>>=
data("ForestHealth", package = "R2BayesX")
data("BeechBnd")
data("BeechGra")
fm1 <- bayesx(defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22),
  family = "cumlogit", method = "REML", data = ForestHealth)
fm2 <- bayesx(defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22) + 
  s(id, bs = "mrf", xt = list(map = BeechGra)),
  family = "cumlogit", method = "REML", data = ForestHealth)
@

<<cache-forest-model, echo=FALSE, eval=TRUE>>=
if(file.exists("forest-model.rda")) {
load("forest-model.rda")
} else {
<<fit-forest-model>>
save(fm1, fm2, file = "forest-model.rda")
}
@

<<summary-forest-model>>=
summary(c(fm1, fm2))
@

\begin{figure}[t!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<forest-no-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(age)")
@
<<forest-no-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(inclination)")
@ 
\\[2ex]

<<forest-no-spatial-canopy, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(canopy)")
@
<<forest-no-spatial-year, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(year)")
@ 
\\[2ex]

<<forest-no-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(elevation)")
@
\end{center}
\caption{\label{fig:forest-no-spatial} Forest damage: estimates of nonparametric effects including
80\% and 95\% point-wise confidence intervals of the model without the spatial effect.}
\end{figure}

\begin{figure}[t!]
\setkeys{Gin}{width=0.49\textwidth}
\begin{center}
<<forest-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(age)")
@
<<forest-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(inclination)")
@
\\[2ex]

<<forest-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(elevation)")
@
\end{center}
\caption{\label{fig:forest-spatial-nonpara} Forest damage: estimates of particular nonparametric 
effects including 80\% and 95\% point-wise confidence intervals of the model including the spatial 
effect.}
\end{figure}

\begin{figure}[t!]
\setkeys{Gin}{width=0.7\textwidth}
\begin{center}
<<forest-spatial-id, echo=FALSE, fig=TRUE, width=7, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(fm2, term = "s(id)", map = BeechBnd, 
  pos = "topleft", width = 0.4, height = 0.2, 
  distance.labels = 2)
@
\end{center}
\caption{\label{fig:forest-spatial} Forest damage: estimate of the spatial effect.}
\end{figure}

\section{Summary}\label{sec:conclusion}


\section*{Acknowledgments}

\nocite{Kneib+Heinzl+Brezger:2011}
\bibliography{R2BayesX}


\end{document}
