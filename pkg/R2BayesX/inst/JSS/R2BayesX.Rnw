\documentclass[article]{jss}
%\documentclass[nojss]{jss}
\usepackage{amsmath,amssymb,amsfonts,thumbpdf}

%% additional commands
\newcommand{\squote}[1]{`{#1}'}
\newcommand{\dquote}[1]{``{#1}''}
\newcommand{\fct}[1]{{\texttt{#1()}\index{#1@\texttt{#1()}}}}
\newcommand{\class}[1]{\dquote{\texttt{#1}}}
%% for internal use
\newcommand{\fixme}[1]{\emph{\marginpar{FIXME} (#1)}}
\newcommand{\readme}[1]{\emph{\marginpar{README} (#1)}}

\author{Nikolaus Umlauf\\Universit\"at Innsbruck \And
        Thomas Kneib\\Universit\"at Oldenburg \And
        Stefan Lang\\Universit\"at Innsbruck \And        
        Achim Zeileis\\Universit\"at Innsbruck}
\Plainauthor{Nikolaus Umlauf, Thomas Kneib, Stefan Lang, Achim Zeileis}

\title{Structured Additive Regression Models: An \proglang{R} Interface to BayesX}
\Plaintitle{Structured Additive Regression Models: An R Interface to BayesX}

\Keywords{STAR models, MCMC, REML, stepwise, \proglang{R}}
\Plainkeywords{STAR models, MCMC, REML, stepwise, R}

%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

\Abstract{
Structured additive regression (STAR) models provide a flexible framework for modeling possible 
nonlinear effects of covariates: They contain the well established frameworks of generalized linear 
models (GLM) and generalized additive models (GAM) as special cases but also allow a wider class of 
effects, e.g., for geographical or spatio-temporal data. This allows for the specification of 
complex and realistic models that can typically be conveniently estimated using Bayesian inference 
based on modern Markov chain Monte Carlo (MCMC) simulation techniques or a mixed model 
representation. Although there is already a quite extensive existing toolset in \proglang{R} 
supporting GLMs and GAMs, many of the more complex models from the STAR class, especially those 
utilizing Bayesian inference, are currently not easily available. They are, however, provided in the 
standalone software package BayesX: a very comprehensive simulation based regression toolbox
written in open-source \proglang{C++} code. BayesX not only covers models for responses from 
univariate exponential families, but also models from non-standard regression situations such as 
models for categorical responses with either ordered or unordered categories, continuous time 
survival data, or continuous time multi-state models. Since there has been increasing interest in an 
\proglang{R} interface to BayesX, the already existing CRAN package \pkg{BayesX}, which previously 
provided only functions for exploring estimation results, is now extended to a full interactive
interface. With the new version of the package, STAR models can be conveniently specified using 
\proglang{R}'s formula language (with some extended terms), fitted using the BayesX binary, 
represented in \proglang{R} with objects of suitable classes, and finally 
printed/summarized/plotted.
}

\Address{
  Nikolaus Umlauf, Stefan Lang, Achim Zeileis\\
  Department of Statistics\\
  Universit\"at Innsbruck\\
  Universit\"atsstr.~15\\
  A-6020 Innsbruck, Austria\\
  E-mail: \email{Nikolaus.Umlauf@uibk.ac.at},\\
  \phantom{E-mail: }\email{Stefan.Lang@uibk.ac.at},\\
  \phantom{E-mail: }\email{Achim.Zeileis@R-project.org}\\
  URL: \url{http://www.uibk.ac.at/statistics/personal/umlauf/},\\
  \phantom{URL: }\url{http://www.uibk.ac.at/statistics/personal/lang/},\\
  \phantom{URL: }\url{http://eeecon.uibk.ac.at/~zeileis/}\\
  
  Thomas Kneib\\
  Department of Mathematics\\
  Universit\"at Oldenburg\\
  D-26111 Oldenburg, Germany \\
  E-mail: \email{Thomas.Kneib@uni-oldenburg.de}\\
  URL: \url{http://www.staff.uni-oldenburg.de/thomas.kneib/}
}

%% Sweave/vignette information and metadata
%% need no \usepackage{Sweave}
\SweaveOpts{engine = R, eps = FALSE, keep.source = TRUE}
%\VignetteIndexEntry{Structured Additive Regression Models: An R Interface to BayesX}
%\VignetteDepends{colorspace,mgcv,BayesX,akima}
%\VignetteKeywords{STAR models, MCMC, REML, stepwise, R}
%\VignettePackage{R2BayesX}

<<preliminaries, echo=FALSE, results=hide>>=
options(width = 70, prompt = "R> ", continue = "+  ")
library("R2BayesX")
data("ZambiaBnd")
data("BeechBnd")
@


\begin{document}


\section{Introduction} \label{sec:intro}

The public domain software BayesX \citep{Brezger+Kneib+Lang:2005} is a standalone program comprising 
powerful tools for Bayesian and mixed model based inference in complex semiparametric regression 
models with structured additive predictor (STAR) (see Section~\ref{sec:model}). To gain improved 
computational performance of the supported models, the algorithms implemented utilize numerically 
efficient (sparse) matrix architectures and are written in a \proglang{C++} environment. 

In this article, we describe the full interactive \proglang{R} \citep{R} interface to BayesX, which
has recently been added to the existing Comprehensive \proglang{R} Archive Network (CRAN) package 
\pkg{BayesX} \citep{Kneib+Heinzl+Brezger:2011}. Within the new functionality of the package, users 
may now 
\begin{itemize}
\item specify and estimate STAR models with BayesX directly from the \proglang{R} console, 
\item apply a set of extractor functions and methods on BayesX fitted-model objects, e.g. producing 
  high level graphics of estimated effects, model diagnostic plots, summary statistics and more,
\item additionally run already existing BayesX program files from \proglang{R},
\item as well as automatically import BayesX output files into \proglang{R}.
\end{itemize}

Furthermore, the models supported by BayesX are conveniently specified using \proglang{R}'s formula 
language definition, wherefore the special model term constructor functions \fct{s} 
\citep{Wood:2011} and \fct{r} facilitate a consistent way to translate \proglang{R} syntax into 
BayesX interpretable commands (see Section~\ref{sec:implementation}). 

To give an introductory example of the various features of the interface, we estimate a Bayesian 
normal geoadditive regression model with the childhood malnutrition dataset in Zambia
(see Section~\ref{subsec:zambia}) using Markov chain Monte Carlo (MCMC) simulation. The 
model is given by
\begin{equation*}
\texttt{stunting}_i = \gamma_0 + f_1(\texttt{agechild}_i) + f_2(\texttt{bmi}_i) + 
  f_{spat}(\texttt{district}_i) + \varepsilon_i \qquad \varepsilon_i \sim N(0, \sigma^2)
\end{equation*} 
where functions $f_1$ and $f_2$ are possibly nonlinear and $f_{spat}$ represents a spatially 
correlated effect. Therefore, the data together with a boundary map file of the districts in Zambia 
is loaded with    
<<data-illustration, echo=TRUE, eval=TRUE, fig=FALSE>>=
data("ZambiaNutrition", "ZambiaBnd", package = "R2BayesX")
@
and the model formula specified by
<<formula-illustration, echo=TRUE, eval=TRUE, fig=FALSE>>=
mf <- stunting ~ s(agechild, bs = "ps") + s(bmi, bs = "ps") + 
  s(district, bs = "gs", xt = list(map = ZambiaBnd))
@
Here, the possibly nonlinear effects of covariates \code{agechild} and \code{bmi} on \code{stunting}
are modeled with P-splines and the spatial effect by a geospline term using the centroid $x$- and 
$y$-coordinates of the district polygons in object \code{ZambiaBnd}. The model is then fitted with 
the function call 
<<fit-illustration, echo=TRUE, eval=FALSE, fig=FALSE>>=
b <- bayesx(mf, family = "gaussian", method = "MCMC", 
  data = ZambiaNutrition)
@
<<cache-illustration, echo=FALSE, eval=TRUE>>=
if(file.exists("illustration-model.rda")) {
load("illustration-model.rda")
} else {
<<fit-illustration>>
save(b, file = "illustration-model.rda")
}
@
After BayesX successfully finished processing several base \proglang{R} functions and methods, such 
as \fct{summary}, \fct{plot}, \fct{fitted} and more, may be applied on the fitted-model object 
\code{b}. In Figure~\ref{fig:illustration}, some visualization examples of the estimated effects 
produced by the versatile implemented plotting functions are shown.
\begin{figure}[t!]
\setkeys{Gin}{width=0.46\textwidth}
\begin{center}
<<plot-illustration-bmi, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b, term = "s(bmi)")
@ 
<<plot-illustration-agechild, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b, term = "s(agechild)", resid = TRUE, cex = 0.1, rug = FALSE)
@ 
\\[2ex]
\setkeys{Gin}{width=0.47\textwidth}
\hspace*{0.3cm}
<<plot-illustration-district-image, echo=FALSE, fig=TRUE, width=5.3, height=4>>=
par(mar = c(4.1, 4, 0.1, 1.8))
plot(b, term = "s(district)", image = T, grid = 100, at = c(-0.4, 0, 0.4),
  image.map = ZambiaBnd, outscale = 0.1, linear = FALSE, extrap = TRUE,
  zlim = c(-1, 1), range = c(-0.5, 0.5), lrange = c(-0.6, 0.6), swap = TRUE)
@
\setkeys{Gin}{width=0.46\textwidth}
<<plot-illustration-district-persp, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 1.1, 0, 0))
plot(b, term = "s(district)", range = c(-0.5, 0.5), lrange = c(-0.6, 0.6), 
  zlim = c(-1.1, 1.1), swap = TRUE, theta = 40, extrap = TRUE, linear = FALSE, 
  ticktype = "detailed", zlab = "\ns(x,y)", xlab = "\nx", ylab = "\ny")
@
\end{center}
\caption{\label{fig:illustration} Visualization examples: Estimated effect for covariate \code{bmi}, 
black line, together with 95\% and 80\% credible intervals shaded in dark gray and light gray 
respectively, upper left panel. The upper right panel shows the estimated effect of \code{agechild} 
including partial residuals. The lower left panel illustrates visualization of the estimated spatial 
effect for covariate \code{district} using an image plot with a map of the districts in Zambia 
together with a color legend, the lower right panel draws the same effect with a perspective plot in 
a slightly rotated angle.}
\end{figure}

Besides exponential family regression, BayesX also supports non-standard regression situations such 
as regression for categorical responses, hazard regression for continuous survival times, and 
continuous time multi-state models, which may be adopted in the same manner.

To present the extensive capabilities of the software in more detail, the next section briefly 
discusses the methodological background of regression models with a structured additive predictor, 
before a description of the implementation is given in Section~\ref{sec:implementation}. In 
Section~\ref{sec:illustrations}, the interface usability is further illustrated with the childhood 
malnutrition data of Zambia as well as on a dataset on forest health from Germany.


\section{STAR models} \label{sec:model} 

The STAR model class supported by \pkg{BayesX} is based on the framework of (Bayesian) generalized 
linear models (GLM) (e.g. see \citet{Nelder+Wedderburn:1972} and \citet{Fahrmeir+Tutz:2001}). GLMs 
assume that, given covariates $\mathbf{x}$ and unknown parameters $\boldsymbol{\gamma}$, the 
distribution of the response variable $y$ belongs to an exponential family with mean 
$\mu = E(y | \mathbf{x}, \boldsymbol{\gamma})$ linked to a linear predictor $\eta$ by
\begin{equation} \label{eqn:glm}
\mu = h(\eta) \qquad \eta = \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation}
where $h$ is a known link function and $\boldsymbol{\gamma}$ are unknown regression parameters. For 
STAR models \citep{Fahrmeir+Kneib+Lang:2004, Brezger+Lang:2006}, the linear predictor is replaced 
by a more general and flexible, structured additive predictor
\begin{equation} \label{eqn:structadd}
\eta = f_1(z) + \ldots + f_p(z) + \mathbf{x}^{\prime}\boldsymbol{\gamma},
\end{equation}
where covariates $z$ are of generic type and dimension, and $f_j$ are possibly smooth functions 
comprising effects (and combination of effects) as e.g. given by             
\begin{itemize}
  \item nonlinear effects of continuous covariates: $f_j(z) = f(x)$,
  \item two-dimensional surfaces: $f_j(z) = f(x_1,x_2)$,
  \item spatially correlated effects: $f_j(z) = f_{spat}(s)$, 
  \item varying coefficients: $f_j(z) = x_1f(x_2)$, 
  \item spatially varying effects: $f_j(z) = x_1f_{spat}(s)$ or $f_j(z) = x_1f(x_2, x_3)$, 
  \item random intercepts with cluster index $c$: $f_j(z) = b_c$, 
  \item random slopes with cluster index $c$: $f_j(z) = x \, b_c$. 
\end{itemize}
Therefore, STAR models cover a number of well known model classes as special cases, including
generalized additive models (GAM) \citep{Hastie+Tibshirani:1990}, generalized additive mixed models
(GAMM) \citep{Lin+Zhang:1999}, geoadditive models \citep{Kamman+Wand:2003}, varying coefficient 
models \citep{Hastie+Tibshirani:1993}, and geographically weighted regression 
\citep{Fotheringham+Brunsdon+Charlton:2002}.

The unified representation of a STAR predictor arises from the fact that all functions $f_j$ in 
(\ref{eqn:structadd}) may be specified by a basis function approach, where the vector of function  
evaluations $\mathbf{f}_j = (f_j(z_{1}),\ldots,f_j(z_{n}))$, with $i = 1,\ldots,n$, observations, 
can be written in matrix notation 
\begin{equation} \label{eqn:matnot}
\mathbf{f}_j = \mathbf{Z}_j\boldsymbol{\beta}_j,
\end{equation}
with $\mathbf{Z}_j$ as a design matrix, that depends on the prior assumptions about smoothness of 
$f_j$. $\boldsymbol{\beta}_j$ are unknown regression coefficients which have to be estimated. 
Hence, the predictor of (\ref{eqn:structadd}) may be rewritten by
\begin{equation} \label{eqn:structaddmat}
\boldsymbol{\eta} = \mathbf{Z}_1\boldsymbol{\beta}_1 + \ldots \mathbf{Z}_p\boldsymbol{\beta}_p 
+ \mathbf{X}\boldsymbol{\gamma},
\end{equation}
where $\mathbf{X}$ corresponds to the usual design matrix for the fixed effects.

A prior for a function $f_j$ is now defined by specifying a suitable design matrix $\mathbf{Z}_j$ 
and a prior distribution for the vector $\boldsymbol{\beta}_j$ of unknown parameters. The general 
form of the prior for $\boldsymbol{\beta}_j$ is
\begin{equation} \label{eqn:prior}
p(\boldsymbol{\beta}_j | \tau_j^2) \propto exp \left(- \frac{1}{2\tau_j^2} 
\boldsymbol{\beta_j}^{\prime}\mathbf{K}_j\boldsymbol{\beta}_j\right),
\end{equation}
with $\mathbf{K}_j$ as a quadratic penalty matrix that shrinks parameters towards zero or penalizes 
too abrupt jumps between neighboring parameters. In most cases $K_j$ will be rank deficient and the 
prior for $\boldsymbol{\beta}_j$ is partially improper.

The variance parameter $\tau_j^2$ is equivalent to the inverse smoothing parameter in a frequentist
approach and controls the trade off between flexibility and smoothness. For full Bayesian inference,
weakly informative inverse Gamma hyperpriors $\tau_j^2 \sim IG(a_j, b_j)$ are assigned to 
$\tau_j^2$, with $a_j = b_j = 0.001$ as a standard option. For empirical Bayes inference, $\tau_j^2$ 
is considered an unknown constant which is determined as a restricted maximum likelihood estimate 
(REML).

In BayesX, estimation of regression parameters is based on two inferential concepts: A fully 
Bayesian interpretation of structured additive regression models is obtained by specifying prior 
distributions for all unknown parameters. Estimation can be facilitated using Markov chain Monte 
Carlo simulation techniques, a general and versatile concept for Bayesian inference. BayesX provides 
numerically efficient implementations of MCMC schemes for structured additive regression models. 
Suitable proposal densities have been developed to obtain rapidly mixing, well-behaved sampling 
schemes without the need for manual tuning. 

The other concept used for estimation is based on mixed model methodology.
Within BayesX this concept has been extended to structured additive regression models and several 
types of non-standard regression situations. The general idea is to take advantage of the close 
connection between penalty concepts and corresponding random effects distributions. The smoothing 
parameters of the penalties then transform to variance components in the random effects (mixed) 
model. While the selection of smoothing parameters has been a difficult task for a long time, 
several estimation procedures for variance components in mixed models are already available since
the 1970's. The most popular one is restricted maximum likelihood in Gaussian mixed models with 
marginal likelihood as the non-Gaussian counterpart. While regression coefficients are estimated 
based on penalized likelihood, restricted maximum likelihood or marginal likelihood estimation forms 
the basis for the determination of smoothing parameters. From a Bayesian perspective, this yields 
empirical Bayes/posterior mode estimates for the structured additive regression models. However, 
estimates can also merely be interpreted as penalized likelihood estimates from a frequentist 
perspective.

As a third alternative BayesX provides a penalized least squares (respectively penalized likelihood) 
approach for estimating structured additive regression tools. In addition, a powerful variable and 
model selection tool is included. Model choice and estimation of the parameters is done 
simultaneously \citep{Belitz+Lang:2008}. The algorithms are able to
\begin{itemize}
  \item decide whether a particular covariate enters the model,
  \item decide whether a continuous covariate enters the model linearly or nonlinearly,
  \item decide whether a spatial effect enters the model,
  \item decide whether a unit- or cluster specific heterogeneity effect enters the model
  \item select complex interaction effects (two dimensional surfaces, varying coefficient terms)
  \item select the degree of smoothness of nonlinear covariate, spatial or cluster specific
    heterogeneity effects.
\end{itemize}
Inference is based on penalized likelihood in combination with fast algorithms for selecting 
relevant covariates and model terms. Different models are compared via various goodness of fit 
criteria, e.g. AIC, BIC, GCV and 5 or 10 fold cross validation. 
%\citep{Sakamoto+Ishiguro+Kitagawa:1986}

A thorough (and for most practical purposes sufficient) introduction into the regression models 
supported by the program is provided in the BayesX methodology manual 
\citep{Belitz+Brezger+Kneib+Lang:2011}.


\section[Implementation in R]{Implementation in \proglang{R}} \label{sec:implementation}

\subsection[Installing BayesX from R]{Installing BayesX from \proglang{R}} 

Before STAR models can be fitted with \pkg{BayesX}, the binary command line version of the 
program needs to be installed and linked to \proglang{R}. The installation may be accomplished 
differently and system specific: One possibility is to install BayesX "by hand", which is described 
in the Appendix~\ref{sec:installation}. However, the recommended option on UNIX and Windows systems 
is to auto - compile/install the BayesX command line binary within \proglang{R} by calling the 
function \fct{install.bayesx}. Therefore package \pkg{BayesX} needs to be loaded.
<<load-bayesx, echo=TRUE, eval=FALSE>>=
library("BayesX")
@
Installing BayesX from \proglang{R} then ideally only requires running
<<install-bayesx, echo=TRUE, eval=FALSE>>=
install.bayesx(inst.dir = "path/to/installation/directory", 
  source.dir = NULL)
@
where argument \code{inst.dir} must be a path to a valid directory with user writing permissions. 
If \code{source.dir = NULL}, the necessary installation files will automatically tried to be 
downloaded from the BayesX homepage, otherwise \code{source.dir} specifies the path where 
\fct{install.bayesx} may either find the packed sources 
\href{http://www.stat.uni-muenchen.de/~bayesx/install/bayesxsource.zip}{\code{bayesxsource.zip}},
or using Windows, the installer
\href{http://www.stat.uni-muenchen.de/~bayesx/install/BayesX_windows.exe}{BayesX\_windows.exe}. If 
the corresponding file is available, \fct{install.bayesx} will then attempt to execute the Windows 
installation process as described in Subsection~\ref{subsec:wininstall}, or to compile the sources 
as shown in Subsection~\ref{subsec:otherinstall}, respectively.


\subsection[Linking the BayesX binary with R]{Linking the BayesX binary with \proglang{R}} 
\label{subsec:linking}
After the successful compilation/installation, the full path to the 
command line binary \textbf{must} be declared at the beginning of every new \proglang{R} session by 
setting
<<options-bayesx, echo=TRUE, eval=FALSE>>=
options(bayesx.bin = "/path/to/BayesX")
@
where \code{"/path/to/BayesX"} is e.g. the path provided to argument \code{inst.dir} of function
\fct{install.bayesx}, with the name of the BayesX binary at last. On Windows platforms the name of 
the binary is \code{bayesx.exe}, on all other platforms usually \code{BayesX}. Hence, on Windows 
systems the user may specify e.g.
<<options-bayesx-windows, echo=TRUE, eval=FALSE>>=
options(bayesx.bin = "C:/BayesX/commandline/bayesx.exe") 
@
However, it is suggested to add the code above in the \proglang{R} startup profile site once. In 
the majority of cases this site is called \code{Rprofile.site} and is stored in the \code{etc} 
directory of the running \proglang{R} installation. The path to this directory with its files may be 
instantly looked up typing
<<Rhome-directory, echo=TRUE, eval=TRUE>>=
(etc.dir <- R.home(component = "etc"))
list.files(etc.dir)
@
Another possibility is to add the installation directory of the binary to the environment PATH 
variable of the operating system. Both options will automatically link the binary with \proglang{R} 
for the upcoming sessions. Afterwards, the function call
<<check-install-bayesx, echo=TRUE, eval=FALSE>>=
check.install.bayesx()
@
will check if BayesX may be called from \proglang{R}. 


\subsection[Processing BayesX from R]{Processing BayesX from \proglang{R}} 
\label{subsec:interface}
 
The main model-fitting function in package \pkg{BayesX} is called \fct{bayesx}. The arguments of 
\fct{bayesx} are
\begin{Sinput}
bayesx(formula, data, weights = NULL, subset = NULL, 
  offset = NULL, na.action = na.fail, contrasts = NULL, 
  control = bayesx.control(...), ...)
\end{Sinput}
and mostly represent the standard model frame specifications \citep[see][]{Chambers+Hastie:1992}. 
The last argument specifies several parameters controlling the processing of the BayesX binary that 
are arranged by function \fct{bayesx.control}. E.g. the choice of the inferential concept, set 
within argument \code{method}. Options currently are: Markov chain Monte Carlo simulation - 
\code{"MCMC"}, mixed model based estimation using restricted maximum likelihood/marginal likelihood 
- \code{"REML"} and penalized likelihood including model selection - \code{"STEP"}. Moreover, the 
distribution assigned to the response may be set with argument \code{family}. The default is 
\code{family = "gaussian"}. An overview of all available distributions for the different methods is 
given in table~\ref{tab:familiy}.
\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|p{4cm}|p{2.5cm}|l|}
\hline
\code{family} & Response distribution & Link & \code{method} \\ \hline
\code{"gaussian"} & Gaussian & identity & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"gamma"} & gamma & log & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"binomial"} & binomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"binomialprobit"} & binomial & probit  & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"multinomial"} & unordered multinomial & logit & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ 
  \hline
\code{"poisson"} & Poisson & log-link & \code{"MCMC"} \code{"REML"} \code{"STEP"} \\ \hline
\code{"cumprobit"} & cumulative threshold & probit & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"cox"} & continuous-time survival data & -  & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"multistate"} & continuous-time multi-state data & - & \code{"MCMC"} \code{"REML"} \\ \hline
\code{"multinomialprobit"} & unordered multinomial & probit & \code{"MCMC"} \\ \hline
\code{"nbinomial"} & negative binomial & log-link & \code{"MCMC"} \\ \hline
\code{"zip"} & zero inflation & log-link & \code{"MCMC"} \\ \hline
\code{"binomialcomploglog"} & binomial & complementary log-log & \code{"REML"} \\ \hline
\code{"cumlogit"} & cumulative multinomial & logit & \code{"REML"} \\ \hline
\code{"seqlogit"} & sequential multinomial & logit & \code{"REML"} \\ \hline
\code{"seqprobit"} & sequential multinomial & probit & \code{"REML"}  \\ \hline
\code{"multinomialcatsp"} & unordered multinomial (with category-specific covariates) & logit & 
  \code{"REML"} \\ \hline
\end{tabular}
\caption{\label{tab:familiy} Distributions implemented for \code{method}s \code{"MCMC"}, 
\code{"REML"} and \code{"STEP"} within the \pkg{BayesX} package.}
\end{center}
\end{table}
The returned fitted-model object is a list of class \code{"bayesx"}, which is supported by several 
functions and methods, such as \fct{plot} or \fct{summary}, shown in 
Subsection~\ref{subsec:extract}. 

For most practical purposes fitting models with \fct{bayesx} may be sufficient. However, the 
interfacing functions, that are basically called within \fct{bayesx}, may also be used 
independently. This may be meaningful for two reason: First, users may want to use already existing 
BayesX program files wherefore a new setup within \proglang{R} is not required, and secondly, there
might be a need for automated importing of BayesX output files into \proglang{R} for further 
analysis. Therefore, users may call function \fct{run.bayesx}, with arguments
\begin{Sinput}
run.bayesx(dir, prg.name = "bayesx.estim.input.prg", 
  verbose = FALSE, bin = getOption("bayesx.bin"))
\end{Sinput}
to run a BayesX program file from a specified directory. Then, model output files may be imported 
using function \fct{read.bayesx.output}:
\begin{Sinput}
read.bayesx.output(dir, model.name = NULL)
\end{Sinput}
Furthermore, the function will search for all different BayesX estimated models in the declared 
directory \code{dir} if argument \code{model.name} is set to \code{NULL}. The returned object is 
also of class \code{"bayesx"}, i.e. all the functions described in Subsection~\ref{subsec:extract} 
may be applied.
  

\subsection[Available additive terms]{Available additive terms} 
\label{subsec:addterms}

As mentioned in the introduction, package \pkg{BayesX} utilizes function \fct{s} from the \pkg{mgcv} 
package to build the additive components of a STAR predictor within \proglang{R}'s formula language.
The usage of function \fct{s} in \pkg{BayesX} is in principle similar to package \pkg{mgcv}. 
However, only a reduced list of arguments and options may be used using the interface. The used 
arguments are
\begin{Sinput}
s(..., k = -1, bs = "ps", m = NA, by = NA, xt = NULL)
\end{Sinput}
Within \fct{s}, the covariates used for the model term are set with argument \code{...}. \code{k}
controls the dimension of the basis used for smooth terms. Within argument \code{bs}, the basis
for the term is chosen, possible options are shown in Table~\ref{tab:terms}. Argument \code{m} is
only meaningful if \code{bs = "ps"}, which sets the degree of the B-spline basis and the order of 
the penalty, e.g. may be set to \code{m = c(3, 2)}.

In addition, unit- or cluster specific unstructured effects may be incorporated into the model
\code{formula} using the random effects term constructor function \fct{r}.

Then, a typical STAR formula with some response \code{y}, covariate \code{x1} with a possibly 
nonlinear effect modeled by a P-spline, covariate \code{id} representing some cluster index modeled 
as random effect and covariate \code{x2} entering linearly, is e.g. formulated by
\begin{Sinput}
y ~ s(x1, bs = "ps") + r(id) + x2
\end{Sinput} 
where argument \code{bs} of function \fct{s} specifies the smooth bases, the type of term that 
should enter the \code{formula}. A list of the implemented model terms in \pkg{BayesX} is provided 
in table~\ref{tab:terms}.
Setting additional arguments for a model term is generally restricted to argument \code{xt} 
within function \fct{s} and \fct{r}, i.e. \code{xt} must be a named \fct{list} including these 
parameters, where all possibilities for each \code{bs} type may be looked up calling function 
\fct{bayesx.term.options}. As an example, using \code{bs = "mrf"} to estimate a spatially correlated
effect with Markov random fields with some location identification covariate \code{id}, requires an 
additional map boundary (\fct{read.bnd}) or graph file (\fct{read.gra}) for the calculation of a 
neighborhood-matrix to guarantee smooth estimates over adjacent regions, which must be provided 
within \code{xt}, then 
\begin{Sinput}
s(id, bs = "mrf", xt = list(map = SomeMap)) 
\end{Sinput} 
constructs the setup for this type of model term.


\subsection[Extractor functions and methods]{Extractor functions and methods} \label{subsec:extract}

Past the execution of all computations with the BayesX binary, the model output files are written 
into the declared output directory, which per default is the temporary directory of the running
session, and are read back into \proglang{R} using function \fct{read.bayesx.output}. The returned 
fitted-model object is a list of class \code{"bayesx"}, wherefore a set of standard extractor 
functions and methods, listed in table~\ref{tab:funmethods}, is available. 

The quite flexible \code{S3} class function \fct{plot.bayesx}, usually called from the generic 
\fct{plot}, is handy generating model diagnostic plots, term effects plots, applying 2d, 3d, 
image and map graphics, as well as sampling paths of coefficients and variances for MCMC estimated 
models, e.g.
\setkeys{Gin}{width=0.46\textwidth}
<<plotcall-illustration-model-samples, echo=TRUE, eval=FALSE>>=
plot(b, term = "s(agechild)", which = "coef-samples")
@
\begin{figure}[t!]
\setkeys{Gin}{width=0.6\textwidth}
\begin{center}
<<plot-illustration-model-samples, echo=FALSE, fig=TRUE, width=7, height=7>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(b, term = "s(agechild)", which = "coef-samples", main = "")
@
\end{center}
\caption{\label{fig:illustration-samples} Illustration example: Plots of the sampling paths of the 
coefficients of term \code{s(agechild)} in model \code{b}.}
\end{figure}
produces plots of coefficient sampling paths as shown in Figure~\ref{fig:illustration-samples}. 


\subsection[Large data example]{Large data example} \label{subsec:largedata}

Another noteworthy feature of package \pkg{BayesX} is the internal handling of data. During MCMC
simulation, BayesX only uses different observations of covariates, since the number of unique
observations is typically much smaller than the total number of observations in the dataset. I.e.
this primarily allows for a potential speedup of algorithm run-times, and secondly reduces the risk
of possible storage problems in the computer memory. To exploit this within \proglang{R} using a
large dataset, which might produce difficulties with \proglang{R}'s object memory allocation, the 
user may specify the \code{data} argument in function \fct{bayesx} as the path to a dataset stored 
in the respective directory. As a consequence, this dataset will not be loaded within \proglang{R} 
and is only used internally by the BayesX binary, and as a result, the output files written will 
typically reserve much less disc space and may be imported to \proglang{R} for further analysis. To 
give an example we generate a large dataset and store it on disc in the temporary folder of the 
running session with
<<large-data, echo=TRUE, eval=FALSE>>=
n <- 100000
file <- paste(tempdir(), "/data.raw", sep = "")
write.table(matrix(c("x", "y"), nrow = 1), file = file, 
  quote = FALSE, row.names = FALSE, col.names = FALSE)
for(i in 1:50) {
  dat <- data.frame(x = round(runif(n, -3, 3), 2))
  dat$y <- with(dat, sin(x) + rnorm(n, sd = 2))
  write.table(dat, file = file, append = TRUE, 
    quote = FALSE, row.names = FALSE, col.names = FALSE)
}
@ 
This produces a dataset of approximately 110Mb with only 601 unique observations for covariate 
\code{x}. The path to the dataset is stored in object \code{file}, which may then provided to the 
function call
<<large-data-01, echo=TRUE, eval=FALSE>>=
b <- bayesx(y ~ s(x, bs = "ps"), data = file, 
  iter = 3000, burnin = 500, step = 2, predict = FALSE)
@ 
to start BayesX. For illustration purposes, the number of iterations is only set to 3000. Argument 
\code{predict} is set to \code{FALSE}, i.e. only output files of estimated effects will be returned, 
otherwise an expanded dataset would be written in the output directory, also containing the data 
used for estimation. This example runs about 4 1/2 hours 
\begin{Sinput}
R> bayesx_runtime(b)

     user    system   elapsed 
16686.130     5.812 16703.644 
\end{Sinput}
on a Linux system with an Intel 2.33GHz Dual Core processor, while the returned object \code{b} uses
\begin{Sinput}
R> print(object.size(b), units = "Mb")

0.3 Mb
\end{Sinput}
of memory size.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|p{2cm}|p{10cm}|}
\hline
\code{bs} & Description \\ \hline
\code{"lasso"}, \code{"nigmix"}, \code{"ridge"} & shrinkage of fixed effects: defines a 
                                                shrinkage-prior for the corresponding parameters 
                                                $\gamma_j$, $j = 1, \ldots, q$, $q \geq 1$ of the 
                                                linear effects $x_1, \ldots, x_q$. There are three 
                                                priors possible: ridge-, lasso- and Normal Mixture 
                                                of inverse Gamma (NMIG)-prior. \\ \hline
\code{"bl"} & nonlinear baseline effect in hazard regression or multi-state models: defines a 
              P-spline with second order random walk penalty for the parameters of the spline for 
              the log-baseline effect $log(\lambda(time))$. \\ \hline
\code{"kr"} & kriging with stationary Gaussian random fields. \\ \hline
\code{"gk"} & geokriging with stationary Gaussian random fields: estimates a stationary Gaussian 
              random field based on the centroids of a map object provided in boundary format within
              the \code{xt} argument of function \fct{s}. \\ \hline
\code{"gs"} & geosplines based on two-dimensional P-splines with first order random walk penalty: 
              defines a two-dimensional P-spline for the spatial covariate region with a 
              two-dimensional first order random walk penalty for the parameters of the spline. 
              Estimation is based on the coordinates of the centroids of the regions provided by a 
              map object in in boundary format within the \code{xt} argument of function \fct{s}.\\ 
              \hline
\code{"mrf"} & Markov random fields: defines a Markov random field prior for a spatial covariate, 
               where geographical informations are provided by a map object in boundary or graph 
               file format within the \code{xt} argument of function \fct{s}.\\ \hline
\code{"ps"} & P-spline with first or second order difference penalty. \\ \hline
\code{"rw1"}, \code{"rw2"} & zero degree P-splines: defines a zero degree P-spline with first or 
                            second order difference penalty. A zero degree P-spline typically 
                            estimates for every distinct covariate value in the data set a separate 
                            parameter. Usually there is no reason to prefer zero degree P-splines 
                            over higher order P-splines. An exception are ordinal covariates or 
                            continuous covariates with only a small number of different values. 
                            For ordinal covariates higher order P-splines are not meaningful while 
                            zero degree P-splines might be an alternative to modeling nonlinear 
                            relationships via a dummy approach with completely unrestricted 
                            regression parameters\\ \hline
\code{"season"} & seasonal effect of a time scale. \\ \hline
\code{"te"} & defines a two-dimensional P-spline based on the tensor product of one-dimensional 
              P-splines with a two-dimensional first order random walk penalty for the parameters of 
              the spline. \\ \hline
\code{"generic"} & general purpose model term. \\ \hline
\end{tabular}
\caption{\label{tab:terms} Possible BayesX model terms within function \fct{s}.}
\end{center}
\end{table}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
Function & Description \\ \hline
\fct{AIC}, \fct{BIC}, \fct{DIC}, \fct{GCV} & computes information criteria, availability is dependent 
                                             on the \code{method} used. \\ \hline
\fct{bayesx\_logfile}, \fct{bayesx\_prgfile}, \fct{bayesx\_runtime} & extracts the internal BayesX 
                                             log-file, the program file and the overall runtime of
                                             the binary. \\ \hline
\fct{c} & combines several objects of class \code{"bayesx"}, all functions and methods may be 
          applied on the returned object. \\ \hline
\fct{coef} & extracts coefficients of linear modeled terms, for \code{"MCMC"} estimated models, 
             the samples of the coefficients are provided within the object attribute 
             \code{"sample"}. \\ \hline
\fct{confint} & compute confidence interval of linear modeled terms if \code{method = "REML"}, for
                \code{"MCMC"} the quantiles of the coefficient samples according to a specified 
                level are computed. \\ \hline
\fct{cprob} & extract contour probabilities of a particular P-spline term, only meaningful if 
              \code{method = "MCMC"} and e.g. argument \code{contourprob} is specified within
              argument \code{xt} in function \fct{s}, e.g. 
              \code{s(x, bs = "ps", xt = list(contourprob = 4))}. \\ \hline
\fct{fitted} & fitted values of either the linear predictor, or a select model term. \\ \hline
\fct{logLik} & extract fitted log-likelihood, only if \code{method = "REML"}. \\ \hline
\fct{plot} & either model diagnostic plots or effect plots of particular terms. \\ \hline
\fct{print} & simple printed display of the initial call and some additional information of the
              fitted model. \\ \hline
\fct{residuals} & extract model or partial residuals for a select term. \\ \hline
\fct{summary} & returns an object of class \code{"summary.bayesx"} containing the relevant summary 
                statistics (which has a \fct{print} method). \\ \hline
\fct{terms} & extract terms of model components. \\ \hline
\end{tabular}
\caption{\label{tab:funmethods} Functions and methods for objects of class \code{"bayesx"}.}
\end{center}
\end{table}


\newpage


\section{STAR models in practice} \label{sec:illustrations}

The focus of this section is on demonstrating the various features of the \pkg{BayesX} package, 
therefore, the examples provided are replicate analysis taken from \citet{Brezger+Kneib+Lang:2005} 
and \citet{Fahrmeir+Kneib+Lang:2009}, the \pkg{VGAM} package \citep{Yee:2009} and the \pkg{mgcv} 
package, which ensure straightforward traceability of the code presented, since all datasets may be 
loaded within the discussed CRAN packages. 


\subsection{Childhood malnutrition in Zambia} \label{subsec:zambia}

This analysis has already been conducted by \citet{Kandala+Lang+Klasen+Fahrmeir:2001} and has also 
been used as a demonstrating example in \citet{Brezger+Kneib+Lang:2005}. Stunting is one of the 
leading drivers of a number of problems development countries are faced with, for instance, a direct 
consequence of stunting is a high mortality rate. Here, the primary interest is to model the 
dependence of stunting of newborn children, with an age ranging from 0 to 5 years, on covariates 
such as the body mass index of the mother, the age of the child and others presented in 
table~\ref{tab:zambia}. 
\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Variable           & Description \\ \hline
\code{stunting}    & standardised Z-score for stunting. \\ \hline
\code{bmi}         & body mass index of the mother. \\ \hline
\code{agechild}    & age of the child in months. \\ \hline
\code{district}    & district where the mother lives. \\ \hline
\code{memployment} & mother's employment status with categories `working' and 
                     `not working'. \\ \hline
\code{education}   & mother's educational status with categories for complete primary but incomplete 
                     secondary `no/incomplete', complete secondary or higher `minimum primary' and 
                     no education or incomplete primary `minimum secondary'. \\ \hline
\code{urban}       & locality of the domicile with categories `yes' and `no'. \\ \hline
\code{gender}      & gender of the child with categories `male' and `female'. \\ \hline
\end{tabular}
\caption{\label{tab:zambia} Variables in the data set on childhood malnutrition in Zambia.}
\end{center}
\end{table}
The response \code{stunting} is defined in terms of a reference 
category, i.e in this dataset the stunting for child $i$ is represented by
\begin{equation*}
\texttt{stunting}_i = \frac{\texttt{AI}_i - \texttt{MAI}_i}{\sigma},
\end{equation*}
where \texttt{AI} refers to the child's anthropometric indicator (height at a certain age in our 
example), while \texttt{MAI} and $\sigma$ correspond to the median and the standard deviation in the 
reference population, respectively.

The data for this analysis is provided in the \pkg{BayesX} package and can be loaded with
<<data-zambia, echo=TRUE, eval=TRUE>>=
data("ZambiaNutrition", package = "R2BayesX")
@
For the final model, incorporating a structured spatial effect for the districts in Zambia using a 
Markov random fields term within the \code{formula} specifiaction, BayesX needs some information 
about the district neighborhood structure, which e.g. is enclosed in 
<<data-zambia-bnd, echo=TRUE, eval=TRUE>>=
data("ZambiaBnd", package = "R2BayesX")
@
With the information of the boundary file an appropriate penalty is computed, allowing for a 
smoothly varying effect of neighboring regions. The object \code{ZambiaBnd} has class \code{"bnd"} 
and is basically a \fct{list} of polygon matrices, one matrix for each district, with $x$-, in the 
first, and $y$-coordinates, in the second column respectively, of the boundary points. There is a 
generic plotting method implemented for objects of class \code{"bnd"}, which in principle calls 
function \fct{plotmap}, e.g. a simple map, as shown in Figure~\ref{fig:zambia-simple-map}, of the districts in Zambia is drawn typing
<<plot-zambia-map-01, echo=TRUE, eval=FALSE>>=
plot(ZambiaBnd)
@ 
\begin{figure}[h!]
\setkeys{Gin}{width=0.46\textwidth}
\begin{center}
<<plot-zambia-map-02, echo=FALSE, eval=TRUE, fig = TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(ZambiaBnd)
@ 
\end{center}
\caption{\label{fig:zambia-simple-map} Example on childhood malnutrition: A simple map of the 
districts in Zambia.}
\end{figure}
Having loaded the necessary files, the model \code{formula} is then specified with
<<formula-zambia, echo=TRUE, eval=TRUE>>=
mf <- stunting ~ memployment + education + urban + gender + 
  s(bmi, bs = "ps") + s(agechild, bs = "ps") +
  s(district, bs = "mrf", xt = list(map = ZambiaBnd)) + r(district)
@
where the two continuous covariates \code{bmi} and \code{agechild} are assumed to have a possibly 
nonlinear effect on \code{stunting} and are modeled with P-splines, \code{bs = "ps"}. Furthermore, 
a decomposition of the spatial effect is achieved by specifying a Markov random field term with 
\code{bs = "mrf"} for the structured and a random effects term, using function \fct{r}, for an
unstructured spatial effect. Finally, a gaussian model is fitted using MCMC by calling
<<fit-zambia-model, echo=TRUE, eval=FALSE>>=
zm <- bayesx(mf, method = "MCMC", iter = 12000, 
  burnin = 2000, step = 10, data = ZambiaNutrition, dir.rm = FALSE)
@
<<cache-zambia-model, echo=FALSE, eval=TRUE>>=
if(file.exists("zambia-model.rda")) {
load("zambia-model.rda")
} else {
<<fit-zambia-model>>
save(zm, file = "zambia-model.rda")
}
@
where argument \code{iter}, \code{burnin} and \code{step} set the number of iterations of the MCMC 
simulation, the burnin period, which will be removed from the generated samples, and the step length 
for which samples should be stored, i.e. \code{step = 10} forces saving of only every 10th sampled 
parameter.

After the model has been successfully fitted, the generic call  
<<summary-zambia-model>>=
summary(zm)
@
provides summary statistics of the MCMC fitted-model object, which typically includes mean, standard 
deviation and quantiles of sampled linear effects, smooth terms variances and random effects 
variances, as well as goodness of fit criteria. The estimated effects for covariates 
\code{agechild} and \code{bmi} may be visualized with
<<zambia-agechild-bmi-plot, echo=TRUE, eval=FALSE>>=
plot(zm, term = c("s(agechild)", "s(bmi)"))
@
\begin{figure}[h!]
\setkeys{Gin}{width=0.46\textwidth}
\begin{center}
<<zambia-agechild, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "s(agechild)")
@
<<zambia-bmi, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 1.1))
plot(zm, term = "s(bmi)")
@
\end{center}
\caption{\label{fig:zambia-agechild} Example on childhood undernutrition: Effect of the body 
mass index of the child's mother and of the age of the child together with pointwise 80\% and 95\% 
credible intervals.}
\end{figure}
and are show in Figure~\ref{fig:zambia-agechild}. 
Figure~\ref{fig:zambia-district-structured-unstructured} shows estimates of the structured and 
unstructured spatial effect, generated with
<<zambia-agechild-bmi-plot, echo=TRUE, eval=FALSE>>=
plot(zm, term = c("s(district)", "r(district)"), 
  map = ZambiaBnd, pos = "topleft", 
  density = 20, angle = 90)
@
\begin{figure}[h!]
\setkeys{Gin}{width=0.46\textwidth}
\begin{center}
<<zambia-district-structured, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(zm, term = "s(district)", map = ZambiaBnd, 
  pos = "topleft", width = 0.6, height = 0.2, 
  distance.labels = 2, swap = TRUE)
@
<<zambia-district-unstructured, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(0, 0, 0, 0))
plot(zm, term = "r(district)", map = ZambiaBnd, 
  pos = "topleft", width = 0.6, height = 0.2, 
  distance.labels = 2L, swap = TRUE, 
  density = 20, angle = 90)
@
\end{center}
\caption{\label{fig:zambia-district-structured-unstructured} Example on childhood malnutrition:
Structured, left panel, and unstructured spatial effect, right panel respectively.}
\end{figure}
noting that if argument \code{map} is not supplied, the effects will also be visualized using 
function \fct{blockplot}. Besides plotting of sampling paths, as mentioned in 
Section~\ref{sec:implementation}, for any term in the model, the samples of the parameters are 
stored as an attribute in the fitted term object and are e.g. extracted for term \code{s(bmi)} by 
the following
<<zambia-coef-extract, echo=TRUE, eval=TRUE, fig=FALSE>>=
fit.bmi <- fitted(zm, term = "s(bmi)")
head(attr(fit.bmi, "sample"), 4)
head(attr(fit.bmi, "variance.sample"), 4)
@
where \code{"sample"} represents samples of regression coefficients and \code{"variance.sample"}
samples of the variance parameter of the smooth. In addition, autocorrelation functions may be 
drawn, for instance of the variance samples and the intercept, as shown in 
Figure~\ref{fig:zambia-autocorr}, by typing
<<zambia-autocorr-01, echo=TRUE, eval=FALSE>>=
plot(zm, term = "s(bmi)", which = "var-samples", 
  acf = TRUE, lag.max = 250)
plot(zm, which = "intcpt-samples", 
  acf = TRUE, lag.max = 250)
@
\begin{figure}[h!]
\setkeys{Gin}{width=0.46\textwidth}
\begin{center}
<<zambia-autocorr-02, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(1.1, 1.1, 0.1, 0.1))
plot(zm, term = "s(bmi)", which = "var-samples", 
  acf = TRUE, lag.max = 250, main = NA)
@
\end{center}
\caption{\label{fig:zambia-autocorr} Example on childhood undernutrition: Autocorrelation function
of the samples of the variance parameter of term \code{s(bmi)}.}
\end{figure}


\newpage


\subsection{Forest health data set} \label{subsec:forest}

The forest health dataset comprises information on the defoliation of beech trees, which serves as 
an indicator of overall forest health here. The data was collected annually from 1980 to 1997 during 
a project of visual inspection of trees around Rothenbuch, Germany, and is discussed in detail in 
\citet{Fahrmeir+Kneib+Lang:2009}, wherein the percentage rate of defoliation of each tree is 
aggregated into three ordinal categories, also see table~\ref{tab:forest} for a description of all 
variables in the dataset. 
\begin{table}[h!]
\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
Variable           & Description \\ \hline
\code{id}          & tree location identification number. \\ \hline
\code{year}        & year of census. \\ \hline
\code{defoliation} & percentage of tree defoliation in three ordinal
                     categories, 0 == `defoliation < 12.5\%', 1 == `12.5\% $\leq$
                     defoliation < 50\%' and 2 == `defoliation $\geq$ 50\%'. \\ \hline
\code{x}           & x-coordinate of the tree location. \\ \hline
\code{y}           & y-coordinate of the tree location. \\ \hline
\code{age}         & age of stands in years. \\ \hline
\code{canopy}      & forest canopy density in percent. \\ \hline
\code{inclination} & slope inclination in percent. \\ \hline
\code{elevation}   & elevation (meters above sea level). \\ \hline
\code{soil}        & soil layer depth in cm. \\ \hline
\code{ph}          & soil pH at 0-2cm depth. \\ \hline
\code{moisture}    & soil moisture level with categories 1 == `moderately
                     dry', 2 == `moderately moist' and 3 == `moist or temporarily
                     wet'. \\ \hline
\code{alkali}      & proportion of base alkali-ions with categories 1 == `low' 
                     to 4 == `high'. \\ \hline
\code{humus}       & humus layer thickness in cm. \\ \hline
\code{stand}       & stand type with categories `deciduous' and `mixed'. \\ \hline
\code{fertilized}  & fertilization applied with categories `yes' and `no'. \\ \hline
\end{tabular}
\caption{\label{tab:forest} Variables in the forest health data set.}
\end{center}
\end{table}

Following \citet{Fahrmeir+Kneib+Lang:2009}, we start with the following three categorical ordered 
logit model, where $P(\texttt{defoliation}_{it} = r)$ of tree $i$ at time $t$, $r = 1,2$, is modeled
in terms of a set of linearly and smooth entering covariates specified with
<<forest-model-formula-01, echo=TRUE, eval=TRUE>>=
data("ForestHealth", package = "R2BayesX")
mf <- defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22)
@
fit this model using REML and a cumulative multinomial distribution for the response by
<<fit-forest-model-01, echo=TRUE, eval=FALSE>>=
fm1 <- bayesx(mf, family = "cumlogit", 
  method = "REML", data = ForestHealth, dir.rm = FALSE)
@
<<fit-forest-model-02, echo=FALSE, eval=FALSE>>=
data("BeechBnd", package = "R2BayesX")
fm2 <- bayesx(defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22) + 
  s(id, bs = "gs", xt = list(map = BeechBnd), k = 22),
  family = "cumlogit", method = "REML", data = ForestHealth)
@
<<cache-forest-model, echo=FALSE, eval=TRUE>>=
if(file.exists("forest-model.rda")) {
load("forest-model.rda")
} else {
<<fit-forest-model-01>>
<<fit-forest-model-02>>
save(fm1, fm2, file = "forest-model.rda")
}
@
and finally visualize the estimated effects for the nonparametric modeled terms 
<<fit-forest-model-01-plots, echo=TRUE, eval=FALSE>>=
plot(fm2, term = c("s(age)","s(inclination)",
  "s(canopy)","s(year)","s(elevation)"))
@
as shown in Figure~\ref{fig:forest-no-spatial}. 
\begin{figure}[h!]
\setkeys{Gin}{width=0.46\textwidth}
\begin{center}
<<forest-no-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(age)")
@
<<forest-no-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(inclination)")
@ 
\\[2ex]

<<forest-no-spatial-canopy, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(canopy)")
@
<<forest-no-spatial-year, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(year)")
@ 
\\[2ex]

<<forest-no-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm1, term = "s(elevation)")
@
\end{center}
\caption{\label{fig:forest-no-spatial} Forest damage: Estimates of nonparametric effects including
80\% and 95\% point-wise confidence intervals of the model without the spatial effect.}
\end{figure}
In this example some contradictory results occur. 
The effect of covariate \code{age} on the \code{defoliation} seems to decline for both, younger and 
older trees, which intuitively should be a monotone increasing effect, this also holds for the 
effect of \code{elevation}. Moreover, the extremely raw estimate of \code{inclination} is hardly
interpretable. Therefore, the authors extend the model by a spatial effect, which we model with a
Markov random field using a graph file including the neighborhood information of the adjacent trees.
The graph file and a boundary file needed for producing a map plot of the effect, are loaded 
<<forest-model-gra-bnd, echo=TRUE, eval=TRUE>>=
data("BeechBnd", "BeechGra", package = "R2BayesX")
@
where \code{BeechGra} is a square matrix with the total number of neighbors of each tree on its 
diagonal
<<forest-model-gra-bnd, echo=TRUE, eval=TRUE>>=
diag(BeechGra)
@
and off diagonal elements have value \code{-1} if trees are neighbors, otherwise \code{0}. Involving
the spatial effect term we now fit the following model
<<fit-forest-model-02, echo=TRUE, eval=FALSE>>=
fm2 <- bayesx(defoliation ~  stand + fertilized + 
  humus + moisture + alkali + ph + soil + 
  s(age, bs = "ps", k = 22) + s(inclination, bs = "ps", k = 22) + 
  s(canopy, bs = "ps", k = 22) + s(year, bs = "ps", k = 22) + 
  s(elevation, bs = "ps", k = 22) + 
  s(id, bs = "mrf", xt = list(map = BeechGra)),
  family = "cumlogit", method = "REML", data = ForestHealth)
@
and have a first look at model information criteria with
<<summary-forest-model, echo=TRUE, eval=TRUE>>=
BIC(c(fm1, fm2))
GCV(c(fm1, fm2))
@
which clearly indicate a better fit by modeling the spatial effect of tree locations. The whole 
summary statistics for both models give 
<<summary-forest-model>>=
summary(c(fm1, fm2))
@
where the linear modeled terms in the second model seem to have a less important effect on tree 
defoliation, with similar findings for covariates \code{inclination} and \code{elevation} in 
Figure~\ref{fig:forest-spatial-nonpara}. 
\begin{figure}[h!]
\setkeys{Gin}{width=0.46\textwidth}
\begin{center}
<<forest-spatial-age, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(age)")
@
<<forest-spatial-inclination, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(inclination)")
@
\\[2ex]

<<forest-spatial-elevation, echo=FALSE, fig=TRUE, width=5, height=4>>=
par(mar = c(4.1, 4.1, 0.1, 2.1))
plot(fm2, term = "s(elevation)")
@
\end{center}
\caption{\label{fig:forest-spatial-nonpara} Forest damage: Estimates of particular nonparametric 
effects including 80\% and 95\% point-wise confidence intervals of the model including the spatial 
effect.}
\end{figure}
However, the estimate of the \code{age} effect seems to be improved in terms of monotonicity. The 
estimated spatial effect is shown in Figure~\ref{fig:forest-spatial}. Summarizing these results 
identifies a strong influence of the spatial effect of the overall model fit, indicating that a 
clear splitting of locational specific covariates and the spatial effect is hardly possible in this 
example. 
\begin{figure}[h!]
\setkeys{Gin}{width=0.64\textwidth}
\begin{center}
<<forest-spatial-id, echo=FALSE, fig=TRUE, width=7.3, height=4.5>>=
par(mar = c(4.1, 4.1, 1, 3.8))
plot(fm2, term = "s(id)", image = TRUE, grid = 200, 
  range = c(-7, 7), lrange = c(-10, 10), 
  image.map = BeechBnd, linear = FALSE, 
  extrap = TRUE, outscale = 0.05)
@
\end{center}
\caption{\label{fig:forest-spatial} Forest damage: Estimate of the spatial effect.}
\end{figure}

\section{Summary}\label{sec:conclusion}


\section*{Acknowledgments}

\nocite{Kneib+Heinzl+Brezger:2011}
\bibliography{R2BayesX}


\begin{appendix}


\section[Installation of BayesX]{Installation of BayesX} \label{sec:installation}

\subsection[Windows systems]{Windows systems} \label{subsec:wininstall}
The installation routine 
\href{http://www.stat.uni-muenchen.de/~bayesx/install/BayesX_windows.exe}{BayesX\_windows.exe}
may be downloaded from the BayesX homepage and executed. The routine will request all necessary 
information during the installation process. It is recommended to install BayesX in a directory 
without spaces in the path name. This will install a pre-compiled computing kernel including a Java 
graphical interface, which automatically installs the necessary command line version of BayesX for 
use within the \proglang{R} interface. The binary is named \code{bayesx.exe} and is stored in the 
\code{commandline} directory of the BayesX installation folder.

\subsection[Other systems]{Other systems} \label{subsec:otherinstall}
The zip archive named 
\href{http://www.stat.uni-muenchen.de/~bayesx/install/bayesxsource.zip}{\code{bayesxsource.zip}}, 
containing the \proglang{C++} source code of BayesX, needs to be downloaded and unpacked. If the make 
facility is available, one can simply type make BayesX in the shell and BayesX will be compiled. 
Depending on the operating system, some minor modifications of the make file (for example relating 
to the version of the installed GNU compiler or the location of the readline library) may be 
necessary. For MAC OS, versions of an adjusted makefile and the main function that have been used
for a sucessful compilation may be found at the
\href{http://www.stat.uni-muenchen.de/~bayesx/bayesxfaq.html}{FAQ site}.
\end{appendix}


\end{document}
